{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentials = void 0;\n\nconst metadata_1 = require(\"./metadata\");\n\nfunction isCurrentOauth2Client(client) {\n  return 'getRequestHeaders' in client && typeof client.getRequestHeaders === 'function';\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\n\n\nclass CallCredentials {\n  /**\n   * Creates a new CallCredentials object from a given function that generates\n   * Metadata objects.\n   * @param metadataGenerator A function that accepts a set of options, and\n   * generates a Metadata object based on these options, which is passed back\n   * to the caller via a supplied (err, metadata) callback.\n   */\n  static createFromMetadataGenerator(metadataGenerator) {\n    return new SingleCallCredentials(metadataGenerator);\n  }\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n\n\n  static createFromGoogleCredential(googleCredentials) {\n    return CallCredentials.createFromMetadataGenerator((options, callback) => {\n      let getHeaders;\n\n      if (isCurrentOauth2Client(googleCredentials)) {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise((resolve, reject) => {\n          googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(headers);\n          });\n        });\n      }\n\n      getHeaders.then(headers => {\n        const metadata = new metadata_1.Metadata();\n\n        for (const key of Object.keys(headers)) {\n          metadata.add(key, headers[key]);\n        }\n\n        callback(null, metadata);\n      }, err => {\n        callback(err);\n      });\n    });\n  }\n\n  static createEmpty() {\n    return new EmptyCallCredentials();\n  }\n\n}\n\nexports.CallCredentials = CallCredentials;\n\nclass ComposedCallCredentials extends CallCredentials {\n  constructor(creds) {\n    super();\n    this.creds = creds;\n  }\n\n  generateMetadata(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const base = new metadata_1.Metadata();\n      const generated = yield Promise.all(_this.creds.map(cred => cred.generateMetadata(options)));\n\n      for (const gen of generated) {\n        base.merge(gen);\n      }\n\n      return base;\n    })();\n  }\n\n  compose(other) {\n    return new ComposedCallCredentials(this.creds.concat([other]));\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ComposedCallCredentials) {\n      return this.creds.every((value, index) => value._equals(other.creds[index]));\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass SingleCallCredentials extends CallCredentials {\n  constructor(metadataGenerator) {\n    super();\n    this.metadataGenerator = metadataGenerator;\n  }\n\n  generateMetadata(options) {\n    return new Promise((resolve, reject) => {\n      this.metadataGenerator(options, (err, metadata) => {\n        if (metadata !== undefined) {\n          resolve(metadata);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  }\n\n  compose(other) {\n    return new ComposedCallCredentials([this, other]);\n  }\n\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof SingleCallCredentials) {\n      return this.metadataGenerator === other.metadataGenerator;\n    } else {\n      return false;\n    }\n  }\n\n}\n\nclass EmptyCallCredentials extends CallCredentials {\n  generateMetadata(options) {\n    return Promise.resolve(new metadata_1.Metadata());\n  }\n\n  compose(other) {\n    return other;\n  }\n\n  _equals(other) {\n    return other instanceof EmptyCallCredentials;\n  }\n\n} //# sourceMappingURL=call-credentials.js.map","map":null,"metadata":{},"sourceType":"script"}