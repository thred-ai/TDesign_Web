{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_1 = require(\"./filter\");\n\nconst units = [['m', 1], ['S', 1000], ['M', 60 * 1000], ['H', 60 * 60 * 1000]];\n\nfunction getDeadline(deadline) {\n  const now = new Date().getTime();\n  const timeoutMs = Math.max(deadline - now, 0);\n\n  for (const [unit, factor] of units) {\n    const amount = timeoutMs / factor;\n\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n\n  throw new Error('Deadline is too far in the future');\n}\n\nclass DeadlineFilter extends filter_1.BaseFilter {\n  constructor(channel, callStream) {\n    var _a, _b;\n\n    super();\n    this.channel = channel;\n    this.callStream = callStream;\n    this.timer = null;\n    const callDeadline = callStream.getDeadline();\n\n    if (callDeadline instanceof Date) {\n      this.deadline = callDeadline.getTime();\n    } else {\n      this.deadline = callDeadline;\n    }\n\n    const now = new Date().getTime();\n    let timeout = this.deadline - now;\n\n    if (timeout <= 0) {\n      process.nextTick(() => {\n        callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      });\n    } else if (this.deadline !== Infinity) {\n      this.timer = setTimeout(() => {\n        callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      }, timeout);\n      (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  sendMetadata(metadata) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.deadline === Infinity) {\n        return metadata;\n      }\n      /* The input metadata promise depends on the original channel.connect()\n       * promise, so when it is complete that implies that the channel is\n       * connected */\n\n\n      const finalMetadata = yield metadata;\n      const timeoutString = getDeadline(_this.deadline);\n      finalMetadata.set('grpc-timeout', timeoutString);\n      return finalMetadata;\n    })();\n  }\n\n  receiveTrailers(status) {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n\n    return status;\n  }\n\n}\n\nexports.DeadlineFilter = DeadlineFilter;\n\nclass DeadlineFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new DeadlineFilter(this.channel, callStream);\n  }\n\n}\n\nexports.DeadlineFilterFactory = DeadlineFilterFactory; //# sourceMappingURL=deadline-filter.js.map","map":null,"metadata":{},"sourceType":"script"}