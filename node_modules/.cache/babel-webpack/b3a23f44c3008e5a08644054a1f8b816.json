{"ast":null,"code":"\"use strict\";\n\nmodule.exports = HTMLParser;\n\nvar Document = require('./Document');\n\nvar DocumentType = require('./DocumentType');\n\nvar Node = require('./Node');\n\nvar NAMESPACE = require('./utils').NAMESPACE;\n\nvar html = require('./htmlelts');\n\nvar impl = html.elements;\nvar pushAll = Function.prototype.apply.bind(Array.prototype.push);\n/*\n * This file contains an implementation of the HTML parsing algorithm.\n * The algorithm and the implementation are complex because HTML\n * explicitly defines how the parser should behave for all possible\n * valid and invalid inputs.\n *\n * Usage:\n *\n * The file defines a single HTMLParser() function, which dom.js exposes\n * publicly as document.implementation.mozHTMLParser(). This is a\n * factory function, not a constructor.\n *\n * When you call document.implementation.mozHTMLParser(), it returns\n * an object that has parse() and document() methods. To parse HTML text,\n * pass the text (in one or more chunks) to the parse() method.  When\n * you've passed all the text (on the last chunk, or afterward) pass\n * true as the second argument to parse() to tell the parser that there\n * is no more coming. Call document() to get the document object that\n * the parser is parsing into.  You can call this at any time, before\n * or after calling parse().\n *\n * The first argument to mozHTMLParser is the absolute URL of the document.\n *\n * The second argument is optional and is for internal use only.  Pass an\n * element as the fragmentContext to do innerHTML parsing for the\n * element.  To do innerHTML parsing on a document, pass null. Otherwise,\n * omit the 2nd argument. See HTMLElement.innerHTML for an example.  Note\n * that if you pass a context element, the end() method will return an\n * unwrapped document instead of a wrapped one.\n *\n * Implementation details:\n *\n * This is a long file of almost 7000 lines. It is structured as one\n * big function nested within another big function.  The outer\n * function defines a bunch of constant data, utility functions\n * that use that data, and a couple of classes used by the parser.\n * The outer function also defines and returns the\n * inner function. This inner function is the HTMLParser factory\n * function that implements the parser and holds all the parser state\n * as local variables.  The HTMLParser function is quite big because\n * it defines many nested functions that use those local variables.\n *\n * There are three tightly coupled parser stages: a scanner, a\n * tokenizer and a tree builder. In a (possibly misguided) attempt at\n * efficiency, the stages are not implemented as separate classes:\n * everything shares state and is (mostly) implemented in imperative\n * (rather than OO) style.\n *\n * The stages of the parser work like this: When the client code calls\n * the parser's parse() method, the specified string is passed to\n * scanChars(). The scanner loops through that string and passes characters\n * (sometimes one at a time, sometimes in chunks) to the tokenizer stage.\n * The tokenizer groups the characters into tokens: tags, endtags, runs\n * of text, comments, doctype declarations, and the end-of-file (EOF)\n * token.  These tokens are then passed to the tree building stage via\n * the insertToken() function.  The tree building stage builds up the\n * document tree.\n *\n * The tokenizer stage is a finite state machine.  Each state is\n * implemented as a function with a name that ends in \"_state\".  The\n * initial state is data_state(). The current tokenizer state is stored\n * in the variable 'tokenizer'.  Most state functions expect a single\n * integer argument which represents a single UTF-16 codepoint.  Some\n * states want more characters and set a lookahead property on\n * themselves.  The scanChars() function in the scanner checks for this\n * lookahead property.  If it doesn't exist, then scanChars() just passes\n * the next input character to the current tokenizer state function.\n * Otherwise, scanChars() looks ahead (a given # of characters, or for a\n * matching string, or for a matching regexp) and passes a string of\n * characters to the current tokenizer state function.\n *\n * As a shortcut, certain states of the tokenizer use regular expressions\n * to look ahead in the scanner's input buffer for runs of text, simple\n * tags and attributes.  For well-formed input, these shortcuts skip a\n * lot of state transitions and speed things up a bit.\n *\n * When a tokenizer state function has consumed a complete token, it\n * emits that token, by calling insertToken(), or by calling a utility\n * function that itself calls insertToken().  These tokens are passed to\n * the tree building stage, which is also a state machine.  Like the\n * tokenizer, the tree building states are implemented as functions, and\n * these functions have names that end with _mode (because the HTML spec\n * refers to them as insertion modes). The current insertion mode is held\n * by the 'parser' variable.  Each insertion mode function takes up to 4\n * arguments.  The first is a token type, represented by the constants\n * TAG, ENDTAG, TEXT, COMMENT, DOCTYPE and EOF.  The second argument is\n * the value of the token: the text or comment data, or tagname or\n * doctype.  For tags, the 3rd argument is an array of attributes.  For\n * DOCTYPES it is the optional public id.  For tags, the 4th argument is\n * true if the tag is self-closing. For doctypes, the 4th argument is the\n * optional system id.\n *\n * Search for \"***\" to find the major sub-divisions in the code.\n */\n\n/***\n * Data prolog.  Lots of constants declared here, including some\n * very large objects.  They're used throughout the code that follows\n */\n// Token types for the tree builder.\n\nvar EOF = -1;\nvar TEXT = 1;\nvar TAG = 2;\nvar ENDTAG = 3;\nvar COMMENT = 4;\nvar DOCTYPE = 5; // A re-usable empty array\n\nvar NOATTRS = []; // These DTD public ids put the browser in quirks mode\n\nvar quirkyPublicIds = /^HTML$|^-\\/\\/W3O\\/\\/DTD W3 HTML Strict 3\\.0\\/\\/EN\\/\\/$|^-\\/W3C\\/DTD HTML 4\\.0 Transitional\\/EN$|^\\+\\/\\/Silmaril\\/\\/dtd html Pro v0r11 19970101\\/\\/|^-\\/\\/AdvaSoft Ltd\\/\\/DTD HTML 3\\.0 asWedit \\+ extensions\\/\\/|^-\\/\\/AS\\/\\/DTD HTML 3\\.0 asWedit \\+ extensions\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Strict Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Strict Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Strict\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.1E\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\.0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\.2 Final\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\.2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 3\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 3\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML\\/\\/|^-\\/\\/Metrius\\/\\/DTD Metrius Presentational\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 2\\.0 HTML Strict\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 2\\.0 HTML\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 2\\.0 Tables\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 3\\.0 HTML Strict\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 3\\.0 HTML\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 3\\.0 Tables\\/\\/|^-\\/\\/Netscape Comm\\. Corp\\.\\/\\/DTD HTML\\/\\/|^-\\/\\/Netscape Comm\\. Corp\\.\\/\\/DTD Strict HTML\\/\\/|^-\\/\\/O'Reilly and Associates\\/\\/DTD HTML 2\\.0\\/\\/|^-\\/\\/O'Reilly and Associates\\/\\/DTD HTML Extended 1\\.0\\/\\/|^-\\/\\/O'Reilly and Associates\\/\\/DTD HTML Extended Relaxed 1\\.0\\/\\/|^-\\/\\/SoftQuad Software\\/\\/DTD HoTMetaL PRO 6\\.0::19990601::extensions to HTML 4\\.0\\/\\/|^-\\/\\/SoftQuad\\/\\/DTD HoTMetaL PRO 4\\.0::19971010::extensions to HTML 4\\.0\\/\\/|^-\\/\\/Spyglass\\/\\/DTD HTML 2\\.0 Extended\\/\\/|^-\\/\\/SQ\\/\\/DTD HTML 2\\.0 HoTMetaL \\+ extensions\\/\\/|^-\\/\\/Sun Microsystems Corp\\.\\/\\/DTD HotJava HTML\\/\\/|^-\\/\\/Sun Microsystems Corp\\.\\/\\/DTD HotJava Strict HTML\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3 1995-03-24\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2 Draft\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2 Final\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2S Draft\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 4\\.0 Frameset\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 4\\.0 Transitional\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML Experimental 19960712\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML Experimental 970421\\/\\/|^-\\/\\/W3C\\/\\/DTD W3 HTML\\/\\/|^-\\/\\/W3O\\/\\/DTD W3 HTML 3\\.0\\/\\/|^-\\/\\/WebTechs\\/\\/DTD Mozilla HTML 2\\.0\\/\\/|^-\\/\\/WebTechs\\/\\/DTD Mozilla HTML\\/\\//i;\nvar quirkySystemId = \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\";\nvar conditionallyQuirkyPublicIds = /^-\\/\\/W3C\\/\\/DTD HTML 4\\.01 Frameset\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 4\\.01 Transitional\\/\\//i; // These DTD public ids put the browser in limited quirks mode\n\nvar limitedQuirkyPublicIds = /^-\\/\\/W3C\\/\\/DTD XHTML 1\\.0 Frameset\\/\\/|^-\\/\\/W3C\\/\\/DTD XHTML 1\\.0 Transitional\\/\\//i; // Element sets below. See the isA() function for a way to test\n// whether an element is a member of a set\n\nvar specialSet = Object.create(null);\nspecialSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"address\": true,\n  \"applet\": true,\n  \"area\": true,\n  \"article\": true,\n  \"aside\": true,\n  \"base\": true,\n  \"basefont\": true,\n  \"bgsound\": true,\n  \"blockquote\": true,\n  \"body\": true,\n  \"br\": true,\n  \"button\": true,\n  \"caption\": true,\n  \"center\": true,\n  \"col\": true,\n  \"colgroup\": true,\n  \"dd\": true,\n  \"details\": true,\n  \"dir\": true,\n  \"div\": true,\n  \"dl\": true,\n  \"dt\": true,\n  \"embed\": true,\n  \"fieldset\": true,\n  \"figcaption\": true,\n  \"figure\": true,\n  \"footer\": true,\n  \"form\": true,\n  \"frame\": true,\n  \"frameset\": true,\n  \"h1\": true,\n  \"h2\": true,\n  \"h3\": true,\n  \"h4\": true,\n  \"h5\": true,\n  \"h6\": true,\n  \"head\": true,\n  \"header\": true,\n  \"hgroup\": true,\n  \"hr\": true,\n  \"html\": true,\n  \"iframe\": true,\n  \"img\": true,\n  \"input\": true,\n  \"li\": true,\n  \"link\": true,\n  \"listing\": true,\n  \"main\": true,\n  \"marquee\": true,\n  \"menu\": true,\n  \"meta\": true,\n  \"nav\": true,\n  \"noembed\": true,\n  \"noframes\": true,\n  \"noscript\": true,\n  \"object\": true,\n  \"ol\": true,\n  \"p\": true,\n  \"param\": true,\n  \"plaintext\": true,\n  \"pre\": true,\n  \"script\": true,\n  \"section\": true,\n  \"select\": true,\n  \"source\": true,\n  \"style\": true,\n  \"summary\": true,\n  \"table\": true,\n  \"tbody\": true,\n  \"td\": true,\n  \"template\": true,\n  \"textarea\": true,\n  \"tfoot\": true,\n  \"th\": true,\n  \"thead\": true,\n  \"title\": true,\n  \"tr\": true,\n  \"track\": true,\n  // Note that \"xmp\" was removed from the \"special\" set in the latest\n  // spec, apparently by accident; see\n  // https://github.com/whatwg/html/pull/1919\n  \"ul\": true,\n  \"wbr\": true,\n  \"xmp\": true\n};\nspecialSet[NAMESPACE.SVG] = {\n  __proto__: null,\n  \"foreignObject\": true,\n  \"desc\": true,\n  \"title\": true\n};\nspecialSet[NAMESPACE.MATHML] = {\n  __proto__: null,\n  \"mi\": true,\n  \"mo\": true,\n  \"mn\": true,\n  \"ms\": true,\n  \"mtext\": true,\n  \"annotation-xml\": true\n}; // The set of address, div, and p HTML tags\n\nvar addressdivpSet = Object.create(null);\naddressdivpSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"address\": true,\n  \"div\": true,\n  \"p\": true\n};\nvar dddtSet = Object.create(null);\ndddtSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"dd\": true,\n  \"dt\": true\n};\nvar tablesectionrowSet = Object.create(null);\ntablesectionrowSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"table\": true,\n  \"thead\": true,\n  \"tbody\": true,\n  \"tfoot\": true,\n  \"tr\": true\n};\nvar impliedEndTagsSet = Object.create(null);\nimpliedEndTagsSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"dd\": true,\n  \"dt\": true,\n  \"li\": true,\n  \"menuitem\": true,\n  \"optgroup\": true,\n  \"option\": true,\n  \"p\": true,\n  \"rb\": true,\n  \"rp\": true,\n  \"rt\": true,\n  \"rtc\": true\n};\nvar thoroughImpliedEndTagsSet = Object.create(null);\nthoroughImpliedEndTagsSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"caption\": true,\n  \"colgroup\": true,\n  \"dd\": true,\n  \"dt\": true,\n  \"li\": true,\n  \"optgroup\": true,\n  \"option\": true,\n  \"p\": true,\n  \"rb\": true,\n  \"rp\": true,\n  \"rt\": true,\n  \"rtc\": true,\n  \"tbody\": true,\n  \"td\": true,\n  \"tfoot\": true,\n  \"th\": true,\n  \"thead\": true,\n  \"tr\": true\n};\nvar tableContextSet = Object.create(null);\ntableContextSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"table\": true,\n  \"template\": true,\n  \"html\": true\n};\nvar tableBodyContextSet = Object.create(null);\ntableBodyContextSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"tbody\": true,\n  \"tfoot\": true,\n  \"thead\": true,\n  \"template\": true,\n  \"html\": true\n};\nvar tableRowContextSet = Object.create(null);\ntableRowContextSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"tr\": true,\n  \"template\": true,\n  \"html\": true\n}; // See http://www.w3.org/TR/html5/forms.html#form-associated-element\n\nvar formassociatedSet = Object.create(null);\nformassociatedSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"button\": true,\n  \"fieldset\": true,\n  \"input\": true,\n  \"keygen\": true,\n  \"object\": true,\n  \"output\": true,\n  \"select\": true,\n  \"textarea\": true,\n  \"img\": true\n};\nvar inScopeSet = Object.create(null);\ninScopeSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"applet\": true,\n  \"caption\": true,\n  \"html\": true,\n  \"table\": true,\n  \"td\": true,\n  \"th\": true,\n  \"marquee\": true,\n  \"object\": true,\n  \"template\": true\n};\ninScopeSet[NAMESPACE.MATHML] = {\n  __proto__: null,\n  \"mi\": true,\n  \"mo\": true,\n  \"mn\": true,\n  \"ms\": true,\n  \"mtext\": true,\n  \"annotation-xml\": true\n};\ninScopeSet[NAMESPACE.SVG] = {\n  __proto__: null,\n  \"foreignObject\": true,\n  \"desc\": true,\n  \"title\": true\n};\nvar inListItemScopeSet = Object.create(inScopeSet);\ninListItemScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);\ninListItemScopeSet[NAMESPACE.HTML].ol = true;\ninListItemScopeSet[NAMESPACE.HTML].ul = true;\nvar inButtonScopeSet = Object.create(inScopeSet);\ninButtonScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);\ninButtonScopeSet[NAMESPACE.HTML].button = true;\nvar inTableScopeSet = Object.create(null);\ninTableScopeSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"html\": true,\n  \"table\": true,\n  \"template\": true\n}; // The set of elements for select scope is the everything *except* these\n\nvar invertedSelectScopeSet = Object.create(null);\ninvertedSelectScopeSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"optgroup\": true,\n  \"option\": true\n};\nvar mathmlTextIntegrationPointSet = Object.create(null);\nmathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {\n  __proto__: null,\n  mi: true,\n  mo: true,\n  mn: true,\n  ms: true,\n  mtext: true\n};\nvar htmlIntegrationPointSet = Object.create(null);\nhtmlIntegrationPointSet[NAMESPACE.SVG] = {\n  __proto__: null,\n  foreignObject: true,\n  desc: true,\n  title: true\n};\nvar foreignAttributes = {\n  __proto__: null,\n  \"xlink:actuate\": NAMESPACE.XLINK,\n  \"xlink:arcrole\": NAMESPACE.XLINK,\n  \"xlink:href\": NAMESPACE.XLINK,\n  \"xlink:role\": NAMESPACE.XLINK,\n  \"xlink:show\": NAMESPACE.XLINK,\n  \"xlink:title\": NAMESPACE.XLINK,\n  \"xlink:type\": NAMESPACE.XLINK,\n  \"xml:base\": NAMESPACE.XML,\n  \"xml:lang\": NAMESPACE.XML,\n  \"xml:space\": NAMESPACE.XML,\n  \"xmlns\": NAMESPACE.XMLNS,\n  \"xmlns:xlink\": NAMESPACE.XMLNS\n}; // Lowercase to mixed case mapping for SVG attributes and tagnames\n\nvar svgAttrAdjustments = {\n  __proto__: null,\n  attributename: \"attributeName\",\n  attributetype: \"attributeType\",\n  basefrequency: \"baseFrequency\",\n  baseprofile: \"baseProfile\",\n  calcmode: \"calcMode\",\n  clippathunits: \"clipPathUnits\",\n  diffuseconstant: \"diffuseConstant\",\n  edgemode: \"edgeMode\",\n  filterunits: \"filterUnits\",\n  glyphref: \"glyphRef\",\n  gradienttransform: \"gradientTransform\",\n  gradientunits: \"gradientUnits\",\n  kernelmatrix: \"kernelMatrix\",\n  kernelunitlength: \"kernelUnitLength\",\n  keypoints: \"keyPoints\",\n  keysplines: \"keySplines\",\n  keytimes: \"keyTimes\",\n  lengthadjust: \"lengthAdjust\",\n  limitingconeangle: \"limitingConeAngle\",\n  markerheight: \"markerHeight\",\n  markerunits: \"markerUnits\",\n  markerwidth: \"markerWidth\",\n  maskcontentunits: \"maskContentUnits\",\n  maskunits: \"maskUnits\",\n  numoctaves: \"numOctaves\",\n  pathlength: \"pathLength\",\n  patterncontentunits: \"patternContentUnits\",\n  patterntransform: \"patternTransform\",\n  patternunits: \"patternUnits\",\n  pointsatx: \"pointsAtX\",\n  pointsaty: \"pointsAtY\",\n  pointsatz: \"pointsAtZ\",\n  preservealpha: \"preserveAlpha\",\n  preserveaspectratio: \"preserveAspectRatio\",\n  primitiveunits: \"primitiveUnits\",\n  refx: \"refX\",\n  refy: \"refY\",\n  repeatcount: \"repeatCount\",\n  repeatdur: \"repeatDur\",\n  requiredextensions: \"requiredExtensions\",\n  requiredfeatures: \"requiredFeatures\",\n  specularconstant: \"specularConstant\",\n  specularexponent: \"specularExponent\",\n  spreadmethod: \"spreadMethod\",\n  startoffset: \"startOffset\",\n  stddeviation: \"stdDeviation\",\n  stitchtiles: \"stitchTiles\",\n  surfacescale: \"surfaceScale\",\n  systemlanguage: \"systemLanguage\",\n  tablevalues: \"tableValues\",\n  targetx: \"targetX\",\n  targety: \"targetY\",\n  textlength: \"textLength\",\n  viewbox: \"viewBox\",\n  viewtarget: \"viewTarget\",\n  xchannelselector: \"xChannelSelector\",\n  ychannelselector: \"yChannelSelector\",\n  zoomandpan: \"zoomAndPan\"\n};\nvar svgTagNameAdjustments = {\n  __proto__: null,\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\",\n  textpath: \"textPath\"\n}; // Data for parsing numeric and named character references\n// These next 3 objects are direct translations of tables\n// in the HTML spec into JavaScript object format\n\nvar numericCharRefReplacements = {\n  __proto__: null,\n  0x00: 0xFFFD,\n  0x80: 0x20AC,\n  0x82: 0x201A,\n  0x83: 0x0192,\n  0x84: 0x201E,\n  0x85: 0x2026,\n  0x86: 0x2020,\n  0x87: 0x2021,\n  0x88: 0x02C6,\n  0x89: 0x2030,\n  0x8A: 0x0160,\n  0x8B: 0x2039,\n  0x8C: 0x0152,\n  0x8E: 0x017D,\n  0x91: 0x2018,\n  0x92: 0x2019,\n  0x93: 0x201C,\n  0x94: 0x201D,\n  0x95: 0x2022,\n  0x96: 0x2013,\n  0x97: 0x2014,\n  0x98: 0x02DC,\n  0x99: 0x2122,\n  0x9A: 0x0161,\n  0x9B: 0x203A,\n  0x9C: 0x0153,\n  0x9E: 0x017E,\n  0x9F: 0x0178\n};\n/*\n * This table is generated with test/tools/update-entities.js\n */\n\nvar namedCharRefs = {\n  __proto__: null,\n  \"AElig\": 0xc6,\n  \"AElig;\": 0xc6,\n  \"AMP\": 0x26,\n  \"AMP;\": 0x26,\n  \"Aacute\": 0xc1,\n  \"Aacute;\": 0xc1,\n  \"Abreve;\": 0x102,\n  \"Acirc\": 0xc2,\n  \"Acirc;\": 0xc2,\n  \"Acy;\": 0x410,\n  \"Afr;\": [0xd835, 0xdd04],\n  \"Agrave\": 0xc0,\n  \"Agrave;\": 0xc0,\n  \"Alpha;\": 0x391,\n  \"Amacr;\": 0x100,\n  \"And;\": 0x2a53,\n  \"Aogon;\": 0x104,\n  \"Aopf;\": [0xd835, 0xdd38],\n  \"ApplyFunction;\": 0x2061,\n  \"Aring\": 0xc5,\n  \"Aring;\": 0xc5,\n  \"Ascr;\": [0xd835, 0xdc9c],\n  \"Assign;\": 0x2254,\n  \"Atilde\": 0xc3,\n  \"Atilde;\": 0xc3,\n  \"Auml\": 0xc4,\n  \"Auml;\": 0xc4,\n  \"Backslash;\": 0x2216,\n  \"Barv;\": 0x2ae7,\n  \"Barwed;\": 0x2306,\n  \"Bcy;\": 0x411,\n  \"Because;\": 0x2235,\n  \"Bernoullis;\": 0x212c,\n  \"Beta;\": 0x392,\n  \"Bfr;\": [0xd835, 0xdd05],\n  \"Bopf;\": [0xd835, 0xdd39],\n  \"Breve;\": 0x2d8,\n  \"Bscr;\": 0x212c,\n  \"Bumpeq;\": 0x224e,\n  \"CHcy;\": 0x427,\n  \"COPY\": 0xa9,\n  \"COPY;\": 0xa9,\n  \"Cacute;\": 0x106,\n  \"Cap;\": 0x22d2,\n  \"CapitalDifferentialD;\": 0x2145,\n  \"Cayleys;\": 0x212d,\n  \"Ccaron;\": 0x10c,\n  \"Ccedil\": 0xc7,\n  \"Ccedil;\": 0xc7,\n  \"Ccirc;\": 0x108,\n  \"Cconint;\": 0x2230,\n  \"Cdot;\": 0x10a,\n  \"Cedilla;\": 0xb8,\n  \"CenterDot;\": 0xb7,\n  \"Cfr;\": 0x212d,\n  \"Chi;\": 0x3a7,\n  \"CircleDot;\": 0x2299,\n  \"CircleMinus;\": 0x2296,\n  \"CirclePlus;\": 0x2295,\n  \"CircleTimes;\": 0x2297,\n  \"ClockwiseContourIntegral;\": 0x2232,\n  \"CloseCurlyDoubleQuote;\": 0x201d,\n  \"CloseCurlyQuote;\": 0x2019,\n  \"Colon;\": 0x2237,\n  \"Colone;\": 0x2a74,\n  \"Congruent;\": 0x2261,\n  \"Conint;\": 0x222f,\n  \"ContourIntegral;\": 0x222e,\n  \"Copf;\": 0x2102,\n  \"Coproduct;\": 0x2210,\n  \"CounterClockwiseContourIntegral;\": 0x2233,\n  \"Cross;\": 0x2a2f,\n  \"Cscr;\": [0xd835, 0xdc9e],\n  \"Cup;\": 0x22d3,\n  \"CupCap;\": 0x224d,\n  \"DD;\": 0x2145,\n  \"DDotrahd;\": 0x2911,\n  \"DJcy;\": 0x402,\n  \"DScy;\": 0x405,\n  \"DZcy;\": 0x40f,\n  \"Dagger;\": 0x2021,\n  \"Darr;\": 0x21a1,\n  \"Dashv;\": 0x2ae4,\n  \"Dcaron;\": 0x10e,\n  \"Dcy;\": 0x414,\n  \"Del;\": 0x2207,\n  \"Delta;\": 0x394,\n  \"Dfr;\": [0xd835, 0xdd07],\n  \"DiacriticalAcute;\": 0xb4,\n  \"DiacriticalDot;\": 0x2d9,\n  \"DiacriticalDoubleAcute;\": 0x2dd,\n  \"DiacriticalGrave;\": 0x60,\n  \"DiacriticalTilde;\": 0x2dc,\n  \"Diamond;\": 0x22c4,\n  \"DifferentialD;\": 0x2146,\n  \"Dopf;\": [0xd835, 0xdd3b],\n  \"Dot;\": 0xa8,\n  \"DotDot;\": 0x20dc,\n  \"DotEqual;\": 0x2250,\n  \"DoubleContourIntegral;\": 0x222f,\n  \"DoubleDot;\": 0xa8,\n  \"DoubleDownArrow;\": 0x21d3,\n  \"DoubleLeftArrow;\": 0x21d0,\n  \"DoubleLeftRightArrow;\": 0x21d4,\n  \"DoubleLeftTee;\": 0x2ae4,\n  \"DoubleLongLeftArrow;\": 0x27f8,\n  \"DoubleLongLeftRightArrow;\": 0x27fa,\n  \"DoubleLongRightArrow;\": 0x27f9,\n  \"DoubleRightArrow;\": 0x21d2,\n  \"DoubleRightTee;\": 0x22a8,\n  \"DoubleUpArrow;\": 0x21d1,\n  \"DoubleUpDownArrow;\": 0x21d5,\n  \"DoubleVerticalBar;\": 0x2225,\n  \"DownArrow;\": 0x2193,\n  \"DownArrowBar;\": 0x2913,\n  \"DownArrowUpArrow;\": 0x21f5,\n  \"DownBreve;\": 0x311,\n  \"DownLeftRightVector;\": 0x2950,\n  \"DownLeftTeeVector;\": 0x295e,\n  \"DownLeftVector;\": 0x21bd,\n  \"DownLeftVectorBar;\": 0x2956,\n  \"DownRightTeeVector;\": 0x295f,\n  \"DownRightVector;\": 0x21c1,\n  \"DownRightVectorBar;\": 0x2957,\n  \"DownTee;\": 0x22a4,\n  \"DownTeeArrow;\": 0x21a7,\n  \"Downarrow;\": 0x21d3,\n  \"Dscr;\": [0xd835, 0xdc9f],\n  \"Dstrok;\": 0x110,\n  \"ENG;\": 0x14a,\n  \"ETH\": 0xd0,\n  \"ETH;\": 0xd0,\n  \"Eacute\": 0xc9,\n  \"Eacute;\": 0xc9,\n  \"Ecaron;\": 0x11a,\n  \"Ecirc\": 0xca,\n  \"Ecirc;\": 0xca,\n  \"Ecy;\": 0x42d,\n  \"Edot;\": 0x116,\n  \"Efr;\": [0xd835, 0xdd08],\n  \"Egrave\": 0xc8,\n  \"Egrave;\": 0xc8,\n  \"Element;\": 0x2208,\n  \"Emacr;\": 0x112,\n  \"EmptySmallSquare;\": 0x25fb,\n  \"EmptyVerySmallSquare;\": 0x25ab,\n  \"Eogon;\": 0x118,\n  \"Eopf;\": [0xd835, 0xdd3c],\n  \"Epsilon;\": 0x395,\n  \"Equal;\": 0x2a75,\n  \"EqualTilde;\": 0x2242,\n  \"Equilibrium;\": 0x21cc,\n  \"Escr;\": 0x2130,\n  \"Esim;\": 0x2a73,\n  \"Eta;\": 0x397,\n  \"Euml\": 0xcb,\n  \"Euml;\": 0xcb,\n  \"Exists;\": 0x2203,\n  \"ExponentialE;\": 0x2147,\n  \"Fcy;\": 0x424,\n  \"Ffr;\": [0xd835, 0xdd09],\n  \"FilledSmallSquare;\": 0x25fc,\n  \"FilledVerySmallSquare;\": 0x25aa,\n  \"Fopf;\": [0xd835, 0xdd3d],\n  \"ForAll;\": 0x2200,\n  \"Fouriertrf;\": 0x2131,\n  \"Fscr;\": 0x2131,\n  \"GJcy;\": 0x403,\n  \"GT\": 0x3e,\n  \"GT;\": 0x3e,\n  \"Gamma;\": 0x393,\n  \"Gammad;\": 0x3dc,\n  \"Gbreve;\": 0x11e,\n  \"Gcedil;\": 0x122,\n  \"Gcirc;\": 0x11c,\n  \"Gcy;\": 0x413,\n  \"Gdot;\": 0x120,\n  \"Gfr;\": [0xd835, 0xdd0a],\n  \"Gg;\": 0x22d9,\n  \"Gopf;\": [0xd835, 0xdd3e],\n  \"GreaterEqual;\": 0x2265,\n  \"GreaterEqualLess;\": 0x22db,\n  \"GreaterFullEqual;\": 0x2267,\n  \"GreaterGreater;\": 0x2aa2,\n  \"GreaterLess;\": 0x2277,\n  \"GreaterSlantEqual;\": 0x2a7e,\n  \"GreaterTilde;\": 0x2273,\n  \"Gscr;\": [0xd835, 0xdca2],\n  \"Gt;\": 0x226b,\n  \"HARDcy;\": 0x42a,\n  \"Hacek;\": 0x2c7,\n  \"Hat;\": 0x5e,\n  \"Hcirc;\": 0x124,\n  \"Hfr;\": 0x210c,\n  \"HilbertSpace;\": 0x210b,\n  \"Hopf;\": 0x210d,\n  \"HorizontalLine;\": 0x2500,\n  \"Hscr;\": 0x210b,\n  \"Hstrok;\": 0x126,\n  \"HumpDownHump;\": 0x224e,\n  \"HumpEqual;\": 0x224f,\n  \"IEcy;\": 0x415,\n  \"IJlig;\": 0x132,\n  \"IOcy;\": 0x401,\n  \"Iacute\": 0xcd,\n  \"Iacute;\": 0xcd,\n  \"Icirc\": 0xce,\n  \"Icirc;\": 0xce,\n  \"Icy;\": 0x418,\n  \"Idot;\": 0x130,\n  \"Ifr;\": 0x2111,\n  \"Igrave\": 0xcc,\n  \"Igrave;\": 0xcc,\n  \"Im;\": 0x2111,\n  \"Imacr;\": 0x12a,\n  \"ImaginaryI;\": 0x2148,\n  \"Implies;\": 0x21d2,\n  \"Int;\": 0x222c,\n  \"Integral;\": 0x222b,\n  \"Intersection;\": 0x22c2,\n  \"InvisibleComma;\": 0x2063,\n  \"InvisibleTimes;\": 0x2062,\n  \"Iogon;\": 0x12e,\n  \"Iopf;\": [0xd835, 0xdd40],\n  \"Iota;\": 0x399,\n  \"Iscr;\": 0x2110,\n  \"Itilde;\": 0x128,\n  \"Iukcy;\": 0x406,\n  \"Iuml\": 0xcf,\n  \"Iuml;\": 0xcf,\n  \"Jcirc;\": 0x134,\n  \"Jcy;\": 0x419,\n  \"Jfr;\": [0xd835, 0xdd0d],\n  \"Jopf;\": [0xd835, 0xdd41],\n  \"Jscr;\": [0xd835, 0xdca5],\n  \"Jsercy;\": 0x408,\n  \"Jukcy;\": 0x404,\n  \"KHcy;\": 0x425,\n  \"KJcy;\": 0x40c,\n  \"Kappa;\": 0x39a,\n  \"Kcedil;\": 0x136,\n  \"Kcy;\": 0x41a,\n  \"Kfr;\": [0xd835, 0xdd0e],\n  \"Kopf;\": [0xd835, 0xdd42],\n  \"Kscr;\": [0xd835, 0xdca6],\n  \"LJcy;\": 0x409,\n  \"LT\": 0x3c,\n  \"LT;\": 0x3c,\n  \"Lacute;\": 0x139,\n  \"Lambda;\": 0x39b,\n  \"Lang;\": 0x27ea,\n  \"Laplacetrf;\": 0x2112,\n  \"Larr;\": 0x219e,\n  \"Lcaron;\": 0x13d,\n  \"Lcedil;\": 0x13b,\n  \"Lcy;\": 0x41b,\n  \"LeftAngleBracket;\": 0x27e8,\n  \"LeftArrow;\": 0x2190,\n  \"LeftArrowBar;\": 0x21e4,\n  \"LeftArrowRightArrow;\": 0x21c6,\n  \"LeftCeiling;\": 0x2308,\n  \"LeftDoubleBracket;\": 0x27e6,\n  \"LeftDownTeeVector;\": 0x2961,\n  \"LeftDownVector;\": 0x21c3,\n  \"LeftDownVectorBar;\": 0x2959,\n  \"LeftFloor;\": 0x230a,\n  \"LeftRightArrow;\": 0x2194,\n  \"LeftRightVector;\": 0x294e,\n  \"LeftTee;\": 0x22a3,\n  \"LeftTeeArrow;\": 0x21a4,\n  \"LeftTeeVector;\": 0x295a,\n  \"LeftTriangle;\": 0x22b2,\n  \"LeftTriangleBar;\": 0x29cf,\n  \"LeftTriangleEqual;\": 0x22b4,\n  \"LeftUpDownVector;\": 0x2951,\n  \"LeftUpTeeVector;\": 0x2960,\n  \"LeftUpVector;\": 0x21bf,\n  \"LeftUpVectorBar;\": 0x2958,\n  \"LeftVector;\": 0x21bc,\n  \"LeftVectorBar;\": 0x2952,\n  \"Leftarrow;\": 0x21d0,\n  \"Leftrightarrow;\": 0x21d4,\n  \"LessEqualGreater;\": 0x22da,\n  \"LessFullEqual;\": 0x2266,\n  \"LessGreater;\": 0x2276,\n  \"LessLess;\": 0x2aa1,\n  \"LessSlantEqual;\": 0x2a7d,\n  \"LessTilde;\": 0x2272,\n  \"Lfr;\": [0xd835, 0xdd0f],\n  \"Ll;\": 0x22d8,\n  \"Lleftarrow;\": 0x21da,\n  \"Lmidot;\": 0x13f,\n  \"LongLeftArrow;\": 0x27f5,\n  \"LongLeftRightArrow;\": 0x27f7,\n  \"LongRightArrow;\": 0x27f6,\n  \"Longleftarrow;\": 0x27f8,\n  \"Longleftrightarrow;\": 0x27fa,\n  \"Longrightarrow;\": 0x27f9,\n  \"Lopf;\": [0xd835, 0xdd43],\n  \"LowerLeftArrow;\": 0x2199,\n  \"LowerRightArrow;\": 0x2198,\n  \"Lscr;\": 0x2112,\n  \"Lsh;\": 0x21b0,\n  \"Lstrok;\": 0x141,\n  \"Lt;\": 0x226a,\n  \"Map;\": 0x2905,\n  \"Mcy;\": 0x41c,\n  \"MediumSpace;\": 0x205f,\n  \"Mellintrf;\": 0x2133,\n  \"Mfr;\": [0xd835, 0xdd10],\n  \"MinusPlus;\": 0x2213,\n  \"Mopf;\": [0xd835, 0xdd44],\n  \"Mscr;\": 0x2133,\n  \"Mu;\": 0x39c,\n  \"NJcy;\": 0x40a,\n  \"Nacute;\": 0x143,\n  \"Ncaron;\": 0x147,\n  \"Ncedil;\": 0x145,\n  \"Ncy;\": 0x41d,\n  \"NegativeMediumSpace;\": 0x200b,\n  \"NegativeThickSpace;\": 0x200b,\n  \"NegativeThinSpace;\": 0x200b,\n  \"NegativeVeryThinSpace;\": 0x200b,\n  \"NestedGreaterGreater;\": 0x226b,\n  \"NestedLessLess;\": 0x226a,\n  \"NewLine;\": 0xa,\n  \"Nfr;\": [0xd835, 0xdd11],\n  \"NoBreak;\": 0x2060,\n  \"NonBreakingSpace;\": 0xa0,\n  \"Nopf;\": 0x2115,\n  \"Not;\": 0x2aec,\n  \"NotCongruent;\": 0x2262,\n  \"NotCupCap;\": 0x226d,\n  \"NotDoubleVerticalBar;\": 0x2226,\n  \"NotElement;\": 0x2209,\n  \"NotEqual;\": 0x2260,\n  \"NotEqualTilde;\": [0x2242, 0x338],\n  \"NotExists;\": 0x2204,\n  \"NotGreater;\": 0x226f,\n  \"NotGreaterEqual;\": 0x2271,\n  \"NotGreaterFullEqual;\": [0x2267, 0x338],\n  \"NotGreaterGreater;\": [0x226b, 0x338],\n  \"NotGreaterLess;\": 0x2279,\n  \"NotGreaterSlantEqual;\": [0x2a7e, 0x338],\n  \"NotGreaterTilde;\": 0x2275,\n  \"NotHumpDownHump;\": [0x224e, 0x338],\n  \"NotHumpEqual;\": [0x224f, 0x338],\n  \"NotLeftTriangle;\": 0x22ea,\n  \"NotLeftTriangleBar;\": [0x29cf, 0x338],\n  \"NotLeftTriangleEqual;\": 0x22ec,\n  \"NotLess;\": 0x226e,\n  \"NotLessEqual;\": 0x2270,\n  \"NotLessGreater;\": 0x2278,\n  \"NotLessLess;\": [0x226a, 0x338],\n  \"NotLessSlantEqual;\": [0x2a7d, 0x338],\n  \"NotLessTilde;\": 0x2274,\n  \"NotNestedGreaterGreater;\": [0x2aa2, 0x338],\n  \"NotNestedLessLess;\": [0x2aa1, 0x338],\n  \"NotPrecedes;\": 0x2280,\n  \"NotPrecedesEqual;\": [0x2aaf, 0x338],\n  \"NotPrecedesSlantEqual;\": 0x22e0,\n  \"NotReverseElement;\": 0x220c,\n  \"NotRightTriangle;\": 0x22eb,\n  \"NotRightTriangleBar;\": [0x29d0, 0x338],\n  \"NotRightTriangleEqual;\": 0x22ed,\n  \"NotSquareSubset;\": [0x228f, 0x338],\n  \"NotSquareSubsetEqual;\": 0x22e2,\n  \"NotSquareSuperset;\": [0x2290, 0x338],\n  \"NotSquareSupersetEqual;\": 0x22e3,\n  \"NotSubset;\": [0x2282, 0x20d2],\n  \"NotSubsetEqual;\": 0x2288,\n  \"NotSucceeds;\": 0x2281,\n  \"NotSucceedsEqual;\": [0x2ab0, 0x338],\n  \"NotSucceedsSlantEqual;\": 0x22e1,\n  \"NotSucceedsTilde;\": [0x227f, 0x338],\n  \"NotSuperset;\": [0x2283, 0x20d2],\n  \"NotSupersetEqual;\": 0x2289,\n  \"NotTilde;\": 0x2241,\n  \"NotTildeEqual;\": 0x2244,\n  \"NotTildeFullEqual;\": 0x2247,\n  \"NotTildeTilde;\": 0x2249,\n  \"NotVerticalBar;\": 0x2224,\n  \"Nscr;\": [0xd835, 0xdca9],\n  \"Ntilde\": 0xd1,\n  \"Ntilde;\": 0xd1,\n  \"Nu;\": 0x39d,\n  \"OElig;\": 0x152,\n  \"Oacute\": 0xd3,\n  \"Oacute;\": 0xd3,\n  \"Ocirc\": 0xd4,\n  \"Ocirc;\": 0xd4,\n  \"Ocy;\": 0x41e,\n  \"Odblac;\": 0x150,\n  \"Ofr;\": [0xd835, 0xdd12],\n  \"Ograve\": 0xd2,\n  \"Ograve;\": 0xd2,\n  \"Omacr;\": 0x14c,\n  \"Omega;\": 0x3a9,\n  \"Omicron;\": 0x39f,\n  \"Oopf;\": [0xd835, 0xdd46],\n  \"OpenCurlyDoubleQuote;\": 0x201c,\n  \"OpenCurlyQuote;\": 0x2018,\n  \"Or;\": 0x2a54,\n  \"Oscr;\": [0xd835, 0xdcaa],\n  \"Oslash\": 0xd8,\n  \"Oslash;\": 0xd8,\n  \"Otilde\": 0xd5,\n  \"Otilde;\": 0xd5,\n  \"Otimes;\": 0x2a37,\n  \"Ouml\": 0xd6,\n  \"Ouml;\": 0xd6,\n  \"OverBar;\": 0x203e,\n  \"OverBrace;\": 0x23de,\n  \"OverBracket;\": 0x23b4,\n  \"OverParenthesis;\": 0x23dc,\n  \"PartialD;\": 0x2202,\n  \"Pcy;\": 0x41f,\n  \"Pfr;\": [0xd835, 0xdd13],\n  \"Phi;\": 0x3a6,\n  \"Pi;\": 0x3a0,\n  \"PlusMinus;\": 0xb1,\n  \"Poincareplane;\": 0x210c,\n  \"Popf;\": 0x2119,\n  \"Pr;\": 0x2abb,\n  \"Precedes;\": 0x227a,\n  \"PrecedesEqual;\": 0x2aaf,\n  \"PrecedesSlantEqual;\": 0x227c,\n  \"PrecedesTilde;\": 0x227e,\n  \"Prime;\": 0x2033,\n  \"Product;\": 0x220f,\n  \"Proportion;\": 0x2237,\n  \"Proportional;\": 0x221d,\n  \"Pscr;\": [0xd835, 0xdcab],\n  \"Psi;\": 0x3a8,\n  \"QUOT\": 0x22,\n  \"QUOT;\": 0x22,\n  \"Qfr;\": [0xd835, 0xdd14],\n  \"Qopf;\": 0x211a,\n  \"Qscr;\": [0xd835, 0xdcac],\n  \"RBarr;\": 0x2910,\n  \"REG\": 0xae,\n  \"REG;\": 0xae,\n  \"Racute;\": 0x154,\n  \"Rang;\": 0x27eb,\n  \"Rarr;\": 0x21a0,\n  \"Rarrtl;\": 0x2916,\n  \"Rcaron;\": 0x158,\n  \"Rcedil;\": 0x156,\n  \"Rcy;\": 0x420,\n  \"Re;\": 0x211c,\n  \"ReverseElement;\": 0x220b,\n  \"ReverseEquilibrium;\": 0x21cb,\n  \"ReverseUpEquilibrium;\": 0x296f,\n  \"Rfr;\": 0x211c,\n  \"Rho;\": 0x3a1,\n  \"RightAngleBracket;\": 0x27e9,\n  \"RightArrow;\": 0x2192,\n  \"RightArrowBar;\": 0x21e5,\n  \"RightArrowLeftArrow;\": 0x21c4,\n  \"RightCeiling;\": 0x2309,\n  \"RightDoubleBracket;\": 0x27e7,\n  \"RightDownTeeVector;\": 0x295d,\n  \"RightDownVector;\": 0x21c2,\n  \"RightDownVectorBar;\": 0x2955,\n  \"RightFloor;\": 0x230b,\n  \"RightTee;\": 0x22a2,\n  \"RightTeeArrow;\": 0x21a6,\n  \"RightTeeVector;\": 0x295b,\n  \"RightTriangle;\": 0x22b3,\n  \"RightTriangleBar;\": 0x29d0,\n  \"RightTriangleEqual;\": 0x22b5,\n  \"RightUpDownVector;\": 0x294f,\n  \"RightUpTeeVector;\": 0x295c,\n  \"RightUpVector;\": 0x21be,\n  \"RightUpVectorBar;\": 0x2954,\n  \"RightVector;\": 0x21c0,\n  \"RightVectorBar;\": 0x2953,\n  \"Rightarrow;\": 0x21d2,\n  \"Ropf;\": 0x211d,\n  \"RoundImplies;\": 0x2970,\n  \"Rrightarrow;\": 0x21db,\n  \"Rscr;\": 0x211b,\n  \"Rsh;\": 0x21b1,\n  \"RuleDelayed;\": 0x29f4,\n  \"SHCHcy;\": 0x429,\n  \"SHcy;\": 0x428,\n  \"SOFTcy;\": 0x42c,\n  \"Sacute;\": 0x15a,\n  \"Sc;\": 0x2abc,\n  \"Scaron;\": 0x160,\n  \"Scedil;\": 0x15e,\n  \"Scirc;\": 0x15c,\n  \"Scy;\": 0x421,\n  \"Sfr;\": [0xd835, 0xdd16],\n  \"ShortDownArrow;\": 0x2193,\n  \"ShortLeftArrow;\": 0x2190,\n  \"ShortRightArrow;\": 0x2192,\n  \"ShortUpArrow;\": 0x2191,\n  \"Sigma;\": 0x3a3,\n  \"SmallCircle;\": 0x2218,\n  \"Sopf;\": [0xd835, 0xdd4a],\n  \"Sqrt;\": 0x221a,\n  \"Square;\": 0x25a1,\n  \"SquareIntersection;\": 0x2293,\n  \"SquareSubset;\": 0x228f,\n  \"SquareSubsetEqual;\": 0x2291,\n  \"SquareSuperset;\": 0x2290,\n  \"SquareSupersetEqual;\": 0x2292,\n  \"SquareUnion;\": 0x2294,\n  \"Sscr;\": [0xd835, 0xdcae],\n  \"Star;\": 0x22c6,\n  \"Sub;\": 0x22d0,\n  \"Subset;\": 0x22d0,\n  \"SubsetEqual;\": 0x2286,\n  \"Succeeds;\": 0x227b,\n  \"SucceedsEqual;\": 0x2ab0,\n  \"SucceedsSlantEqual;\": 0x227d,\n  \"SucceedsTilde;\": 0x227f,\n  \"SuchThat;\": 0x220b,\n  \"Sum;\": 0x2211,\n  \"Sup;\": 0x22d1,\n  \"Superset;\": 0x2283,\n  \"SupersetEqual;\": 0x2287,\n  \"Supset;\": 0x22d1,\n  \"THORN\": 0xde,\n  \"THORN;\": 0xde,\n  \"TRADE;\": 0x2122,\n  \"TSHcy;\": 0x40b,\n  \"TScy;\": 0x426,\n  \"Tab;\": 0x9,\n  \"Tau;\": 0x3a4,\n  \"Tcaron;\": 0x164,\n  \"Tcedil;\": 0x162,\n  \"Tcy;\": 0x422,\n  \"Tfr;\": [0xd835, 0xdd17],\n  \"Therefore;\": 0x2234,\n  \"Theta;\": 0x398,\n  \"ThickSpace;\": [0x205f, 0x200a],\n  \"ThinSpace;\": 0x2009,\n  \"Tilde;\": 0x223c,\n  \"TildeEqual;\": 0x2243,\n  \"TildeFullEqual;\": 0x2245,\n  \"TildeTilde;\": 0x2248,\n  \"Topf;\": [0xd835, 0xdd4b],\n  \"TripleDot;\": 0x20db,\n  \"Tscr;\": [0xd835, 0xdcaf],\n  \"Tstrok;\": 0x166,\n  \"Uacute\": 0xda,\n  \"Uacute;\": 0xda,\n  \"Uarr;\": 0x219f,\n  \"Uarrocir;\": 0x2949,\n  \"Ubrcy;\": 0x40e,\n  \"Ubreve;\": 0x16c,\n  \"Ucirc\": 0xdb,\n  \"Ucirc;\": 0xdb,\n  \"Ucy;\": 0x423,\n  \"Udblac;\": 0x170,\n  \"Ufr;\": [0xd835, 0xdd18],\n  \"Ugrave\": 0xd9,\n  \"Ugrave;\": 0xd9,\n  \"Umacr;\": 0x16a,\n  \"UnderBar;\": 0x5f,\n  \"UnderBrace;\": 0x23df,\n  \"UnderBracket;\": 0x23b5,\n  \"UnderParenthesis;\": 0x23dd,\n  \"Union;\": 0x22c3,\n  \"UnionPlus;\": 0x228e,\n  \"Uogon;\": 0x172,\n  \"Uopf;\": [0xd835, 0xdd4c],\n  \"UpArrow;\": 0x2191,\n  \"UpArrowBar;\": 0x2912,\n  \"UpArrowDownArrow;\": 0x21c5,\n  \"UpDownArrow;\": 0x2195,\n  \"UpEquilibrium;\": 0x296e,\n  \"UpTee;\": 0x22a5,\n  \"UpTeeArrow;\": 0x21a5,\n  \"Uparrow;\": 0x21d1,\n  \"Updownarrow;\": 0x21d5,\n  \"UpperLeftArrow;\": 0x2196,\n  \"UpperRightArrow;\": 0x2197,\n  \"Upsi;\": 0x3d2,\n  \"Upsilon;\": 0x3a5,\n  \"Uring;\": 0x16e,\n  \"Uscr;\": [0xd835, 0xdcb0],\n  \"Utilde;\": 0x168,\n  \"Uuml\": 0xdc,\n  \"Uuml;\": 0xdc,\n  \"VDash;\": 0x22ab,\n  \"Vbar;\": 0x2aeb,\n  \"Vcy;\": 0x412,\n  \"Vdash;\": 0x22a9,\n  \"Vdashl;\": 0x2ae6,\n  \"Vee;\": 0x22c1,\n  \"Verbar;\": 0x2016,\n  \"Vert;\": 0x2016,\n  \"VerticalBar;\": 0x2223,\n  \"VerticalLine;\": 0x7c,\n  \"VerticalSeparator;\": 0x2758,\n  \"VerticalTilde;\": 0x2240,\n  \"VeryThinSpace;\": 0x200a,\n  \"Vfr;\": [0xd835, 0xdd19],\n  \"Vopf;\": [0xd835, 0xdd4d],\n  \"Vscr;\": [0xd835, 0xdcb1],\n  \"Vvdash;\": 0x22aa,\n  \"Wcirc;\": 0x174,\n  \"Wedge;\": 0x22c0,\n  \"Wfr;\": [0xd835, 0xdd1a],\n  \"Wopf;\": [0xd835, 0xdd4e],\n  \"Wscr;\": [0xd835, 0xdcb2],\n  \"Xfr;\": [0xd835, 0xdd1b],\n  \"Xi;\": 0x39e,\n  \"Xopf;\": [0xd835, 0xdd4f],\n  \"Xscr;\": [0xd835, 0xdcb3],\n  \"YAcy;\": 0x42f,\n  \"YIcy;\": 0x407,\n  \"YUcy;\": 0x42e,\n  \"Yacute\": 0xdd,\n  \"Yacute;\": 0xdd,\n  \"Ycirc;\": 0x176,\n  \"Ycy;\": 0x42b,\n  \"Yfr;\": [0xd835, 0xdd1c],\n  \"Yopf;\": [0xd835, 0xdd50],\n  \"Yscr;\": [0xd835, 0xdcb4],\n  \"Yuml;\": 0x178,\n  \"ZHcy;\": 0x416,\n  \"Zacute;\": 0x179,\n  \"Zcaron;\": 0x17d,\n  \"Zcy;\": 0x417,\n  \"Zdot;\": 0x17b,\n  \"ZeroWidthSpace;\": 0x200b,\n  \"Zeta;\": 0x396,\n  \"Zfr;\": 0x2128,\n  \"Zopf;\": 0x2124,\n  \"Zscr;\": [0xd835, 0xdcb5],\n  \"aacute\": 0xe1,\n  \"aacute;\": 0xe1,\n  \"abreve;\": 0x103,\n  \"ac;\": 0x223e,\n  \"acE;\": [0x223e, 0x333],\n  \"acd;\": 0x223f,\n  \"acirc\": 0xe2,\n  \"acirc;\": 0xe2,\n  \"acute\": 0xb4,\n  \"acute;\": 0xb4,\n  \"acy;\": 0x430,\n  \"aelig\": 0xe6,\n  \"aelig;\": 0xe6,\n  \"af;\": 0x2061,\n  \"afr;\": [0xd835, 0xdd1e],\n  \"agrave\": 0xe0,\n  \"agrave;\": 0xe0,\n  \"alefsym;\": 0x2135,\n  \"aleph;\": 0x2135,\n  \"alpha;\": 0x3b1,\n  \"amacr;\": 0x101,\n  \"amalg;\": 0x2a3f,\n  \"amp\": 0x26,\n  \"amp;\": 0x26,\n  \"and;\": 0x2227,\n  \"andand;\": 0x2a55,\n  \"andd;\": 0x2a5c,\n  \"andslope;\": 0x2a58,\n  \"andv;\": 0x2a5a,\n  \"ang;\": 0x2220,\n  \"ange;\": 0x29a4,\n  \"angle;\": 0x2220,\n  \"angmsd;\": 0x2221,\n  \"angmsdaa;\": 0x29a8,\n  \"angmsdab;\": 0x29a9,\n  \"angmsdac;\": 0x29aa,\n  \"angmsdad;\": 0x29ab,\n  \"angmsdae;\": 0x29ac,\n  \"angmsdaf;\": 0x29ad,\n  \"angmsdag;\": 0x29ae,\n  \"angmsdah;\": 0x29af,\n  \"angrt;\": 0x221f,\n  \"angrtvb;\": 0x22be,\n  \"angrtvbd;\": 0x299d,\n  \"angsph;\": 0x2222,\n  \"angst;\": 0xc5,\n  \"angzarr;\": 0x237c,\n  \"aogon;\": 0x105,\n  \"aopf;\": [0xd835, 0xdd52],\n  \"ap;\": 0x2248,\n  \"apE;\": 0x2a70,\n  \"apacir;\": 0x2a6f,\n  \"ape;\": 0x224a,\n  \"apid;\": 0x224b,\n  \"apos;\": 0x27,\n  \"approx;\": 0x2248,\n  \"approxeq;\": 0x224a,\n  \"aring\": 0xe5,\n  \"aring;\": 0xe5,\n  \"ascr;\": [0xd835, 0xdcb6],\n  \"ast;\": 0x2a,\n  \"asymp;\": 0x2248,\n  \"asympeq;\": 0x224d,\n  \"atilde\": 0xe3,\n  \"atilde;\": 0xe3,\n  \"auml\": 0xe4,\n  \"auml;\": 0xe4,\n  \"awconint;\": 0x2233,\n  \"awint;\": 0x2a11,\n  \"bNot;\": 0x2aed,\n  \"backcong;\": 0x224c,\n  \"backepsilon;\": 0x3f6,\n  \"backprime;\": 0x2035,\n  \"backsim;\": 0x223d,\n  \"backsimeq;\": 0x22cd,\n  \"barvee;\": 0x22bd,\n  \"barwed;\": 0x2305,\n  \"barwedge;\": 0x2305,\n  \"bbrk;\": 0x23b5,\n  \"bbrktbrk;\": 0x23b6,\n  \"bcong;\": 0x224c,\n  \"bcy;\": 0x431,\n  \"bdquo;\": 0x201e,\n  \"becaus;\": 0x2235,\n  \"because;\": 0x2235,\n  \"bemptyv;\": 0x29b0,\n  \"bepsi;\": 0x3f6,\n  \"bernou;\": 0x212c,\n  \"beta;\": 0x3b2,\n  \"beth;\": 0x2136,\n  \"between;\": 0x226c,\n  \"bfr;\": [0xd835, 0xdd1f],\n  \"bigcap;\": 0x22c2,\n  \"bigcirc;\": 0x25ef,\n  \"bigcup;\": 0x22c3,\n  \"bigodot;\": 0x2a00,\n  \"bigoplus;\": 0x2a01,\n  \"bigotimes;\": 0x2a02,\n  \"bigsqcup;\": 0x2a06,\n  \"bigstar;\": 0x2605,\n  \"bigtriangledown;\": 0x25bd,\n  \"bigtriangleup;\": 0x25b3,\n  \"biguplus;\": 0x2a04,\n  \"bigvee;\": 0x22c1,\n  \"bigwedge;\": 0x22c0,\n  \"bkarow;\": 0x290d,\n  \"blacklozenge;\": 0x29eb,\n  \"blacksquare;\": 0x25aa,\n  \"blacktriangle;\": 0x25b4,\n  \"blacktriangledown;\": 0x25be,\n  \"blacktriangleleft;\": 0x25c2,\n  \"blacktriangleright;\": 0x25b8,\n  \"blank;\": 0x2423,\n  \"blk12;\": 0x2592,\n  \"blk14;\": 0x2591,\n  \"blk34;\": 0x2593,\n  \"block;\": 0x2588,\n  \"bne;\": [0x3d, 0x20e5],\n  \"bnequiv;\": [0x2261, 0x20e5],\n  \"bnot;\": 0x2310,\n  \"bopf;\": [0xd835, 0xdd53],\n  \"bot;\": 0x22a5,\n  \"bottom;\": 0x22a5,\n  \"bowtie;\": 0x22c8,\n  \"boxDL;\": 0x2557,\n  \"boxDR;\": 0x2554,\n  \"boxDl;\": 0x2556,\n  \"boxDr;\": 0x2553,\n  \"boxH;\": 0x2550,\n  \"boxHD;\": 0x2566,\n  \"boxHU;\": 0x2569,\n  \"boxHd;\": 0x2564,\n  \"boxHu;\": 0x2567,\n  \"boxUL;\": 0x255d,\n  \"boxUR;\": 0x255a,\n  \"boxUl;\": 0x255c,\n  \"boxUr;\": 0x2559,\n  \"boxV;\": 0x2551,\n  \"boxVH;\": 0x256c,\n  \"boxVL;\": 0x2563,\n  \"boxVR;\": 0x2560,\n  \"boxVh;\": 0x256b,\n  \"boxVl;\": 0x2562,\n  \"boxVr;\": 0x255f,\n  \"boxbox;\": 0x29c9,\n  \"boxdL;\": 0x2555,\n  \"boxdR;\": 0x2552,\n  \"boxdl;\": 0x2510,\n  \"boxdr;\": 0x250c,\n  \"boxh;\": 0x2500,\n  \"boxhD;\": 0x2565,\n  \"boxhU;\": 0x2568,\n  \"boxhd;\": 0x252c,\n  \"boxhu;\": 0x2534,\n  \"boxminus;\": 0x229f,\n  \"boxplus;\": 0x229e,\n  \"boxtimes;\": 0x22a0,\n  \"boxuL;\": 0x255b,\n  \"boxuR;\": 0x2558,\n  \"boxul;\": 0x2518,\n  \"boxur;\": 0x2514,\n  \"boxv;\": 0x2502,\n  \"boxvH;\": 0x256a,\n  \"boxvL;\": 0x2561,\n  \"boxvR;\": 0x255e,\n  \"boxvh;\": 0x253c,\n  \"boxvl;\": 0x2524,\n  \"boxvr;\": 0x251c,\n  \"bprime;\": 0x2035,\n  \"breve;\": 0x2d8,\n  \"brvbar\": 0xa6,\n  \"brvbar;\": 0xa6,\n  \"bscr;\": [0xd835, 0xdcb7],\n  \"bsemi;\": 0x204f,\n  \"bsim;\": 0x223d,\n  \"bsime;\": 0x22cd,\n  \"bsol;\": 0x5c,\n  \"bsolb;\": 0x29c5,\n  \"bsolhsub;\": 0x27c8,\n  \"bull;\": 0x2022,\n  \"bullet;\": 0x2022,\n  \"bump;\": 0x224e,\n  \"bumpE;\": 0x2aae,\n  \"bumpe;\": 0x224f,\n  \"bumpeq;\": 0x224f,\n  \"cacute;\": 0x107,\n  \"cap;\": 0x2229,\n  \"capand;\": 0x2a44,\n  \"capbrcup;\": 0x2a49,\n  \"capcap;\": 0x2a4b,\n  \"capcup;\": 0x2a47,\n  \"capdot;\": 0x2a40,\n  \"caps;\": [0x2229, 0xfe00],\n  \"caret;\": 0x2041,\n  \"caron;\": 0x2c7,\n  \"ccaps;\": 0x2a4d,\n  \"ccaron;\": 0x10d,\n  \"ccedil\": 0xe7,\n  \"ccedil;\": 0xe7,\n  \"ccirc;\": 0x109,\n  \"ccups;\": 0x2a4c,\n  \"ccupssm;\": 0x2a50,\n  \"cdot;\": 0x10b,\n  \"cedil\": 0xb8,\n  \"cedil;\": 0xb8,\n  \"cemptyv;\": 0x29b2,\n  \"cent\": 0xa2,\n  \"cent;\": 0xa2,\n  \"centerdot;\": 0xb7,\n  \"cfr;\": [0xd835, 0xdd20],\n  \"chcy;\": 0x447,\n  \"check;\": 0x2713,\n  \"checkmark;\": 0x2713,\n  \"chi;\": 0x3c7,\n  \"cir;\": 0x25cb,\n  \"cirE;\": 0x29c3,\n  \"circ;\": 0x2c6,\n  \"circeq;\": 0x2257,\n  \"circlearrowleft;\": 0x21ba,\n  \"circlearrowright;\": 0x21bb,\n  \"circledR;\": 0xae,\n  \"circledS;\": 0x24c8,\n  \"circledast;\": 0x229b,\n  \"circledcirc;\": 0x229a,\n  \"circleddash;\": 0x229d,\n  \"cire;\": 0x2257,\n  \"cirfnint;\": 0x2a10,\n  \"cirmid;\": 0x2aef,\n  \"cirscir;\": 0x29c2,\n  \"clubs;\": 0x2663,\n  \"clubsuit;\": 0x2663,\n  \"colon;\": 0x3a,\n  \"colone;\": 0x2254,\n  \"coloneq;\": 0x2254,\n  \"comma;\": 0x2c,\n  \"commat;\": 0x40,\n  \"comp;\": 0x2201,\n  \"compfn;\": 0x2218,\n  \"complement;\": 0x2201,\n  \"complexes;\": 0x2102,\n  \"cong;\": 0x2245,\n  \"congdot;\": 0x2a6d,\n  \"conint;\": 0x222e,\n  \"copf;\": [0xd835, 0xdd54],\n  \"coprod;\": 0x2210,\n  \"copy\": 0xa9,\n  \"copy;\": 0xa9,\n  \"copysr;\": 0x2117,\n  \"crarr;\": 0x21b5,\n  \"cross;\": 0x2717,\n  \"cscr;\": [0xd835, 0xdcb8],\n  \"csub;\": 0x2acf,\n  \"csube;\": 0x2ad1,\n  \"csup;\": 0x2ad0,\n  \"csupe;\": 0x2ad2,\n  \"ctdot;\": 0x22ef,\n  \"cudarrl;\": 0x2938,\n  \"cudarrr;\": 0x2935,\n  \"cuepr;\": 0x22de,\n  \"cuesc;\": 0x22df,\n  \"cularr;\": 0x21b6,\n  \"cularrp;\": 0x293d,\n  \"cup;\": 0x222a,\n  \"cupbrcap;\": 0x2a48,\n  \"cupcap;\": 0x2a46,\n  \"cupcup;\": 0x2a4a,\n  \"cupdot;\": 0x228d,\n  \"cupor;\": 0x2a45,\n  \"cups;\": [0x222a, 0xfe00],\n  \"curarr;\": 0x21b7,\n  \"curarrm;\": 0x293c,\n  \"curlyeqprec;\": 0x22de,\n  \"curlyeqsucc;\": 0x22df,\n  \"curlyvee;\": 0x22ce,\n  \"curlywedge;\": 0x22cf,\n  \"curren\": 0xa4,\n  \"curren;\": 0xa4,\n  \"curvearrowleft;\": 0x21b6,\n  \"curvearrowright;\": 0x21b7,\n  \"cuvee;\": 0x22ce,\n  \"cuwed;\": 0x22cf,\n  \"cwconint;\": 0x2232,\n  \"cwint;\": 0x2231,\n  \"cylcty;\": 0x232d,\n  \"dArr;\": 0x21d3,\n  \"dHar;\": 0x2965,\n  \"dagger;\": 0x2020,\n  \"daleth;\": 0x2138,\n  \"darr;\": 0x2193,\n  \"dash;\": 0x2010,\n  \"dashv;\": 0x22a3,\n  \"dbkarow;\": 0x290f,\n  \"dblac;\": 0x2dd,\n  \"dcaron;\": 0x10f,\n  \"dcy;\": 0x434,\n  \"dd;\": 0x2146,\n  \"ddagger;\": 0x2021,\n  \"ddarr;\": 0x21ca,\n  \"ddotseq;\": 0x2a77,\n  \"deg\": 0xb0,\n  \"deg;\": 0xb0,\n  \"delta;\": 0x3b4,\n  \"demptyv;\": 0x29b1,\n  \"dfisht;\": 0x297f,\n  \"dfr;\": [0xd835, 0xdd21],\n  \"dharl;\": 0x21c3,\n  \"dharr;\": 0x21c2,\n  \"diam;\": 0x22c4,\n  \"diamond;\": 0x22c4,\n  \"diamondsuit;\": 0x2666,\n  \"diams;\": 0x2666,\n  \"die;\": 0xa8,\n  \"digamma;\": 0x3dd,\n  \"disin;\": 0x22f2,\n  \"div;\": 0xf7,\n  \"divide\": 0xf7,\n  \"divide;\": 0xf7,\n  \"divideontimes;\": 0x22c7,\n  \"divonx;\": 0x22c7,\n  \"djcy;\": 0x452,\n  \"dlcorn;\": 0x231e,\n  \"dlcrop;\": 0x230d,\n  \"dollar;\": 0x24,\n  \"dopf;\": [0xd835, 0xdd55],\n  \"dot;\": 0x2d9,\n  \"doteq;\": 0x2250,\n  \"doteqdot;\": 0x2251,\n  \"dotminus;\": 0x2238,\n  \"dotplus;\": 0x2214,\n  \"dotsquare;\": 0x22a1,\n  \"doublebarwedge;\": 0x2306,\n  \"downarrow;\": 0x2193,\n  \"downdownarrows;\": 0x21ca,\n  \"downharpoonleft;\": 0x21c3,\n  \"downharpoonright;\": 0x21c2,\n  \"drbkarow;\": 0x2910,\n  \"drcorn;\": 0x231f,\n  \"drcrop;\": 0x230c,\n  \"dscr;\": [0xd835, 0xdcb9],\n  \"dscy;\": 0x455,\n  \"dsol;\": 0x29f6,\n  \"dstrok;\": 0x111,\n  \"dtdot;\": 0x22f1,\n  \"dtri;\": 0x25bf,\n  \"dtrif;\": 0x25be,\n  \"duarr;\": 0x21f5,\n  \"duhar;\": 0x296f,\n  \"dwangle;\": 0x29a6,\n  \"dzcy;\": 0x45f,\n  \"dzigrarr;\": 0x27ff,\n  \"eDDot;\": 0x2a77,\n  \"eDot;\": 0x2251,\n  \"eacute\": 0xe9,\n  \"eacute;\": 0xe9,\n  \"easter;\": 0x2a6e,\n  \"ecaron;\": 0x11b,\n  \"ecir;\": 0x2256,\n  \"ecirc\": 0xea,\n  \"ecirc;\": 0xea,\n  \"ecolon;\": 0x2255,\n  \"ecy;\": 0x44d,\n  \"edot;\": 0x117,\n  \"ee;\": 0x2147,\n  \"efDot;\": 0x2252,\n  \"efr;\": [0xd835, 0xdd22],\n  \"eg;\": 0x2a9a,\n  \"egrave\": 0xe8,\n  \"egrave;\": 0xe8,\n  \"egs;\": 0x2a96,\n  \"egsdot;\": 0x2a98,\n  \"el;\": 0x2a99,\n  \"elinters;\": 0x23e7,\n  \"ell;\": 0x2113,\n  \"els;\": 0x2a95,\n  \"elsdot;\": 0x2a97,\n  \"emacr;\": 0x113,\n  \"empty;\": 0x2205,\n  \"emptyset;\": 0x2205,\n  \"emptyv;\": 0x2205,\n  \"emsp13;\": 0x2004,\n  \"emsp14;\": 0x2005,\n  \"emsp;\": 0x2003,\n  \"eng;\": 0x14b,\n  \"ensp;\": 0x2002,\n  \"eogon;\": 0x119,\n  \"eopf;\": [0xd835, 0xdd56],\n  \"epar;\": 0x22d5,\n  \"eparsl;\": 0x29e3,\n  \"eplus;\": 0x2a71,\n  \"epsi;\": 0x3b5,\n  \"epsilon;\": 0x3b5,\n  \"epsiv;\": 0x3f5,\n  \"eqcirc;\": 0x2256,\n  \"eqcolon;\": 0x2255,\n  \"eqsim;\": 0x2242,\n  \"eqslantgtr;\": 0x2a96,\n  \"eqslantless;\": 0x2a95,\n  \"equals;\": 0x3d,\n  \"equest;\": 0x225f,\n  \"equiv;\": 0x2261,\n  \"equivDD;\": 0x2a78,\n  \"eqvparsl;\": 0x29e5,\n  \"erDot;\": 0x2253,\n  \"erarr;\": 0x2971,\n  \"escr;\": 0x212f,\n  \"esdot;\": 0x2250,\n  \"esim;\": 0x2242,\n  \"eta;\": 0x3b7,\n  \"eth\": 0xf0,\n  \"eth;\": 0xf0,\n  \"euml\": 0xeb,\n  \"euml;\": 0xeb,\n  \"euro;\": 0x20ac,\n  \"excl;\": 0x21,\n  \"exist;\": 0x2203,\n  \"expectation;\": 0x2130,\n  \"exponentiale;\": 0x2147,\n  \"fallingdotseq;\": 0x2252,\n  \"fcy;\": 0x444,\n  \"female;\": 0x2640,\n  \"ffilig;\": 0xfb03,\n  \"fflig;\": 0xfb00,\n  \"ffllig;\": 0xfb04,\n  \"ffr;\": [0xd835, 0xdd23],\n  \"filig;\": 0xfb01,\n  \"fjlig;\": [0x66, 0x6a],\n  \"flat;\": 0x266d,\n  \"fllig;\": 0xfb02,\n  \"fltns;\": 0x25b1,\n  \"fnof;\": 0x192,\n  \"fopf;\": [0xd835, 0xdd57],\n  \"forall;\": 0x2200,\n  \"fork;\": 0x22d4,\n  \"forkv;\": 0x2ad9,\n  \"fpartint;\": 0x2a0d,\n  \"frac12\": 0xbd,\n  \"frac12;\": 0xbd,\n  \"frac13;\": 0x2153,\n  \"frac14\": 0xbc,\n  \"frac14;\": 0xbc,\n  \"frac15;\": 0x2155,\n  \"frac16;\": 0x2159,\n  \"frac18;\": 0x215b,\n  \"frac23;\": 0x2154,\n  \"frac25;\": 0x2156,\n  \"frac34\": 0xbe,\n  \"frac34;\": 0xbe,\n  \"frac35;\": 0x2157,\n  \"frac38;\": 0x215c,\n  \"frac45;\": 0x2158,\n  \"frac56;\": 0x215a,\n  \"frac58;\": 0x215d,\n  \"frac78;\": 0x215e,\n  \"frasl;\": 0x2044,\n  \"frown;\": 0x2322,\n  \"fscr;\": [0xd835, 0xdcbb],\n  \"gE;\": 0x2267,\n  \"gEl;\": 0x2a8c,\n  \"gacute;\": 0x1f5,\n  \"gamma;\": 0x3b3,\n  \"gammad;\": 0x3dd,\n  \"gap;\": 0x2a86,\n  \"gbreve;\": 0x11f,\n  \"gcirc;\": 0x11d,\n  \"gcy;\": 0x433,\n  \"gdot;\": 0x121,\n  \"ge;\": 0x2265,\n  \"gel;\": 0x22db,\n  \"geq;\": 0x2265,\n  \"geqq;\": 0x2267,\n  \"geqslant;\": 0x2a7e,\n  \"ges;\": 0x2a7e,\n  \"gescc;\": 0x2aa9,\n  \"gesdot;\": 0x2a80,\n  \"gesdoto;\": 0x2a82,\n  \"gesdotol;\": 0x2a84,\n  \"gesl;\": [0x22db, 0xfe00],\n  \"gesles;\": 0x2a94,\n  \"gfr;\": [0xd835, 0xdd24],\n  \"gg;\": 0x226b,\n  \"ggg;\": 0x22d9,\n  \"gimel;\": 0x2137,\n  \"gjcy;\": 0x453,\n  \"gl;\": 0x2277,\n  \"glE;\": 0x2a92,\n  \"gla;\": 0x2aa5,\n  \"glj;\": 0x2aa4,\n  \"gnE;\": 0x2269,\n  \"gnap;\": 0x2a8a,\n  \"gnapprox;\": 0x2a8a,\n  \"gne;\": 0x2a88,\n  \"gneq;\": 0x2a88,\n  \"gneqq;\": 0x2269,\n  \"gnsim;\": 0x22e7,\n  \"gopf;\": [0xd835, 0xdd58],\n  \"grave;\": 0x60,\n  \"gscr;\": 0x210a,\n  \"gsim;\": 0x2273,\n  \"gsime;\": 0x2a8e,\n  \"gsiml;\": 0x2a90,\n  \"gt\": 0x3e,\n  \"gt;\": 0x3e,\n  \"gtcc;\": 0x2aa7,\n  \"gtcir;\": 0x2a7a,\n  \"gtdot;\": 0x22d7,\n  \"gtlPar;\": 0x2995,\n  \"gtquest;\": 0x2a7c,\n  \"gtrapprox;\": 0x2a86,\n  \"gtrarr;\": 0x2978,\n  \"gtrdot;\": 0x22d7,\n  \"gtreqless;\": 0x22db,\n  \"gtreqqless;\": 0x2a8c,\n  \"gtrless;\": 0x2277,\n  \"gtrsim;\": 0x2273,\n  \"gvertneqq;\": [0x2269, 0xfe00],\n  \"gvnE;\": [0x2269, 0xfe00],\n  \"hArr;\": 0x21d4,\n  \"hairsp;\": 0x200a,\n  \"half;\": 0xbd,\n  \"hamilt;\": 0x210b,\n  \"hardcy;\": 0x44a,\n  \"harr;\": 0x2194,\n  \"harrcir;\": 0x2948,\n  \"harrw;\": 0x21ad,\n  \"hbar;\": 0x210f,\n  \"hcirc;\": 0x125,\n  \"hearts;\": 0x2665,\n  \"heartsuit;\": 0x2665,\n  \"hellip;\": 0x2026,\n  \"hercon;\": 0x22b9,\n  \"hfr;\": [0xd835, 0xdd25],\n  \"hksearow;\": 0x2925,\n  \"hkswarow;\": 0x2926,\n  \"hoarr;\": 0x21ff,\n  \"homtht;\": 0x223b,\n  \"hookleftarrow;\": 0x21a9,\n  \"hookrightarrow;\": 0x21aa,\n  \"hopf;\": [0xd835, 0xdd59],\n  \"horbar;\": 0x2015,\n  \"hscr;\": [0xd835, 0xdcbd],\n  \"hslash;\": 0x210f,\n  \"hstrok;\": 0x127,\n  \"hybull;\": 0x2043,\n  \"hyphen;\": 0x2010,\n  \"iacute\": 0xed,\n  \"iacute;\": 0xed,\n  \"ic;\": 0x2063,\n  \"icirc\": 0xee,\n  \"icirc;\": 0xee,\n  \"icy;\": 0x438,\n  \"iecy;\": 0x435,\n  \"iexcl\": 0xa1,\n  \"iexcl;\": 0xa1,\n  \"iff;\": 0x21d4,\n  \"ifr;\": [0xd835, 0xdd26],\n  \"igrave\": 0xec,\n  \"igrave;\": 0xec,\n  \"ii;\": 0x2148,\n  \"iiiint;\": 0x2a0c,\n  \"iiint;\": 0x222d,\n  \"iinfin;\": 0x29dc,\n  \"iiota;\": 0x2129,\n  \"ijlig;\": 0x133,\n  \"imacr;\": 0x12b,\n  \"image;\": 0x2111,\n  \"imagline;\": 0x2110,\n  \"imagpart;\": 0x2111,\n  \"imath;\": 0x131,\n  \"imof;\": 0x22b7,\n  \"imped;\": 0x1b5,\n  \"in;\": 0x2208,\n  \"incare;\": 0x2105,\n  \"infin;\": 0x221e,\n  \"infintie;\": 0x29dd,\n  \"inodot;\": 0x131,\n  \"int;\": 0x222b,\n  \"intcal;\": 0x22ba,\n  \"integers;\": 0x2124,\n  \"intercal;\": 0x22ba,\n  \"intlarhk;\": 0x2a17,\n  \"intprod;\": 0x2a3c,\n  \"iocy;\": 0x451,\n  \"iogon;\": 0x12f,\n  \"iopf;\": [0xd835, 0xdd5a],\n  \"iota;\": 0x3b9,\n  \"iprod;\": 0x2a3c,\n  \"iquest\": 0xbf,\n  \"iquest;\": 0xbf,\n  \"iscr;\": [0xd835, 0xdcbe],\n  \"isin;\": 0x2208,\n  \"isinE;\": 0x22f9,\n  \"isindot;\": 0x22f5,\n  \"isins;\": 0x22f4,\n  \"isinsv;\": 0x22f3,\n  \"isinv;\": 0x2208,\n  \"it;\": 0x2062,\n  \"itilde;\": 0x129,\n  \"iukcy;\": 0x456,\n  \"iuml\": 0xef,\n  \"iuml;\": 0xef,\n  \"jcirc;\": 0x135,\n  \"jcy;\": 0x439,\n  \"jfr;\": [0xd835, 0xdd27],\n  \"jmath;\": 0x237,\n  \"jopf;\": [0xd835, 0xdd5b],\n  \"jscr;\": [0xd835, 0xdcbf],\n  \"jsercy;\": 0x458,\n  \"jukcy;\": 0x454,\n  \"kappa;\": 0x3ba,\n  \"kappav;\": 0x3f0,\n  \"kcedil;\": 0x137,\n  \"kcy;\": 0x43a,\n  \"kfr;\": [0xd835, 0xdd28],\n  \"kgreen;\": 0x138,\n  \"khcy;\": 0x445,\n  \"kjcy;\": 0x45c,\n  \"kopf;\": [0xd835, 0xdd5c],\n  \"kscr;\": [0xd835, 0xdcc0],\n  \"lAarr;\": 0x21da,\n  \"lArr;\": 0x21d0,\n  \"lAtail;\": 0x291b,\n  \"lBarr;\": 0x290e,\n  \"lE;\": 0x2266,\n  \"lEg;\": 0x2a8b,\n  \"lHar;\": 0x2962,\n  \"lacute;\": 0x13a,\n  \"laemptyv;\": 0x29b4,\n  \"lagran;\": 0x2112,\n  \"lambda;\": 0x3bb,\n  \"lang;\": 0x27e8,\n  \"langd;\": 0x2991,\n  \"langle;\": 0x27e8,\n  \"lap;\": 0x2a85,\n  \"laquo\": 0xab,\n  \"laquo;\": 0xab,\n  \"larr;\": 0x2190,\n  \"larrb;\": 0x21e4,\n  \"larrbfs;\": 0x291f,\n  \"larrfs;\": 0x291d,\n  \"larrhk;\": 0x21a9,\n  \"larrlp;\": 0x21ab,\n  \"larrpl;\": 0x2939,\n  \"larrsim;\": 0x2973,\n  \"larrtl;\": 0x21a2,\n  \"lat;\": 0x2aab,\n  \"latail;\": 0x2919,\n  \"late;\": 0x2aad,\n  \"lates;\": [0x2aad, 0xfe00],\n  \"lbarr;\": 0x290c,\n  \"lbbrk;\": 0x2772,\n  \"lbrace;\": 0x7b,\n  \"lbrack;\": 0x5b,\n  \"lbrke;\": 0x298b,\n  \"lbrksld;\": 0x298f,\n  \"lbrkslu;\": 0x298d,\n  \"lcaron;\": 0x13e,\n  \"lcedil;\": 0x13c,\n  \"lceil;\": 0x2308,\n  \"lcub;\": 0x7b,\n  \"lcy;\": 0x43b,\n  \"ldca;\": 0x2936,\n  \"ldquo;\": 0x201c,\n  \"ldquor;\": 0x201e,\n  \"ldrdhar;\": 0x2967,\n  \"ldrushar;\": 0x294b,\n  \"ldsh;\": 0x21b2,\n  \"le;\": 0x2264,\n  \"leftarrow;\": 0x2190,\n  \"leftarrowtail;\": 0x21a2,\n  \"leftharpoondown;\": 0x21bd,\n  \"leftharpoonup;\": 0x21bc,\n  \"leftleftarrows;\": 0x21c7,\n  \"leftrightarrow;\": 0x2194,\n  \"leftrightarrows;\": 0x21c6,\n  \"leftrightharpoons;\": 0x21cb,\n  \"leftrightsquigarrow;\": 0x21ad,\n  \"leftthreetimes;\": 0x22cb,\n  \"leg;\": 0x22da,\n  \"leq;\": 0x2264,\n  \"leqq;\": 0x2266,\n  \"leqslant;\": 0x2a7d,\n  \"les;\": 0x2a7d,\n  \"lescc;\": 0x2aa8,\n  \"lesdot;\": 0x2a7f,\n  \"lesdoto;\": 0x2a81,\n  \"lesdotor;\": 0x2a83,\n  \"lesg;\": [0x22da, 0xfe00],\n  \"lesges;\": 0x2a93,\n  \"lessapprox;\": 0x2a85,\n  \"lessdot;\": 0x22d6,\n  \"lesseqgtr;\": 0x22da,\n  \"lesseqqgtr;\": 0x2a8b,\n  \"lessgtr;\": 0x2276,\n  \"lesssim;\": 0x2272,\n  \"lfisht;\": 0x297c,\n  \"lfloor;\": 0x230a,\n  \"lfr;\": [0xd835, 0xdd29],\n  \"lg;\": 0x2276,\n  \"lgE;\": 0x2a91,\n  \"lhard;\": 0x21bd,\n  \"lharu;\": 0x21bc,\n  \"lharul;\": 0x296a,\n  \"lhblk;\": 0x2584,\n  \"ljcy;\": 0x459,\n  \"ll;\": 0x226a,\n  \"llarr;\": 0x21c7,\n  \"llcorner;\": 0x231e,\n  \"llhard;\": 0x296b,\n  \"lltri;\": 0x25fa,\n  \"lmidot;\": 0x140,\n  \"lmoust;\": 0x23b0,\n  \"lmoustache;\": 0x23b0,\n  \"lnE;\": 0x2268,\n  \"lnap;\": 0x2a89,\n  \"lnapprox;\": 0x2a89,\n  \"lne;\": 0x2a87,\n  \"lneq;\": 0x2a87,\n  \"lneqq;\": 0x2268,\n  \"lnsim;\": 0x22e6,\n  \"loang;\": 0x27ec,\n  \"loarr;\": 0x21fd,\n  \"lobrk;\": 0x27e6,\n  \"longleftarrow;\": 0x27f5,\n  \"longleftrightarrow;\": 0x27f7,\n  \"longmapsto;\": 0x27fc,\n  \"longrightarrow;\": 0x27f6,\n  \"looparrowleft;\": 0x21ab,\n  \"looparrowright;\": 0x21ac,\n  \"lopar;\": 0x2985,\n  \"lopf;\": [0xd835, 0xdd5d],\n  \"loplus;\": 0x2a2d,\n  \"lotimes;\": 0x2a34,\n  \"lowast;\": 0x2217,\n  \"lowbar;\": 0x5f,\n  \"loz;\": 0x25ca,\n  \"lozenge;\": 0x25ca,\n  \"lozf;\": 0x29eb,\n  \"lpar;\": 0x28,\n  \"lparlt;\": 0x2993,\n  \"lrarr;\": 0x21c6,\n  \"lrcorner;\": 0x231f,\n  \"lrhar;\": 0x21cb,\n  \"lrhard;\": 0x296d,\n  \"lrm;\": 0x200e,\n  \"lrtri;\": 0x22bf,\n  \"lsaquo;\": 0x2039,\n  \"lscr;\": [0xd835, 0xdcc1],\n  \"lsh;\": 0x21b0,\n  \"lsim;\": 0x2272,\n  \"lsime;\": 0x2a8d,\n  \"lsimg;\": 0x2a8f,\n  \"lsqb;\": 0x5b,\n  \"lsquo;\": 0x2018,\n  \"lsquor;\": 0x201a,\n  \"lstrok;\": 0x142,\n  \"lt\": 0x3c,\n  \"lt;\": 0x3c,\n  \"ltcc;\": 0x2aa6,\n  \"ltcir;\": 0x2a79,\n  \"ltdot;\": 0x22d6,\n  \"lthree;\": 0x22cb,\n  \"ltimes;\": 0x22c9,\n  \"ltlarr;\": 0x2976,\n  \"ltquest;\": 0x2a7b,\n  \"ltrPar;\": 0x2996,\n  \"ltri;\": 0x25c3,\n  \"ltrie;\": 0x22b4,\n  \"ltrif;\": 0x25c2,\n  \"lurdshar;\": 0x294a,\n  \"luruhar;\": 0x2966,\n  \"lvertneqq;\": [0x2268, 0xfe00],\n  \"lvnE;\": [0x2268, 0xfe00],\n  \"mDDot;\": 0x223a,\n  \"macr\": 0xaf,\n  \"macr;\": 0xaf,\n  \"male;\": 0x2642,\n  \"malt;\": 0x2720,\n  \"maltese;\": 0x2720,\n  \"map;\": 0x21a6,\n  \"mapsto;\": 0x21a6,\n  \"mapstodown;\": 0x21a7,\n  \"mapstoleft;\": 0x21a4,\n  \"mapstoup;\": 0x21a5,\n  \"marker;\": 0x25ae,\n  \"mcomma;\": 0x2a29,\n  \"mcy;\": 0x43c,\n  \"mdash;\": 0x2014,\n  \"measuredangle;\": 0x2221,\n  \"mfr;\": [0xd835, 0xdd2a],\n  \"mho;\": 0x2127,\n  \"micro\": 0xb5,\n  \"micro;\": 0xb5,\n  \"mid;\": 0x2223,\n  \"midast;\": 0x2a,\n  \"midcir;\": 0x2af0,\n  \"middot\": 0xb7,\n  \"middot;\": 0xb7,\n  \"minus;\": 0x2212,\n  \"minusb;\": 0x229f,\n  \"minusd;\": 0x2238,\n  \"minusdu;\": 0x2a2a,\n  \"mlcp;\": 0x2adb,\n  \"mldr;\": 0x2026,\n  \"mnplus;\": 0x2213,\n  \"models;\": 0x22a7,\n  \"mopf;\": [0xd835, 0xdd5e],\n  \"mp;\": 0x2213,\n  \"mscr;\": [0xd835, 0xdcc2],\n  \"mstpos;\": 0x223e,\n  \"mu;\": 0x3bc,\n  \"multimap;\": 0x22b8,\n  \"mumap;\": 0x22b8,\n  \"nGg;\": [0x22d9, 0x338],\n  \"nGt;\": [0x226b, 0x20d2],\n  \"nGtv;\": [0x226b, 0x338],\n  \"nLeftarrow;\": 0x21cd,\n  \"nLeftrightarrow;\": 0x21ce,\n  \"nLl;\": [0x22d8, 0x338],\n  \"nLt;\": [0x226a, 0x20d2],\n  \"nLtv;\": [0x226a, 0x338],\n  \"nRightarrow;\": 0x21cf,\n  \"nVDash;\": 0x22af,\n  \"nVdash;\": 0x22ae,\n  \"nabla;\": 0x2207,\n  \"nacute;\": 0x144,\n  \"nang;\": [0x2220, 0x20d2],\n  \"nap;\": 0x2249,\n  \"napE;\": [0x2a70, 0x338],\n  \"napid;\": [0x224b, 0x338],\n  \"napos;\": 0x149,\n  \"napprox;\": 0x2249,\n  \"natur;\": 0x266e,\n  \"natural;\": 0x266e,\n  \"naturals;\": 0x2115,\n  \"nbsp\": 0xa0,\n  \"nbsp;\": 0xa0,\n  \"nbump;\": [0x224e, 0x338],\n  \"nbumpe;\": [0x224f, 0x338],\n  \"ncap;\": 0x2a43,\n  \"ncaron;\": 0x148,\n  \"ncedil;\": 0x146,\n  \"ncong;\": 0x2247,\n  \"ncongdot;\": [0x2a6d, 0x338],\n  \"ncup;\": 0x2a42,\n  \"ncy;\": 0x43d,\n  \"ndash;\": 0x2013,\n  \"ne;\": 0x2260,\n  \"neArr;\": 0x21d7,\n  \"nearhk;\": 0x2924,\n  \"nearr;\": 0x2197,\n  \"nearrow;\": 0x2197,\n  \"nedot;\": [0x2250, 0x338],\n  \"nequiv;\": 0x2262,\n  \"nesear;\": 0x2928,\n  \"nesim;\": [0x2242, 0x338],\n  \"nexist;\": 0x2204,\n  \"nexists;\": 0x2204,\n  \"nfr;\": [0xd835, 0xdd2b],\n  \"ngE;\": [0x2267, 0x338],\n  \"nge;\": 0x2271,\n  \"ngeq;\": 0x2271,\n  \"ngeqq;\": [0x2267, 0x338],\n  \"ngeqslant;\": [0x2a7e, 0x338],\n  \"nges;\": [0x2a7e, 0x338],\n  \"ngsim;\": 0x2275,\n  \"ngt;\": 0x226f,\n  \"ngtr;\": 0x226f,\n  \"nhArr;\": 0x21ce,\n  \"nharr;\": 0x21ae,\n  \"nhpar;\": 0x2af2,\n  \"ni;\": 0x220b,\n  \"nis;\": 0x22fc,\n  \"nisd;\": 0x22fa,\n  \"niv;\": 0x220b,\n  \"njcy;\": 0x45a,\n  \"nlArr;\": 0x21cd,\n  \"nlE;\": [0x2266, 0x338],\n  \"nlarr;\": 0x219a,\n  \"nldr;\": 0x2025,\n  \"nle;\": 0x2270,\n  \"nleftarrow;\": 0x219a,\n  \"nleftrightarrow;\": 0x21ae,\n  \"nleq;\": 0x2270,\n  \"nleqq;\": [0x2266, 0x338],\n  \"nleqslant;\": [0x2a7d, 0x338],\n  \"nles;\": [0x2a7d, 0x338],\n  \"nless;\": 0x226e,\n  \"nlsim;\": 0x2274,\n  \"nlt;\": 0x226e,\n  \"nltri;\": 0x22ea,\n  \"nltrie;\": 0x22ec,\n  \"nmid;\": 0x2224,\n  \"nopf;\": [0xd835, 0xdd5f],\n  \"not\": 0xac,\n  \"not;\": 0xac,\n  \"notin;\": 0x2209,\n  \"notinE;\": [0x22f9, 0x338],\n  \"notindot;\": [0x22f5, 0x338],\n  \"notinva;\": 0x2209,\n  \"notinvb;\": 0x22f7,\n  \"notinvc;\": 0x22f6,\n  \"notni;\": 0x220c,\n  \"notniva;\": 0x220c,\n  \"notnivb;\": 0x22fe,\n  \"notnivc;\": 0x22fd,\n  \"npar;\": 0x2226,\n  \"nparallel;\": 0x2226,\n  \"nparsl;\": [0x2afd, 0x20e5],\n  \"npart;\": [0x2202, 0x338],\n  \"npolint;\": 0x2a14,\n  \"npr;\": 0x2280,\n  \"nprcue;\": 0x22e0,\n  \"npre;\": [0x2aaf, 0x338],\n  \"nprec;\": 0x2280,\n  \"npreceq;\": [0x2aaf, 0x338],\n  \"nrArr;\": 0x21cf,\n  \"nrarr;\": 0x219b,\n  \"nrarrc;\": [0x2933, 0x338],\n  \"nrarrw;\": [0x219d, 0x338],\n  \"nrightarrow;\": 0x219b,\n  \"nrtri;\": 0x22eb,\n  \"nrtrie;\": 0x22ed,\n  \"nsc;\": 0x2281,\n  \"nsccue;\": 0x22e1,\n  \"nsce;\": [0x2ab0, 0x338],\n  \"nscr;\": [0xd835, 0xdcc3],\n  \"nshortmid;\": 0x2224,\n  \"nshortparallel;\": 0x2226,\n  \"nsim;\": 0x2241,\n  \"nsime;\": 0x2244,\n  \"nsimeq;\": 0x2244,\n  \"nsmid;\": 0x2224,\n  \"nspar;\": 0x2226,\n  \"nsqsube;\": 0x22e2,\n  \"nsqsupe;\": 0x22e3,\n  \"nsub;\": 0x2284,\n  \"nsubE;\": [0x2ac5, 0x338],\n  \"nsube;\": 0x2288,\n  \"nsubset;\": [0x2282, 0x20d2],\n  \"nsubseteq;\": 0x2288,\n  \"nsubseteqq;\": [0x2ac5, 0x338],\n  \"nsucc;\": 0x2281,\n  \"nsucceq;\": [0x2ab0, 0x338],\n  \"nsup;\": 0x2285,\n  \"nsupE;\": [0x2ac6, 0x338],\n  \"nsupe;\": 0x2289,\n  \"nsupset;\": [0x2283, 0x20d2],\n  \"nsupseteq;\": 0x2289,\n  \"nsupseteqq;\": [0x2ac6, 0x338],\n  \"ntgl;\": 0x2279,\n  \"ntilde\": 0xf1,\n  \"ntilde;\": 0xf1,\n  \"ntlg;\": 0x2278,\n  \"ntriangleleft;\": 0x22ea,\n  \"ntrianglelefteq;\": 0x22ec,\n  \"ntriangleright;\": 0x22eb,\n  \"ntrianglerighteq;\": 0x22ed,\n  \"nu;\": 0x3bd,\n  \"num;\": 0x23,\n  \"numero;\": 0x2116,\n  \"numsp;\": 0x2007,\n  \"nvDash;\": 0x22ad,\n  \"nvHarr;\": 0x2904,\n  \"nvap;\": [0x224d, 0x20d2],\n  \"nvdash;\": 0x22ac,\n  \"nvge;\": [0x2265, 0x20d2],\n  \"nvgt;\": [0x3e, 0x20d2],\n  \"nvinfin;\": 0x29de,\n  \"nvlArr;\": 0x2902,\n  \"nvle;\": [0x2264, 0x20d2],\n  \"nvlt;\": [0x3c, 0x20d2],\n  \"nvltrie;\": [0x22b4, 0x20d2],\n  \"nvrArr;\": 0x2903,\n  \"nvrtrie;\": [0x22b5, 0x20d2],\n  \"nvsim;\": [0x223c, 0x20d2],\n  \"nwArr;\": 0x21d6,\n  \"nwarhk;\": 0x2923,\n  \"nwarr;\": 0x2196,\n  \"nwarrow;\": 0x2196,\n  \"nwnear;\": 0x2927,\n  \"oS;\": 0x24c8,\n  \"oacute\": 0xf3,\n  \"oacute;\": 0xf3,\n  \"oast;\": 0x229b,\n  \"ocir;\": 0x229a,\n  \"ocirc\": 0xf4,\n  \"ocirc;\": 0xf4,\n  \"ocy;\": 0x43e,\n  \"odash;\": 0x229d,\n  \"odblac;\": 0x151,\n  \"odiv;\": 0x2a38,\n  \"odot;\": 0x2299,\n  \"odsold;\": 0x29bc,\n  \"oelig;\": 0x153,\n  \"ofcir;\": 0x29bf,\n  \"ofr;\": [0xd835, 0xdd2c],\n  \"ogon;\": 0x2db,\n  \"ograve\": 0xf2,\n  \"ograve;\": 0xf2,\n  \"ogt;\": 0x29c1,\n  \"ohbar;\": 0x29b5,\n  \"ohm;\": 0x3a9,\n  \"oint;\": 0x222e,\n  \"olarr;\": 0x21ba,\n  \"olcir;\": 0x29be,\n  \"olcross;\": 0x29bb,\n  \"oline;\": 0x203e,\n  \"olt;\": 0x29c0,\n  \"omacr;\": 0x14d,\n  \"omega;\": 0x3c9,\n  \"omicron;\": 0x3bf,\n  \"omid;\": 0x29b6,\n  \"ominus;\": 0x2296,\n  \"oopf;\": [0xd835, 0xdd60],\n  \"opar;\": 0x29b7,\n  \"operp;\": 0x29b9,\n  \"oplus;\": 0x2295,\n  \"or;\": 0x2228,\n  \"orarr;\": 0x21bb,\n  \"ord;\": 0x2a5d,\n  \"order;\": 0x2134,\n  \"orderof;\": 0x2134,\n  \"ordf\": 0xaa,\n  \"ordf;\": 0xaa,\n  \"ordm\": 0xba,\n  \"ordm;\": 0xba,\n  \"origof;\": 0x22b6,\n  \"oror;\": 0x2a56,\n  \"orslope;\": 0x2a57,\n  \"orv;\": 0x2a5b,\n  \"oscr;\": 0x2134,\n  \"oslash\": 0xf8,\n  \"oslash;\": 0xf8,\n  \"osol;\": 0x2298,\n  \"otilde\": 0xf5,\n  \"otilde;\": 0xf5,\n  \"otimes;\": 0x2297,\n  \"otimesas;\": 0x2a36,\n  \"ouml\": 0xf6,\n  \"ouml;\": 0xf6,\n  \"ovbar;\": 0x233d,\n  \"par;\": 0x2225,\n  \"para\": 0xb6,\n  \"para;\": 0xb6,\n  \"parallel;\": 0x2225,\n  \"parsim;\": 0x2af3,\n  \"parsl;\": 0x2afd,\n  \"part;\": 0x2202,\n  \"pcy;\": 0x43f,\n  \"percnt;\": 0x25,\n  \"period;\": 0x2e,\n  \"permil;\": 0x2030,\n  \"perp;\": 0x22a5,\n  \"pertenk;\": 0x2031,\n  \"pfr;\": [0xd835, 0xdd2d],\n  \"phi;\": 0x3c6,\n  \"phiv;\": 0x3d5,\n  \"phmmat;\": 0x2133,\n  \"phone;\": 0x260e,\n  \"pi;\": 0x3c0,\n  \"pitchfork;\": 0x22d4,\n  \"piv;\": 0x3d6,\n  \"planck;\": 0x210f,\n  \"planckh;\": 0x210e,\n  \"plankv;\": 0x210f,\n  \"plus;\": 0x2b,\n  \"plusacir;\": 0x2a23,\n  \"plusb;\": 0x229e,\n  \"pluscir;\": 0x2a22,\n  \"plusdo;\": 0x2214,\n  \"plusdu;\": 0x2a25,\n  \"pluse;\": 0x2a72,\n  \"plusmn\": 0xb1,\n  \"plusmn;\": 0xb1,\n  \"plussim;\": 0x2a26,\n  \"plustwo;\": 0x2a27,\n  \"pm;\": 0xb1,\n  \"pointint;\": 0x2a15,\n  \"popf;\": [0xd835, 0xdd61],\n  \"pound\": 0xa3,\n  \"pound;\": 0xa3,\n  \"pr;\": 0x227a,\n  \"prE;\": 0x2ab3,\n  \"prap;\": 0x2ab7,\n  \"prcue;\": 0x227c,\n  \"pre;\": 0x2aaf,\n  \"prec;\": 0x227a,\n  \"precapprox;\": 0x2ab7,\n  \"preccurlyeq;\": 0x227c,\n  \"preceq;\": 0x2aaf,\n  \"precnapprox;\": 0x2ab9,\n  \"precneqq;\": 0x2ab5,\n  \"precnsim;\": 0x22e8,\n  \"precsim;\": 0x227e,\n  \"prime;\": 0x2032,\n  \"primes;\": 0x2119,\n  \"prnE;\": 0x2ab5,\n  \"prnap;\": 0x2ab9,\n  \"prnsim;\": 0x22e8,\n  \"prod;\": 0x220f,\n  \"profalar;\": 0x232e,\n  \"profline;\": 0x2312,\n  \"profsurf;\": 0x2313,\n  \"prop;\": 0x221d,\n  \"propto;\": 0x221d,\n  \"prsim;\": 0x227e,\n  \"prurel;\": 0x22b0,\n  \"pscr;\": [0xd835, 0xdcc5],\n  \"psi;\": 0x3c8,\n  \"puncsp;\": 0x2008,\n  \"qfr;\": [0xd835, 0xdd2e],\n  \"qint;\": 0x2a0c,\n  \"qopf;\": [0xd835, 0xdd62],\n  \"qprime;\": 0x2057,\n  \"qscr;\": [0xd835, 0xdcc6],\n  \"quaternions;\": 0x210d,\n  \"quatint;\": 0x2a16,\n  \"quest;\": 0x3f,\n  \"questeq;\": 0x225f,\n  \"quot\": 0x22,\n  \"quot;\": 0x22,\n  \"rAarr;\": 0x21db,\n  \"rArr;\": 0x21d2,\n  \"rAtail;\": 0x291c,\n  \"rBarr;\": 0x290f,\n  \"rHar;\": 0x2964,\n  \"race;\": [0x223d, 0x331],\n  \"racute;\": 0x155,\n  \"radic;\": 0x221a,\n  \"raemptyv;\": 0x29b3,\n  \"rang;\": 0x27e9,\n  \"rangd;\": 0x2992,\n  \"range;\": 0x29a5,\n  \"rangle;\": 0x27e9,\n  \"raquo\": 0xbb,\n  \"raquo;\": 0xbb,\n  \"rarr;\": 0x2192,\n  \"rarrap;\": 0x2975,\n  \"rarrb;\": 0x21e5,\n  \"rarrbfs;\": 0x2920,\n  \"rarrc;\": 0x2933,\n  \"rarrfs;\": 0x291e,\n  \"rarrhk;\": 0x21aa,\n  \"rarrlp;\": 0x21ac,\n  \"rarrpl;\": 0x2945,\n  \"rarrsim;\": 0x2974,\n  \"rarrtl;\": 0x21a3,\n  \"rarrw;\": 0x219d,\n  \"ratail;\": 0x291a,\n  \"ratio;\": 0x2236,\n  \"rationals;\": 0x211a,\n  \"rbarr;\": 0x290d,\n  \"rbbrk;\": 0x2773,\n  \"rbrace;\": 0x7d,\n  \"rbrack;\": 0x5d,\n  \"rbrke;\": 0x298c,\n  \"rbrksld;\": 0x298e,\n  \"rbrkslu;\": 0x2990,\n  \"rcaron;\": 0x159,\n  \"rcedil;\": 0x157,\n  \"rceil;\": 0x2309,\n  \"rcub;\": 0x7d,\n  \"rcy;\": 0x440,\n  \"rdca;\": 0x2937,\n  \"rdldhar;\": 0x2969,\n  \"rdquo;\": 0x201d,\n  \"rdquor;\": 0x201d,\n  \"rdsh;\": 0x21b3,\n  \"real;\": 0x211c,\n  \"realine;\": 0x211b,\n  \"realpart;\": 0x211c,\n  \"reals;\": 0x211d,\n  \"rect;\": 0x25ad,\n  \"reg\": 0xae,\n  \"reg;\": 0xae,\n  \"rfisht;\": 0x297d,\n  \"rfloor;\": 0x230b,\n  \"rfr;\": [0xd835, 0xdd2f],\n  \"rhard;\": 0x21c1,\n  \"rharu;\": 0x21c0,\n  \"rharul;\": 0x296c,\n  \"rho;\": 0x3c1,\n  \"rhov;\": 0x3f1,\n  \"rightarrow;\": 0x2192,\n  \"rightarrowtail;\": 0x21a3,\n  \"rightharpoondown;\": 0x21c1,\n  \"rightharpoonup;\": 0x21c0,\n  \"rightleftarrows;\": 0x21c4,\n  \"rightleftharpoons;\": 0x21cc,\n  \"rightrightarrows;\": 0x21c9,\n  \"rightsquigarrow;\": 0x219d,\n  \"rightthreetimes;\": 0x22cc,\n  \"ring;\": 0x2da,\n  \"risingdotseq;\": 0x2253,\n  \"rlarr;\": 0x21c4,\n  \"rlhar;\": 0x21cc,\n  \"rlm;\": 0x200f,\n  \"rmoust;\": 0x23b1,\n  \"rmoustache;\": 0x23b1,\n  \"rnmid;\": 0x2aee,\n  \"roang;\": 0x27ed,\n  \"roarr;\": 0x21fe,\n  \"robrk;\": 0x27e7,\n  \"ropar;\": 0x2986,\n  \"ropf;\": [0xd835, 0xdd63],\n  \"roplus;\": 0x2a2e,\n  \"rotimes;\": 0x2a35,\n  \"rpar;\": 0x29,\n  \"rpargt;\": 0x2994,\n  \"rppolint;\": 0x2a12,\n  \"rrarr;\": 0x21c9,\n  \"rsaquo;\": 0x203a,\n  \"rscr;\": [0xd835, 0xdcc7],\n  \"rsh;\": 0x21b1,\n  \"rsqb;\": 0x5d,\n  \"rsquo;\": 0x2019,\n  \"rsquor;\": 0x2019,\n  \"rthree;\": 0x22cc,\n  \"rtimes;\": 0x22ca,\n  \"rtri;\": 0x25b9,\n  \"rtrie;\": 0x22b5,\n  \"rtrif;\": 0x25b8,\n  \"rtriltri;\": 0x29ce,\n  \"ruluhar;\": 0x2968,\n  \"rx;\": 0x211e,\n  \"sacute;\": 0x15b,\n  \"sbquo;\": 0x201a,\n  \"sc;\": 0x227b,\n  \"scE;\": 0x2ab4,\n  \"scap;\": 0x2ab8,\n  \"scaron;\": 0x161,\n  \"sccue;\": 0x227d,\n  \"sce;\": 0x2ab0,\n  \"scedil;\": 0x15f,\n  \"scirc;\": 0x15d,\n  \"scnE;\": 0x2ab6,\n  \"scnap;\": 0x2aba,\n  \"scnsim;\": 0x22e9,\n  \"scpolint;\": 0x2a13,\n  \"scsim;\": 0x227f,\n  \"scy;\": 0x441,\n  \"sdot;\": 0x22c5,\n  \"sdotb;\": 0x22a1,\n  \"sdote;\": 0x2a66,\n  \"seArr;\": 0x21d8,\n  \"searhk;\": 0x2925,\n  \"searr;\": 0x2198,\n  \"searrow;\": 0x2198,\n  \"sect\": 0xa7,\n  \"sect;\": 0xa7,\n  \"semi;\": 0x3b,\n  \"seswar;\": 0x2929,\n  \"setminus;\": 0x2216,\n  \"setmn;\": 0x2216,\n  \"sext;\": 0x2736,\n  \"sfr;\": [0xd835, 0xdd30],\n  \"sfrown;\": 0x2322,\n  \"sharp;\": 0x266f,\n  \"shchcy;\": 0x449,\n  \"shcy;\": 0x448,\n  \"shortmid;\": 0x2223,\n  \"shortparallel;\": 0x2225,\n  \"shy\": 0xad,\n  \"shy;\": 0xad,\n  \"sigma;\": 0x3c3,\n  \"sigmaf;\": 0x3c2,\n  \"sigmav;\": 0x3c2,\n  \"sim;\": 0x223c,\n  \"simdot;\": 0x2a6a,\n  \"sime;\": 0x2243,\n  \"simeq;\": 0x2243,\n  \"simg;\": 0x2a9e,\n  \"simgE;\": 0x2aa0,\n  \"siml;\": 0x2a9d,\n  \"simlE;\": 0x2a9f,\n  \"simne;\": 0x2246,\n  \"simplus;\": 0x2a24,\n  \"simrarr;\": 0x2972,\n  \"slarr;\": 0x2190,\n  \"smallsetminus;\": 0x2216,\n  \"smashp;\": 0x2a33,\n  \"smeparsl;\": 0x29e4,\n  \"smid;\": 0x2223,\n  \"smile;\": 0x2323,\n  \"smt;\": 0x2aaa,\n  \"smte;\": 0x2aac,\n  \"smtes;\": [0x2aac, 0xfe00],\n  \"softcy;\": 0x44c,\n  \"sol;\": 0x2f,\n  \"solb;\": 0x29c4,\n  \"solbar;\": 0x233f,\n  \"sopf;\": [0xd835, 0xdd64],\n  \"spades;\": 0x2660,\n  \"spadesuit;\": 0x2660,\n  \"spar;\": 0x2225,\n  \"sqcap;\": 0x2293,\n  \"sqcaps;\": [0x2293, 0xfe00],\n  \"sqcup;\": 0x2294,\n  \"sqcups;\": [0x2294, 0xfe00],\n  \"sqsub;\": 0x228f,\n  \"sqsube;\": 0x2291,\n  \"sqsubset;\": 0x228f,\n  \"sqsubseteq;\": 0x2291,\n  \"sqsup;\": 0x2290,\n  \"sqsupe;\": 0x2292,\n  \"sqsupset;\": 0x2290,\n  \"sqsupseteq;\": 0x2292,\n  \"squ;\": 0x25a1,\n  \"square;\": 0x25a1,\n  \"squarf;\": 0x25aa,\n  \"squf;\": 0x25aa,\n  \"srarr;\": 0x2192,\n  \"sscr;\": [0xd835, 0xdcc8],\n  \"ssetmn;\": 0x2216,\n  \"ssmile;\": 0x2323,\n  \"sstarf;\": 0x22c6,\n  \"star;\": 0x2606,\n  \"starf;\": 0x2605,\n  \"straightepsilon;\": 0x3f5,\n  \"straightphi;\": 0x3d5,\n  \"strns;\": 0xaf,\n  \"sub;\": 0x2282,\n  \"subE;\": 0x2ac5,\n  \"subdot;\": 0x2abd,\n  \"sube;\": 0x2286,\n  \"subedot;\": 0x2ac3,\n  \"submult;\": 0x2ac1,\n  \"subnE;\": 0x2acb,\n  \"subne;\": 0x228a,\n  \"subplus;\": 0x2abf,\n  \"subrarr;\": 0x2979,\n  \"subset;\": 0x2282,\n  \"subseteq;\": 0x2286,\n  \"subseteqq;\": 0x2ac5,\n  \"subsetneq;\": 0x228a,\n  \"subsetneqq;\": 0x2acb,\n  \"subsim;\": 0x2ac7,\n  \"subsub;\": 0x2ad5,\n  \"subsup;\": 0x2ad3,\n  \"succ;\": 0x227b,\n  \"succapprox;\": 0x2ab8,\n  \"succcurlyeq;\": 0x227d,\n  \"succeq;\": 0x2ab0,\n  \"succnapprox;\": 0x2aba,\n  \"succneqq;\": 0x2ab6,\n  \"succnsim;\": 0x22e9,\n  \"succsim;\": 0x227f,\n  \"sum;\": 0x2211,\n  \"sung;\": 0x266a,\n  \"sup1\": 0xb9,\n  \"sup1;\": 0xb9,\n  \"sup2\": 0xb2,\n  \"sup2;\": 0xb2,\n  \"sup3\": 0xb3,\n  \"sup3;\": 0xb3,\n  \"sup;\": 0x2283,\n  \"supE;\": 0x2ac6,\n  \"supdot;\": 0x2abe,\n  \"supdsub;\": 0x2ad8,\n  \"supe;\": 0x2287,\n  \"supedot;\": 0x2ac4,\n  \"suphsol;\": 0x27c9,\n  \"suphsub;\": 0x2ad7,\n  \"suplarr;\": 0x297b,\n  \"supmult;\": 0x2ac2,\n  \"supnE;\": 0x2acc,\n  \"supne;\": 0x228b,\n  \"supplus;\": 0x2ac0,\n  \"supset;\": 0x2283,\n  \"supseteq;\": 0x2287,\n  \"supseteqq;\": 0x2ac6,\n  \"supsetneq;\": 0x228b,\n  \"supsetneqq;\": 0x2acc,\n  \"supsim;\": 0x2ac8,\n  \"supsub;\": 0x2ad4,\n  \"supsup;\": 0x2ad6,\n  \"swArr;\": 0x21d9,\n  \"swarhk;\": 0x2926,\n  \"swarr;\": 0x2199,\n  \"swarrow;\": 0x2199,\n  \"swnwar;\": 0x292a,\n  \"szlig\": 0xdf,\n  \"szlig;\": 0xdf,\n  \"target;\": 0x2316,\n  \"tau;\": 0x3c4,\n  \"tbrk;\": 0x23b4,\n  \"tcaron;\": 0x165,\n  \"tcedil;\": 0x163,\n  \"tcy;\": 0x442,\n  \"tdot;\": 0x20db,\n  \"telrec;\": 0x2315,\n  \"tfr;\": [0xd835, 0xdd31],\n  \"there4;\": 0x2234,\n  \"therefore;\": 0x2234,\n  \"theta;\": 0x3b8,\n  \"thetasym;\": 0x3d1,\n  \"thetav;\": 0x3d1,\n  \"thickapprox;\": 0x2248,\n  \"thicksim;\": 0x223c,\n  \"thinsp;\": 0x2009,\n  \"thkap;\": 0x2248,\n  \"thksim;\": 0x223c,\n  \"thorn\": 0xfe,\n  \"thorn;\": 0xfe,\n  \"tilde;\": 0x2dc,\n  \"times\": 0xd7,\n  \"times;\": 0xd7,\n  \"timesb;\": 0x22a0,\n  \"timesbar;\": 0x2a31,\n  \"timesd;\": 0x2a30,\n  \"tint;\": 0x222d,\n  \"toea;\": 0x2928,\n  \"top;\": 0x22a4,\n  \"topbot;\": 0x2336,\n  \"topcir;\": 0x2af1,\n  \"topf;\": [0xd835, 0xdd65],\n  \"topfork;\": 0x2ada,\n  \"tosa;\": 0x2929,\n  \"tprime;\": 0x2034,\n  \"trade;\": 0x2122,\n  \"triangle;\": 0x25b5,\n  \"triangledown;\": 0x25bf,\n  \"triangleleft;\": 0x25c3,\n  \"trianglelefteq;\": 0x22b4,\n  \"triangleq;\": 0x225c,\n  \"triangleright;\": 0x25b9,\n  \"trianglerighteq;\": 0x22b5,\n  \"tridot;\": 0x25ec,\n  \"trie;\": 0x225c,\n  \"triminus;\": 0x2a3a,\n  \"triplus;\": 0x2a39,\n  \"trisb;\": 0x29cd,\n  \"tritime;\": 0x2a3b,\n  \"trpezium;\": 0x23e2,\n  \"tscr;\": [0xd835, 0xdcc9],\n  \"tscy;\": 0x446,\n  \"tshcy;\": 0x45b,\n  \"tstrok;\": 0x167,\n  \"twixt;\": 0x226c,\n  \"twoheadleftarrow;\": 0x219e,\n  \"twoheadrightarrow;\": 0x21a0,\n  \"uArr;\": 0x21d1,\n  \"uHar;\": 0x2963,\n  \"uacute\": 0xfa,\n  \"uacute;\": 0xfa,\n  \"uarr;\": 0x2191,\n  \"ubrcy;\": 0x45e,\n  \"ubreve;\": 0x16d,\n  \"ucirc\": 0xfb,\n  \"ucirc;\": 0xfb,\n  \"ucy;\": 0x443,\n  \"udarr;\": 0x21c5,\n  \"udblac;\": 0x171,\n  \"udhar;\": 0x296e,\n  \"ufisht;\": 0x297e,\n  \"ufr;\": [0xd835, 0xdd32],\n  \"ugrave\": 0xf9,\n  \"ugrave;\": 0xf9,\n  \"uharl;\": 0x21bf,\n  \"uharr;\": 0x21be,\n  \"uhblk;\": 0x2580,\n  \"ulcorn;\": 0x231c,\n  \"ulcorner;\": 0x231c,\n  \"ulcrop;\": 0x230f,\n  \"ultri;\": 0x25f8,\n  \"umacr;\": 0x16b,\n  \"uml\": 0xa8,\n  \"uml;\": 0xa8,\n  \"uogon;\": 0x173,\n  \"uopf;\": [0xd835, 0xdd66],\n  \"uparrow;\": 0x2191,\n  \"updownarrow;\": 0x2195,\n  \"upharpoonleft;\": 0x21bf,\n  \"upharpoonright;\": 0x21be,\n  \"uplus;\": 0x228e,\n  \"upsi;\": 0x3c5,\n  \"upsih;\": 0x3d2,\n  \"upsilon;\": 0x3c5,\n  \"upuparrows;\": 0x21c8,\n  \"urcorn;\": 0x231d,\n  \"urcorner;\": 0x231d,\n  \"urcrop;\": 0x230e,\n  \"uring;\": 0x16f,\n  \"urtri;\": 0x25f9,\n  \"uscr;\": [0xd835, 0xdcca],\n  \"utdot;\": 0x22f0,\n  \"utilde;\": 0x169,\n  \"utri;\": 0x25b5,\n  \"utrif;\": 0x25b4,\n  \"uuarr;\": 0x21c8,\n  \"uuml\": 0xfc,\n  \"uuml;\": 0xfc,\n  \"uwangle;\": 0x29a7,\n  \"vArr;\": 0x21d5,\n  \"vBar;\": 0x2ae8,\n  \"vBarv;\": 0x2ae9,\n  \"vDash;\": 0x22a8,\n  \"vangrt;\": 0x299c,\n  \"varepsilon;\": 0x3f5,\n  \"varkappa;\": 0x3f0,\n  \"varnothing;\": 0x2205,\n  \"varphi;\": 0x3d5,\n  \"varpi;\": 0x3d6,\n  \"varpropto;\": 0x221d,\n  \"varr;\": 0x2195,\n  \"varrho;\": 0x3f1,\n  \"varsigma;\": 0x3c2,\n  \"varsubsetneq;\": [0x228a, 0xfe00],\n  \"varsubsetneqq;\": [0x2acb, 0xfe00],\n  \"varsupsetneq;\": [0x228b, 0xfe00],\n  \"varsupsetneqq;\": [0x2acc, 0xfe00],\n  \"vartheta;\": 0x3d1,\n  \"vartriangleleft;\": 0x22b2,\n  \"vartriangleright;\": 0x22b3,\n  \"vcy;\": 0x432,\n  \"vdash;\": 0x22a2,\n  \"vee;\": 0x2228,\n  \"veebar;\": 0x22bb,\n  \"veeeq;\": 0x225a,\n  \"vellip;\": 0x22ee,\n  \"verbar;\": 0x7c,\n  \"vert;\": 0x7c,\n  \"vfr;\": [0xd835, 0xdd33],\n  \"vltri;\": 0x22b2,\n  \"vnsub;\": [0x2282, 0x20d2],\n  \"vnsup;\": [0x2283, 0x20d2],\n  \"vopf;\": [0xd835, 0xdd67],\n  \"vprop;\": 0x221d,\n  \"vrtri;\": 0x22b3,\n  \"vscr;\": [0xd835, 0xdccb],\n  \"vsubnE;\": [0x2acb, 0xfe00],\n  \"vsubne;\": [0x228a, 0xfe00],\n  \"vsupnE;\": [0x2acc, 0xfe00],\n  \"vsupne;\": [0x228b, 0xfe00],\n  \"vzigzag;\": 0x299a,\n  \"wcirc;\": 0x175,\n  \"wedbar;\": 0x2a5f,\n  \"wedge;\": 0x2227,\n  \"wedgeq;\": 0x2259,\n  \"weierp;\": 0x2118,\n  \"wfr;\": [0xd835, 0xdd34],\n  \"wopf;\": [0xd835, 0xdd68],\n  \"wp;\": 0x2118,\n  \"wr;\": 0x2240,\n  \"wreath;\": 0x2240,\n  \"wscr;\": [0xd835, 0xdccc],\n  \"xcap;\": 0x22c2,\n  \"xcirc;\": 0x25ef,\n  \"xcup;\": 0x22c3,\n  \"xdtri;\": 0x25bd,\n  \"xfr;\": [0xd835, 0xdd35],\n  \"xhArr;\": 0x27fa,\n  \"xharr;\": 0x27f7,\n  \"xi;\": 0x3be,\n  \"xlArr;\": 0x27f8,\n  \"xlarr;\": 0x27f5,\n  \"xmap;\": 0x27fc,\n  \"xnis;\": 0x22fb,\n  \"xodot;\": 0x2a00,\n  \"xopf;\": [0xd835, 0xdd69],\n  \"xoplus;\": 0x2a01,\n  \"xotime;\": 0x2a02,\n  \"xrArr;\": 0x27f9,\n  \"xrarr;\": 0x27f6,\n  \"xscr;\": [0xd835, 0xdccd],\n  \"xsqcup;\": 0x2a06,\n  \"xuplus;\": 0x2a04,\n  \"xutri;\": 0x25b3,\n  \"xvee;\": 0x22c1,\n  \"xwedge;\": 0x22c0,\n  \"yacute\": 0xfd,\n  \"yacute;\": 0xfd,\n  \"yacy;\": 0x44f,\n  \"ycirc;\": 0x177,\n  \"ycy;\": 0x44b,\n  \"yen\": 0xa5,\n  \"yen;\": 0xa5,\n  \"yfr;\": [0xd835, 0xdd36],\n  \"yicy;\": 0x457,\n  \"yopf;\": [0xd835, 0xdd6a],\n  \"yscr;\": [0xd835, 0xdcce],\n  \"yucy;\": 0x44e,\n  \"yuml\": 0xff,\n  \"yuml;\": 0xff,\n  \"zacute;\": 0x17a,\n  \"zcaron;\": 0x17e,\n  \"zcy;\": 0x437,\n  \"zdot;\": 0x17c,\n  \"zeetrf;\": 0x2128,\n  \"zeta;\": 0x3b6,\n  \"zfr;\": [0xd835, 0xdd37],\n  \"zhcy;\": 0x436,\n  \"zigrarr;\": 0x21dd,\n  \"zopf;\": [0xd835, 0xdd6b],\n  \"zscr;\": [0xd835, 0xdccf],\n  \"zwj;\": 0x200d,\n  \"zwnj;\": 0x200c\n};\n/*\n * This regexp is generated with test/tools/update-entities.js\n * It will always match at least one character -- but note that there\n * are no entities whose names are a single character long.\n */\n\nvar NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\\s\\S]/g;\nvar NAMEDCHARREF_MAXLEN = 32; // Regular expression constants used by the tokenizer and parser\n// Note that \\r is included in all of these regexps because it will need\n// to be converted to LF by the scanChars() function.\n\nvar DBLQUOTEATTRVAL = /[^\\r\"&\\u0000]+/g;\nvar SINGLEQUOTEATTRVAL = /[^\\r'&\\u0000]+/g;\nvar UNQUOTEDATTRVAL = /[^\\r\\t\\n\\f &>\\u0000]+/g;\nvar TAGNAME = /[^\\r\\t\\n\\f \\/>A-Z\\u0000]+/g;\nvar ATTRNAME = /[^\\r\\t\\n\\f \\/=>A-Z\\u0000]+/g;\nvar CDATATEXT = /[^\\]\\r\\u0000\\uffff]*/g;\nvar DATATEXT = /[^&<\\r\\u0000\\uffff]*/g;\nvar RAWTEXT = /[^<\\r\\u0000\\uffff]*/g;\nvar PLAINTEXT = /[^\\r\\u0000\\uffff]*/g; // Since we don't have the 'sticky tag', add '|.' to the end of SIMPLETAG\n// and SIMPLEATTR so that we are guaranteed to always match.  This prevents\n// us from scanning past the lastIndex set. (Note that the desired matches\n// are always greater than 1 char long, so longest-match will ensure that .\n// is not matched unless the desired match fails.)\n\nvar SIMPLETAG = /(?:(\\/)?([a-z]+)>)|[\\s\\S]/g;\nvar SIMPLEATTR = /(?:([-a-z]+)[ \\t\\n\\f]*=[ \\t\\n\\f]*('[^'&\\r\\u0000]*'|\"[^\"&\\r\\u0000]*\"|[^\\t\\n\\r\\f \"&'\\u0000>][^&> \\t\\n\\r\\f\\u0000]*[ \\t\\n\\f]))|[\\s\\S]/g;\nvar NONWS = /[^\\x09\\x0A\\x0C\\x0D\\x20]/;\nvar ALLNONWS = /[^\\x09\\x0A\\x0C\\x0D\\x20]/g; // like above, with g flag\n\nvar NONWSNONNUL = /[^\\x00\\x09\\x0A\\x0C\\x0D\\x20]/; // don't allow NUL either\n\nvar LEADINGWS = /^[\\x09\\x0A\\x0C\\x0D\\x20]+/;\nvar NULCHARS = /\\x00/g;\n/***\n * These are utility functions that don't use any of the parser's\n * internal state.\n */\n\nfunction buf2str(buf) {\n  var CHUNKSIZE = 16384;\n\n  if (buf.length < CHUNKSIZE) {\n    return String.fromCharCode.apply(String, buf);\n  } // special case for large strings, to avoid busting the stack.\n\n\n  var result = '';\n\n  for (var i = 0; i < buf.length; i += CHUNKSIZE) {\n    result += String.fromCharCode.apply(String, buf.slice(i, i + CHUNKSIZE));\n  }\n\n  return result;\n}\n\nfunction str2buf(s) {\n  var result = [];\n\n  for (var i = 0; i < s.length; i++) {\n    result[i] = s.charCodeAt(i);\n  }\n\n  return result;\n} // Determine whether the element is a member of the set.\n// The set is an object that maps namespaces to objects. The objects\n// then map local tagnames to the value true if that tag is part of the set\n\n\nfunction isA(elt, set) {\n  if (typeof set === 'string') {\n    // convenience case for testing a particular HTML element\n    return elt.namespaceURI === NAMESPACE.HTML && elt.localName === set;\n  }\n\n  var tagnames = set[elt.namespaceURI];\n  return tagnames && tagnames[elt.localName];\n}\n\nfunction isMathmlTextIntegrationPoint(n) {\n  return isA(n, mathmlTextIntegrationPointSet);\n}\n\nfunction isHTMLIntegrationPoint(n) {\n  if (isA(n, htmlIntegrationPointSet)) return true;\n\n  if (n.namespaceURI === NAMESPACE.MATHML && n.localName === \"annotation-xml\") {\n    var encoding = n.getAttribute(\"encoding\");\n    if (encoding) encoding = encoding.toLowerCase();\n    if (encoding === \"text/html\" || encoding === \"application/xhtml+xml\") return true;\n  }\n\n  return false;\n}\n\nfunction adjustSVGTagName(name) {\n  if (name in svgTagNameAdjustments) return svgTagNameAdjustments[name];else return name;\n}\n\nfunction adjustSVGAttributes(attrs) {\n  for (var i = 0, n = attrs.length; i < n; i++) {\n    if (attrs[i][0] in svgAttrAdjustments) {\n      attrs[i][0] = svgAttrAdjustments[attrs[i][0]];\n    }\n  }\n}\n\nfunction adjustMathMLAttributes(attrs) {\n  for (var i = 0, n = attrs.length; i < n; i++) {\n    if (attrs[i][0] === \"definitionurl\") {\n      attrs[i][0] = \"definitionURL\";\n      break;\n    }\n  }\n}\n\nfunction adjustForeignAttributes(attrs) {\n  for (var i = 0, n = attrs.length; i < n; i++) {\n    if (attrs[i][0] in foreignAttributes) {\n      // Attributes with namespaces get a 3rd element:\n      // [Qname, value, namespace]\n      attrs[i].push(foreignAttributes[attrs[i][0]]);\n    }\n  }\n} // For each attribute in attrs, if elt doesn't have an attribute\n// by that name, add the attribute to elt\n// XXX: I'm ignoring namespaces for now\n\n\nfunction transferAttributes(attrs, elt) {\n  for (var i = 0, n = attrs.length; i < n; i++) {\n    var name = attrs[i][0],\n        value = attrs[i][1];\n    if (elt.hasAttribute(name)) continue;\n\n    elt._setAttribute(name, value);\n  }\n}\n/***\n * The ElementStack class\n */\n\n\nHTMLParser.ElementStack = function ElementStack() {\n  this.elements = [];\n  this.top = null; // stack.top is the \"current node\" in the spec\n};\n/*\n// This is for debugging only\nHTMLParser.ElementStack.prototype.toString = function(e) {\n  return \"STACK: \" +\n  this.elements.map(function(e) {return e.localName;}).join(\"-\");\n}\n*/\n\n\nHTMLParser.ElementStack.prototype.push = function (e) {\n  this.elements.push(e);\n  this.top = e;\n};\n\nHTMLParser.ElementStack.prototype.pop = function (e) {\n  this.elements.pop();\n  this.top = this.elements[this.elements.length - 1];\n}; // Pop elements off the stack up to and including the first\n// element with the specified (HTML) tagname\n\n\nHTMLParser.ElementStack.prototype.popTag = function (tag) {\n  for (var i = this.elements.length - 1; i > 0; i--) {\n    var e = this.elements[i];\n    if (isA(e, tag)) break;\n  }\n\n  this.elements.length = i;\n  this.top = this.elements[i - 1];\n}; // Pop elements off the stack up to and including the first\n// element that is an instance of the specified type\n\n\nHTMLParser.ElementStack.prototype.popElementType = function (type) {\n  for (var i = this.elements.length - 1; i > 0; i--) {\n    if (this.elements[i] instanceof type) break;\n  }\n\n  this.elements.length = i;\n  this.top = this.elements[i - 1];\n}; // Pop elements off the stack up to and including the element e.\n// Note that this is very different from removeElement()\n// This requires that e is on the stack.\n\n\nHTMLParser.ElementStack.prototype.popElement = function (e) {\n  for (var i = this.elements.length - 1; i > 0; i--) {\n    if (this.elements[i] === e) break;\n  }\n\n  this.elements.length = i;\n  this.top = this.elements[i - 1];\n}; // Remove a specific element from the stack.\n// Do nothing if the element is not on the stack\n\n\nHTMLParser.ElementStack.prototype.removeElement = function (e) {\n  if (this.top === e) this.pop();else {\n    var idx = this.elements.lastIndexOf(e);\n    if (idx !== -1) this.elements.splice(idx, 1);\n  }\n};\n\nHTMLParser.ElementStack.prototype.clearToContext = function (set) {\n  // Note that we don't loop to 0. Never pop the <html> elt off.\n  for (var i = this.elements.length - 1; i > 0; i--) {\n    if (isA(this.elements[i], set)) break;\n  }\n\n  this.elements.length = i + 1;\n  this.top = this.elements[i];\n};\n\nHTMLParser.ElementStack.prototype.contains = function (tag) {\n  return this.inSpecificScope(tag, Object.create(null));\n};\n\nHTMLParser.ElementStack.prototype.inSpecificScope = function (tag, set) {\n  for (var i = this.elements.length - 1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (isA(elt, tag)) return true;\n    if (isA(elt, set)) return false;\n  }\n\n  return false;\n}; // Like the above, but for a specific element, not a tagname\n\n\nHTMLParser.ElementStack.prototype.elementInSpecificScope = function (target, set) {\n  for (var i = this.elements.length - 1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (elt === target) return true;\n    if (isA(elt, set)) return false;\n  }\n\n  return false;\n}; // Like the above, but for an element interface, not a tagname\n\n\nHTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function (target, set) {\n  for (var i = this.elements.length - 1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (elt instanceof target) return true;\n    if (isA(elt, set)) return false;\n  }\n\n  return false;\n};\n\nHTMLParser.ElementStack.prototype.inScope = function (tag) {\n  return this.inSpecificScope(tag, inScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.elementInScope = function (e) {\n  return this.elementInSpecificScope(e, inScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.elementTypeInScope = function (type) {\n  return this.elementTypeInSpecificScope(type, inScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inButtonScope = function (tag) {\n  return this.inSpecificScope(tag, inButtonScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inListItemScope = function (tag) {\n  return this.inSpecificScope(tag, inListItemScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inTableScope = function (tag) {\n  return this.inSpecificScope(tag, inTableScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inSelectScope = function (tag) {\n  // Can't implement this one with inSpecificScope, since it involves\n  // a set defined by inverting another set. So implement manually.\n  for (var i = this.elements.length - 1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (elt.namespaceURI !== NAMESPACE.HTML) return false;\n    var localname = elt.localName;\n    if (localname === tag) return true;\n    if (localname !== \"optgroup\" && localname !== \"option\") return false;\n  }\n\n  return false;\n};\n\nHTMLParser.ElementStack.prototype.generateImpliedEndTags = function (butnot, thorough) {\n  var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;\n\n  for (var i = this.elements.length - 1; i >= 0; i--) {\n    var e = this.elements[i];\n    if (butnot && isA(e, butnot)) break;\n    if (!isA(this.elements[i], endTagSet)) break;\n  }\n\n  this.elements.length = i + 1;\n  this.top = this.elements[i];\n};\n/***\n * The ActiveFormattingElements class\n */\n\n\nHTMLParser.ActiveFormattingElements = function AFE() {\n  this.list = []; // elements\n\n  this.attrs = []; // attribute tokens for cloning\n};\n\nHTMLParser.ActiveFormattingElements.prototype.MARKER = {\n  localName: \"|\"\n};\n/*\n// For debugging\nHTMLParser.ActiveFormattingElements.prototype.toString = function() {\n  return \"AFE: \" +\n  this.list.map(function(e) { return e.localName; }).join(\"-\");\n}\n*/\n\nHTMLParser.ActiveFormattingElements.prototype.insertMarker = function () {\n  this.list.push(this.MARKER);\n  this.attrs.push(this.MARKER);\n};\n\nHTMLParser.ActiveFormattingElements.prototype.push = function (elt, attrs) {\n  // Scan backwards: if there are already 3 copies of this element\n  // before we encounter a marker, then drop the last one\n  var count = 0;\n\n  for (var i = this.list.length - 1; i >= 0; i--) {\n    if (this.list[i] === this.MARKER) break; // equal() is defined below\n\n    if (equal(elt, this.list[i], this.attrs[i])) {\n      count++;\n\n      if (count === 3) {\n        this.list.splice(i, 1);\n        this.attrs.splice(i, 1);\n        break;\n      }\n    }\n  } // Now push the element onto the list\n\n\n  this.list.push(elt); // Copy the attributes and push those on, too\n\n  var attrcopy = [];\n\n  for (var ii = 0; ii < attrs.length; ii++) {\n    attrcopy[ii] = attrs[ii];\n  }\n\n  this.attrs.push(attrcopy); // This function defines equality of two elements for the purposes\n  // of the AFE list.  Note that it compares the new elements\n  // attributes to the saved array of attributes associated with\n  // the old element because a script could have changed the\n  // old element's set of attributes\n\n  function equal(newelt, oldelt, oldattrs) {\n    if (newelt.localName !== oldelt.localName) return false;\n    if (newelt._numattrs !== oldattrs.length) return false;\n\n    for (var i = 0, n = oldattrs.length; i < n; i++) {\n      var oldname = oldattrs[i][0];\n      var oldval = oldattrs[i][1];\n      if (!newelt.hasAttribute(oldname)) return false;\n      if (newelt.getAttribute(oldname) !== oldval) return false;\n    }\n\n    return true;\n  }\n};\n\nHTMLParser.ActiveFormattingElements.prototype.clearToMarker = function () {\n  for (var i = this.list.length - 1; i >= 0; i--) {\n    if (this.list[i] === this.MARKER) break;\n  }\n\n  if (i < 0) i = 0;\n  this.list.length = i;\n  this.attrs.length = i;\n}; // Find and return the last element with the specified tag between the\n// end of the list and the last marker on the list.\n// Used when parsing <a> in_body_mode()\n\n\nHTMLParser.ActiveFormattingElements.prototype.findElementByTag = function (tag) {\n  for (var i = this.list.length - 1; i >= 0; i--) {\n    var elt = this.list[i];\n    if (elt === this.MARKER) break;\n    if (elt.localName === tag) return elt;\n  }\n\n  return null;\n};\n\nHTMLParser.ActiveFormattingElements.prototype.indexOf = function (e) {\n  return this.list.lastIndexOf(e);\n}; // Find the element e in the list and remove it\n// Used when parsing <a> in_body()\n\n\nHTMLParser.ActiveFormattingElements.prototype.remove = function (e) {\n  var idx = this.list.lastIndexOf(e);\n\n  if (idx !== -1) {\n    this.list.splice(idx, 1);\n    this.attrs.splice(idx, 1);\n  }\n}; // Find element a in the list and replace it with element b\n// XXX: Do I need to handle attributes here?\n\n\nHTMLParser.ActiveFormattingElements.prototype.replace = function (a, b, attrs) {\n  var idx = this.list.lastIndexOf(a);\n\n  if (idx !== -1) {\n    this.list[idx] = b;\n    this.attrs[idx] = attrs;\n  }\n}; // Find a in the list and insert b after it\n// This is only used for insert a bookmark object, so the\n// attrs array doesn't really matter\n\n\nHTMLParser.ActiveFormattingElements.prototype.insertAfter = function (a, b) {\n  var idx = this.list.lastIndexOf(a);\n\n  if (idx !== -1) {\n    this.list.splice(idx, 0, b);\n    this.attrs.splice(idx, 0, b);\n  }\n};\n/***\n * This is the parser factory function. It is the return value of\n * the outer closure that it is defined within.  Most of the parser\n * implementation details are inside this function.\n */\n\n\nfunction HTMLParser(address, fragmentContext, options) {\n  /***\n   * These are the parser's state variables\n   */\n  // Scanner state\n  var chars = null;\n  var numchars = 0; // Length of chars\n\n  var nextchar = 0; // Index of next char\n\n  var input_complete = false; // Becomes true when end() called.\n\n  var scanner_skip_newline = false; // If previous char was CR\n\n  var reentrant_invocations = 0;\n  var saved_scanner_state = [];\n  var leftovers = \"\";\n  var first_batch = true;\n  var paused = 0; // Becomes non-zero while loading scripts\n  // Tokenizer state\n\n  var tokenizer = data_state; // Current tokenizer state\n\n  var return_state;\n  var character_reference_code;\n  var tagnamebuf = \"\";\n  var lasttagname = \"\"; // holds the target end tag for text states\n\n  var tempbuf = [];\n  var attrnamebuf = \"\";\n  var attrvaluebuf = \"\";\n  var commentbuf = [];\n  var doctypenamebuf = [];\n  var doctypepublicbuf = [];\n  var doctypesystembuf = [];\n  var attributes = [];\n  var is_end_tag = false; // Tree builder state\n\n  var parser = initial_mode; // Current insertion mode\n\n  var originalInsertionMode = null; // A saved insertion mode\n\n  var templateInsertionModes = []; // Stack of template insertion modes.\n\n  var stack = new HTMLParser.ElementStack(); // Stack of open elements\n\n  var afe = new HTMLParser.ActiveFormattingElements(); // mis-nested tags\n\n  var fragment = fragmentContext !== undefined; // For innerHTML, etc.\n\n  var head_element_pointer = null;\n  var form_element_pointer = null;\n  var scripting_enabled = true;\n\n  if (fragmentContext) {\n    scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;\n  }\n\n  if (options && options.scripting_enabled === false) scripting_enabled = false;\n  var frameset_ok = true;\n  var force_quirks = false;\n  var pending_table_text;\n  var text_integration_mode; // XXX a spec bug workaround?\n  // A single run of characters, buffered up to be sent to\n  // the parser as a single string.\n\n  var textrun = [];\n  var textIncludesNUL = false;\n  var ignore_linefeed = false;\n  /***\n   * This is the parser object that will be the return value of this\n   * factory function, which is some 5000 lines below.\n   * Note that the variable \"parser\" is the current state of the\n   * parser's state machine.  This variable \"htmlparser\" is the\n   * return value and defines the public API of the parser\n   */\n\n  var htmlparser = {\n    document: function () {\n      return doc;\n    },\n    // Convenience function for internal use. Can only be called once,\n    // as it removes the nodes from `doc` to add them to fragment.\n    _asDocumentFragment: function () {\n      var frag = doc.createDocumentFragment();\n      var root = doc.firstChild;\n\n      while (root.hasChildNodes()) {\n        frag.appendChild(root.firstChild);\n      }\n\n      return frag;\n    },\n    // Internal function used from HTMLScriptElement to pause the\n    // parser while a script is being loaded from the network\n    pause: function () {\n      // print(\"pausing parser\");\n      paused++;\n    },\n    // Called when a script finishes loading\n    resume: function () {\n      // print(\"resuming parser\");\n      paused--; // XXX: added this to force a resumption.\n      // Is this the right thing to do?\n\n      this.parse(\"\");\n    },\n    // Parse the HTML text s.\n    // The second argument should be true if there is no more\n    // text to be parsed, and should be false or omitted otherwise.\n    // The second argument must not be set for recursive invocations\n    // from document.write()\n    parse: function (s, end, shouldPauseFunc) {\n      var moreToDo; // If we're paused, remember the text to parse, but\n      // don't parse it now.\n      // (Don't invoke shouldPauseFunc because we haven't handled 'end' yet.)\n\n      if (paused > 0) {\n        leftovers += s;\n        return true; // more to do\n      }\n\n      if (reentrant_invocations === 0) {\n        // A normal, top-level invocation\n        if (leftovers) {\n          s = leftovers + s;\n          leftovers = \"\";\n        } // Add a special marker character to the end of\n        // the buffer.  If the scanner is at the end of\n        // the buffer and input_complete is set, then this\n        // character will transform into an EOF token.\n        // Having an actual character that represents EOF\n        // in the character buffer makes lookahead regexp\n        // matching work more easily, and this is\n        // important for character references.\n\n\n        if (end) {\n          s += \"\\uFFFF\";\n          input_complete = true; // Makes scanChars() send EOF\n        }\n\n        chars = s;\n        numchars = s.length;\n        nextchar = 0;\n\n        if (first_batch) {\n          // We skip a leading Byte Order Mark (\\uFEFF)\n          // on first batch of text we're given\n          first_batch = false;\n          if (chars.charCodeAt(0) === 0xFEFF) nextchar = 1;\n        }\n\n        reentrant_invocations++;\n        moreToDo = scanChars(shouldPauseFunc);\n        leftovers = chars.substring(nextchar, numchars);\n        reentrant_invocations--;\n      } else {\n        // This is the re-entrant case, which we have to\n        // handle a little differently.\n        reentrant_invocations++; // Save current scanner state\n\n        saved_scanner_state.push(chars, numchars, nextchar); // Set new scanner state\n\n        chars = s;\n        numchars = s.length;\n        nextchar = 0; // Now scan as many of these new chars as we can\n\n        scanChars();\n        moreToDo = false;\n        leftovers = chars.substring(nextchar, numchars); // restore old scanner state\n\n        nextchar = saved_scanner_state.pop();\n        numchars = saved_scanner_state.pop();\n        chars = saved_scanner_state.pop(); // If there were leftover chars from this invocation\n        // insert them into the pending invocation's buffer\n        // and trim already processed chars at the same time\n\n        if (leftovers) {\n          chars = leftovers + chars.substring(nextchar);\n          numchars = chars.length;\n          nextchar = 0;\n          leftovers = \"\";\n        } // Decrement the counter\n\n\n        reentrant_invocations--;\n      }\n\n      return moreToDo;\n    }\n  }; // This is the document we'll be building up\n\n  var doc = new Document(true, address); // The document needs to know about the parser, for document.write().\n  // This _parser property will be deleted when we're done parsing.\n\n  doc._parser = htmlparser; // XXX I think that any document we use this parser on should support\n  // scripts. But I may need to configure that through a parser parameter\n  // Only documents with windows (\"browsing contexts\" to be precise)\n  // allow scripting.\n\n  doc._scripting_enabled = scripting_enabled;\n  /***\n   * The actual code of the HTMLParser() factory function begins here.\n   */\n\n  if (fragmentContext) {\n    // for innerHTML parsing\n    if (fragmentContext.ownerDocument._quirks) doc._quirks = true;\n    if (fragmentContext.ownerDocument._limitedQuirks) doc._limitedQuirks = true; // Set the initial tokenizer state\n\n    if (fragmentContext.namespaceURI === NAMESPACE.HTML) {\n      switch (fragmentContext.localName) {\n        case \"title\":\n        case \"textarea\":\n          tokenizer = rcdata_state;\n          break;\n\n        case \"style\":\n        case \"xmp\":\n        case \"iframe\":\n        case \"noembed\":\n        case \"noframes\":\n        case \"script\":\n        case \"plaintext\":\n          tokenizer = plaintext_state;\n          break;\n\n        case \"noscript\":\n          if (scripting_enabled) tokenizer = plaintext_state;\n      }\n    }\n\n    var root = doc.createElement(\"html\");\n\n    doc._appendChild(root);\n\n    stack.push(root);\n\n    if (fragmentContext instanceof impl.HTMLTemplateElement) {\n      templateInsertionModes.push(in_template_mode);\n    }\n\n    resetInsertionMode();\n\n    for (var e = fragmentContext; e !== null; e = e.parentElement) {\n      if (e instanceof impl.HTMLFormElement) {\n        form_element_pointer = e;\n        break;\n      }\n    }\n  }\n  /***\n   * Scanner functions\n   */\n  // Loop through the characters in chars, and pass them one at a time\n  // to the tokenizer FSM. Return when no more characters can be processed\n  // (This may leave 1 or more characters in the buffer: like a CR\n  // waiting to see if the next char is LF, or for states that require\n  // lookahead...)\n\n\n  function scanChars(shouldPauseFunc) {\n    var codepoint, s, pattern, eof;\n\n    while (nextchar < numchars) {\n      // If we just tokenized a </script> tag, then the paused flag\n      // may have been set to tell us to stop tokenizing while\n      // the script is loading\n      if (paused > 0 || shouldPauseFunc && shouldPauseFunc()) {\n        return true;\n      }\n\n      switch (typeof tokenizer.lookahead) {\n        case 'undefined':\n          codepoint = chars.charCodeAt(nextchar++);\n\n          if (scanner_skip_newline) {\n            scanner_skip_newline = false;\n\n            if (codepoint === 0x000A) {\n              nextchar++;\n              continue;\n            }\n          }\n\n          switch (codepoint) {\n            case 0x000D:\n              // CR always turns into LF, but if the next character\n              // is LF, then that second LF is skipped.\n              if (nextchar < numchars) {\n                if (chars.charCodeAt(nextchar) === 0x000A) nextchar++;\n              } else {\n                // We don't know the next char right now, so we\n                // can't check if it is a LF.  So set a flag\n                scanner_skip_newline = true;\n              } // In either case, emit a LF\n\n\n              tokenizer(0x000A);\n              break;\n\n            case 0xFFFF:\n              if (input_complete && nextchar === numchars) {\n                tokenizer(EOF); // codepoint will be 0xFFFF here\n\n                break;\n              }\n\n            /* falls through */\n\n            default:\n              tokenizer(codepoint);\n              break;\n          }\n\n          break;\n\n        case 'number':\n          codepoint = chars.charCodeAt(nextchar); // The only tokenizer states that require fixed lookahead\n          // only consume alphanum characters, so we don't have\n          // to worry about CR and LF in this case\n          // tokenizer wants n chars of lookahead\n\n          var n = tokenizer.lookahead;\n          var needsString = true;\n\n          if (n < 0) {\n            needsString = false;\n            n = -n;\n          }\n\n          if (n < numchars - nextchar) {\n            // If we can look ahead that far\n            s = needsString ? chars.substring(nextchar, nextchar + n) : null;\n            eof = false;\n          } else {\n            // if we don't have that many characters\n            if (input_complete) {\n              // If no more are coming\n              // Just return what we have\n              s = needsString ? chars.substring(nextchar, numchars) : null;\n              eof = true;\n              if (codepoint === 0xFFFF && nextchar === numchars - 1) codepoint = EOF;\n            } else {\n              // Return now and wait for more chars later\n              return true;\n            }\n          }\n\n          tokenizer(codepoint, s, eof);\n          break;\n\n        case 'string':\n          codepoint = chars.charCodeAt(nextchar); // tokenizer wants characters up to a matching string\n\n          pattern = tokenizer.lookahead;\n          var pos = chars.indexOf(pattern, nextchar);\n\n          if (pos !== -1) {\n            s = chars.substring(nextchar, pos + pattern.length);\n            eof = false;\n          } else {\n            // No match\n            // If more characters coming, wait for them\n            if (!input_complete) return true; // Otherwise, we've got to return what we've got\n\n            s = chars.substring(nextchar, numchars);\n            if (codepoint === 0xFFFF && nextchar === numchars - 1) codepoint = EOF;\n            eof = true;\n          } // The tokenizer states that require this kind of\n          // lookahead have to be careful to handle CR characters\n          // correctly\n\n\n          tokenizer(codepoint, s, eof);\n          break;\n      }\n    }\n\n    return false; // no more characters to scan!\n  }\n  /***\n   * Tokenizer utility functions\n   */\n\n\n  function addAttribute(name, value) {\n    // Make sure there isn't already an attribute with this name\n    // If there is, ignore this one.\n    for (var i = 0; i < attributes.length; i++) {\n      if (attributes[i][0] === name) return;\n    }\n\n    if (value !== undefined) {\n      attributes.push([name, value]);\n    } else {\n      attributes.push([name]);\n    }\n  } // Shortcut for simple attributes\n\n\n  function handleSimpleAttribute() {\n    SIMPLEATTR.lastIndex = nextchar - 1;\n    var matched = SIMPLEATTR.exec(chars);\n    if (!matched) throw new Error(\"should never happen\");\n    var name = matched[1];\n    if (!name) return false;\n    var value = matched[2];\n    var len = value.length;\n\n    switch (value[0]) {\n      case '\"':\n      case \"'\":\n        value = value.substring(1, len - 1);\n        nextchar += matched[0].length - 1;\n        tokenizer = after_attribute_value_quoted_state;\n        break;\n\n      default:\n        tokenizer = before_attribute_name_state;\n        nextchar += matched[0].length - 1;\n        value = value.substring(0, len - 1);\n        break;\n    } // Make sure there isn't already an attribute with this name\n    // If there is, ignore this one.\n\n\n    for (var i = 0; i < attributes.length; i++) {\n      if (attributes[i][0] === name) return true;\n    }\n\n    attributes.push([name, value]);\n    return true;\n  }\n\n  function beginTagName() {\n    is_end_tag = false;\n    tagnamebuf = \"\";\n    attributes.length = 0;\n  }\n\n  function beginEndTagName() {\n    is_end_tag = true;\n    tagnamebuf = \"\";\n    attributes.length = 0;\n  }\n\n  function beginTempBuf() {\n    tempbuf.length = 0;\n  }\n\n  function beginAttrName() {\n    attrnamebuf = \"\";\n  }\n\n  function beginAttrValue() {\n    attrvaluebuf = \"\";\n  }\n\n  function beginComment() {\n    commentbuf.length = 0;\n  }\n\n  function beginDoctype() {\n    doctypenamebuf.length = 0;\n    doctypepublicbuf = null;\n    doctypesystembuf = null;\n  }\n\n  function beginDoctypePublicId() {\n    doctypepublicbuf = [];\n  }\n\n  function beginDoctypeSystemId() {\n    doctypesystembuf = [];\n  }\n\n  function forcequirks() {\n    force_quirks = true;\n  }\n\n  function cdataAllowed() {\n    return stack.top && stack.top.namespaceURI !== \"http://www.w3.org/1999/xhtml\";\n  } // Return true if the codepoints in the specified buffer match the\n  // characters of lasttagname\n\n\n  function appropriateEndTag(buf) {\n    return lasttagname === buf;\n  }\n\n  function flushText() {\n    if (textrun.length > 0) {\n      var s = buf2str(textrun);\n      textrun.length = 0;\n\n      if (ignore_linefeed) {\n        ignore_linefeed = false;\n        if (s[0] === \"\\n\") s = s.substring(1);\n        if (s.length === 0) return;\n      }\n\n      insertToken(TEXT, s);\n      textIncludesNUL = false;\n    }\n\n    ignore_linefeed = false;\n  } // Consume chars matched by the pattern and return them as a string. Starts\n  // matching at the current position, so users should drop the current char\n  // otherwise.\n\n\n  function getMatchingChars(pattern) {\n    pattern.lastIndex = nextchar - 1;\n    var match = pattern.exec(chars);\n\n    if (match && match.index === nextchar - 1) {\n      match = match[0];\n      nextchar += match.length - 1;\n      /* Careful!  Make sure we haven't matched the EOF character! */\n\n      if (input_complete && nextchar === numchars) {\n        // Oops, backup one.\n        match = match.slice(0, -1);\n        nextchar--;\n      }\n\n      return match;\n    } else {\n      throw new Error(\"should never happen\");\n    }\n  } // emit a string of chars that match a regexp\n  // Returns false if no chars matched.\n\n\n  function emitCharsWhile(pattern) {\n    pattern.lastIndex = nextchar - 1;\n    var match = pattern.exec(chars)[0];\n    if (!match) return false;\n    emitCharString(match);\n    nextchar += match.length - 1;\n    return true;\n  } // This is used by CDATA sections\n\n\n  function emitCharString(s) {\n    if (textrun.length > 0) flushText();\n\n    if (ignore_linefeed) {\n      ignore_linefeed = false;\n      if (s[0] === \"\\n\") s = s.substring(1);\n      if (s.length === 0) return;\n    }\n\n    insertToken(TEXT, s);\n  }\n\n  function emitTag() {\n    if (is_end_tag) insertToken(ENDTAG, tagnamebuf);else {\n      // Remember the last open tag we emitted\n      var tagname = tagnamebuf;\n      tagnamebuf = \"\";\n      lasttagname = tagname;\n      insertToken(TAG, tagname, attributes);\n    }\n  } // A shortcut: look ahead and if this is a open or close tag\n  // in lowercase with no spaces and no attributes, just emit it now.\n\n\n  function emitSimpleTag() {\n    if (nextchar === numchars) {\n      return false;\n      /* not even 1 char left */\n    }\n\n    SIMPLETAG.lastIndex = nextchar;\n    var matched = SIMPLETAG.exec(chars);\n    if (!matched) throw new Error(\"should never happen\");\n    var tagname = matched[2];\n    if (!tagname) return false;\n    var endtag = matched[1];\n\n    if (endtag) {\n      nextchar += tagname.length + 2;\n      insertToken(ENDTAG, tagname);\n    } else {\n      nextchar += tagname.length + 1;\n      lasttagname = tagname;\n      insertToken(TAG, tagname, NOATTRS);\n    }\n\n    return true;\n  }\n\n  function emitSelfClosingTag() {\n    if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);else {\n      insertToken(TAG, tagnamebuf, attributes, true);\n    }\n  }\n\n  function emitDoctype() {\n    insertToken(DOCTYPE, buf2str(doctypenamebuf), doctypepublicbuf ? buf2str(doctypepublicbuf) : undefined, doctypesystembuf ? buf2str(doctypesystembuf) : undefined);\n  }\n\n  function emitEOF() {\n    flushText();\n    parser(EOF); // EOF never goes to insertForeignContent()\n\n    doc.modclock = 1; // Start tracking modifications\n  } // Insert a token, either using the current parser insertion mode\n  // (for HTML stuff) or using the insertForeignToken() method.\n\n\n  var insertToken = htmlparser.insertToken = function insertToken(t, value, arg3, arg4) {\n    flushText();\n    var current = stack.top;\n\n    if (!current || current.namespaceURI === NAMESPACE.HTML) {\n      // This is the common case\n      parser(t, value, arg3, arg4);\n    } else {\n      // Otherwise we may need to insert this token as foreign content\n      if (t !== TAG && t !== TEXT) {\n        insertForeignToken(t, value, arg3, arg4);\n      } else {\n        // But in some cases we treat it as regular content\n        if (isMathmlTextIntegrationPoint(current) && (t === TEXT || t === TAG && value !== \"mglyph\" && value !== \"malignmark\") || t === TAG && value === \"svg\" && current.namespaceURI === NAMESPACE.MATHML && current.localName === \"annotation-xml\" || isHTMLIntegrationPoint(current)) {\n          // XXX: the text_integration_mode stuff is an\n          // attempted bug workaround of mine\n          text_integration_mode = true;\n          parser(t, value, arg3, arg4);\n          text_integration_mode = false;\n        } // Otherwise it is foreign content\n        else {\n            insertForeignToken(t, value, arg3, arg4);\n          }\n      }\n    }\n  };\n  /***\n   * Tree building utility functions\n   */\n\n\n  function insertComment(data) {\n    var parent = stack.top;\n\n    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {\n      fosterParent(function (doc) {\n        return doc.createComment(data);\n      });\n    } else {\n      // \"If the adjusted insertion location is inside a template element,\n      // let it instead be inside the template element's template contents\"\n      if (parent instanceof impl.HTMLTemplateElement) {\n        parent = parent.content;\n      }\n\n      parent._appendChild(parent.ownerDocument.createComment(data));\n    }\n  }\n\n  function insertText(s) {\n    var parent = stack.top;\n\n    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {\n      fosterParent(function (doc) {\n        return doc.createTextNode(s);\n      });\n    } else {\n      // \"If the adjusted insertion location is inside a template element,\n      // let it instead be inside the template element's template contents\"\n      if (parent instanceof impl.HTMLTemplateElement) {\n        parent = parent.content;\n      } // \"If there is a Text node immediately before the adjusted insertion\n      // location, then append data to that Text node's data.\"\n\n\n      var lastChild = parent.lastChild;\n\n      if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {\n        lastChild.appendData(s);\n      } else {\n        parent._appendChild(parent.ownerDocument.createTextNode(s));\n      }\n    }\n  }\n\n  function createHTMLElt(doc, name, attrs) {\n    // Create the element this way, rather than with\n    // doc.createElement because createElement() does error\n    // checking on the element name that we need to avoid here.\n    var elt = html.createElement(doc, name, null);\n\n    if (attrs) {\n      for (var i = 0, n = attrs.length; i < n; i++) {\n        // Use the _ version to avoid testing the validity\n        // of the attribute name\n        elt._setAttribute(attrs[i][0], attrs[i][1]);\n      }\n    } // XXX\n    // If the element is a resettable form element,\n    // run its reset algorithm now\n    // XXX\n    // handle case where form-element-pointer is not null\n\n\n    return elt;\n  } // The in_table insertion mode turns on this flag, and that makes\n  // insertHTMLElement use the foster parenting algorithm for elements\n  // tags inside a table\n\n\n  var foster_parent_mode = false;\n\n  function insertHTMLElement(name, attrs) {\n    var elt = insertElement(function (doc) {\n      return createHTMLElt(doc, name, attrs);\n    }); // XXX\n    // If this is a form element, set its form attribute property here\n\n    if (isA(elt, formassociatedSet)) {\n      elt._form = form_element_pointer;\n    }\n\n    return elt;\n  } // Insert the element into the open element or foster parent it\n\n\n  function insertElement(eltFunc) {\n    var elt;\n\n    if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {\n      elt = fosterParent(eltFunc);\n    } else if (stack.top instanceof impl.HTMLTemplateElement) {\n      // \"If the adjusted insertion location is inside a template element,\n      // let it instead be inside the template element's template contents\"\n      elt = eltFunc(stack.top.content.ownerDocument);\n\n      stack.top.content._appendChild(elt);\n    } else {\n      elt = eltFunc(stack.top.ownerDocument);\n\n      stack.top._appendChild(elt);\n    }\n\n    stack.push(elt);\n    return elt;\n  }\n\n  function insertForeignElement(name, attrs, ns) {\n    return insertElement(function (doc) {\n      // We need to prevent createElementNS from trying to parse `name` as a\n      // `qname`, so use an internal Document#_createElementNS() interface.\n      var elt = doc._createElementNS(name, ns, null);\n\n      if (attrs) {\n        for (var i = 0, n = attrs.length; i < n; i++) {\n          var attr = attrs[i];\n          if (attr.length === 2) elt._setAttribute(attr[0], attr[1]);else {\n            elt._setAttributeNS(attr[2], attr[0], attr[1]);\n          }\n        }\n      }\n\n      return elt;\n    });\n  }\n\n  function lastElementOfType(type) {\n    for (var i = stack.elements.length - 1; i >= 0; i--) {\n      if (stack.elements[i] instanceof type) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function fosterParent(eltFunc) {\n    var parent,\n        before,\n        lastTable = -1,\n        lastTemplate = -1,\n        elt;\n    lastTable = lastElementOfType(impl.HTMLTableElement);\n    lastTemplate = lastElementOfType(impl.HTMLTemplateElement);\n\n    if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {\n      parent = stack.elements[lastTemplate];\n    } else if (lastTable >= 0) {\n      parent = stack.elements[lastTable].parentNode;\n\n      if (parent) {\n        before = stack.elements[lastTable];\n      } else {\n        parent = stack.elements[lastTable - 1];\n      }\n    }\n\n    if (!parent) parent = stack.elements[0]; // the `html` element.\n    // \"If the adjusted insertion location is inside a template element,\n    // let it instead be inside the template element's template contents\"\n\n    if (parent instanceof impl.HTMLTemplateElement) {\n      parent = parent.content;\n    } // Create element in the appropriate document.\n\n\n    elt = eltFunc(parent.ownerDocument);\n\n    if (elt.nodeType === Node.TEXT_NODE) {\n      var prev;\n      if (before) prev = before.previousSibling;else prev = parent.lastChild;\n\n      if (prev && prev.nodeType === Node.TEXT_NODE) {\n        prev.appendData(elt.data);\n        return elt;\n      }\n    }\n\n    if (before) parent.insertBefore(elt, before);else parent._appendChild(elt);\n    return elt;\n  }\n\n  function resetInsertionMode() {\n    var last = false;\n\n    for (var i = stack.elements.length - 1; i >= 0; i--) {\n      var node = stack.elements[i];\n\n      if (i === 0) {\n        last = true;\n\n        if (fragment) {\n          node = fragmentContext;\n        }\n      }\n\n      if (node.namespaceURI === NAMESPACE.HTML) {\n        var tag = node.localName;\n\n        switch (tag) {\n          case \"select\":\n            for (var j = i; j > 0;) {\n              var ancestor = stack.elements[--j];\n\n              if (ancestor instanceof impl.HTMLTemplateElement) {\n                break;\n              } else if (ancestor instanceof impl.HTMLTableElement) {\n                parser = in_select_in_table_mode;\n                return;\n              }\n            }\n\n            parser = in_select_mode;\n            return;\n\n          case \"tr\":\n            parser = in_row_mode;\n            return;\n\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n            parser = in_table_body_mode;\n            return;\n\n          case \"caption\":\n            parser = in_caption_mode;\n            return;\n\n          case \"colgroup\":\n            parser = in_column_group_mode;\n            return;\n\n          case \"table\":\n            parser = in_table_mode;\n            return;\n\n          case \"template\":\n            parser = templateInsertionModes[templateInsertionModes.length - 1];\n            return;\n\n          case \"body\":\n            parser = in_body_mode;\n            return;\n\n          case \"frameset\":\n            parser = in_frameset_mode;\n            return;\n\n          case \"html\":\n            if (head_element_pointer === null) {\n              parser = before_head_mode;\n            } else {\n              parser = after_head_mode;\n            }\n\n            return;\n\n          default:\n            if (!last) {\n              if (tag === \"head\") {\n                parser = in_head_mode;\n                return;\n              }\n\n              if (tag === \"td\" || tag === \"th\") {\n                parser = in_cell_mode;\n                return;\n              }\n            }\n\n        }\n      }\n\n      if (last) {\n        parser = in_body_mode;\n        return;\n      }\n    }\n  }\n\n  function parseRawText(name, attrs) {\n    insertHTMLElement(name, attrs);\n    tokenizer = rawtext_state;\n    originalInsertionMode = parser;\n    parser = text_mode;\n  }\n\n  function parseRCDATA(name, attrs) {\n    insertHTMLElement(name, attrs);\n    tokenizer = rcdata_state;\n    originalInsertionMode = parser;\n    parser = text_mode;\n  } // Make a copy of element i on the list of active formatting\n  // elements, using its original attributes, not current\n  // attributes (which may have been modified by a script)\n\n\n  function afeclone(doc, i) {\n    return {\n      elt: createHTMLElt(doc, afe.list[i].localName, afe.attrs[i]),\n      attrs: afe.attrs[i]\n    };\n  }\n\n  function afereconstruct() {\n    if (afe.list.length === 0) return;\n    var entry = afe.list[afe.list.length - 1]; // If the last is a marker , do nothing\n\n    if (entry === afe.MARKER) return; // Or if it is an open element, do nothing\n\n    if (stack.elements.lastIndexOf(entry) !== -1) return; // Loop backward through the list until we find a marker or an\n    // open element, and then move forward one from there.\n\n    for (var i = afe.list.length - 2; i >= 0; i--) {\n      entry = afe.list[i];\n      if (entry === afe.MARKER) break;\n      if (stack.elements.lastIndexOf(entry) !== -1) break;\n    } // Now loop forward, starting from the element after the current\n    // one, recreating formatting elements and pushing them back onto\n    // the list of open elements\n\n\n    for (i = i + 1; i < afe.list.length; i++) {\n      var newelt = insertElement(function (doc) {\n        return afeclone(doc, i).elt;\n      });\n      afe.list[i] = newelt;\n    }\n  } // Used by the adoptionAgency() function\n\n\n  var BOOKMARK = {\n    localName: \"BM\"\n  };\n\n  function adoptionAgency(tag) {\n    // If the current node is an HTML element whose tag name is subject,\n    // and the current node is not in the list of active formatting\n    // elements, then pop the current node off the stack of open\n    // elements and abort these steps.\n    if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {\n      stack.pop();\n      return true; // no more handling required\n    } // Let outer loop counter be zero.\n\n\n    var outer = 0; // Outer loop: If outer loop counter is greater than or\n    // equal to eight, then abort these steps.\n\n    while (outer < 8) {\n      // Increment outer loop counter by one.\n      outer++; // Let the formatting element be the last element in the list\n      // of active formatting elements that: is between the end of\n      // the list and the last scope marker in the list, if any, or\n      // the start of the list otherwise, and has the same tag name\n      // as the token.\n\n      var fmtelt = afe.findElementByTag(tag); // If there is no such node, then abort these steps and instead\n      // act as described in the \"any other end tag\" entry below.\n\n      if (!fmtelt) {\n        return false; // false means handle by the default case\n      } // Otherwise, if there is such a node, but that node is not in\n      // the stack of open elements, then this is a parse error;\n      // remove the element from the list, and abort these steps.\n\n\n      var index = stack.elements.lastIndexOf(fmtelt);\n\n      if (index === -1) {\n        afe.remove(fmtelt);\n        return true; // true means no more handling required\n      } // Otherwise, if there is such a node, and that node is also in\n      // the stack of open elements, but the element is not in scope,\n      // then this is a parse error; ignore the token, and abort\n      // these steps.\n\n\n      if (!stack.elementInScope(fmtelt)) {\n        return true;\n      } // Let the furthest block be the topmost node in the stack of\n      // open elements that is lower in the stack than the formatting\n      // element, and is an element in the special category. There\n      // might not be one.\n\n\n      var furthestblock = null,\n          furthestblockindex;\n\n      for (var i = index + 1; i < stack.elements.length; i++) {\n        if (isA(stack.elements[i], specialSet)) {\n          furthestblock = stack.elements[i];\n          furthestblockindex = i;\n          break;\n        }\n      } // If there is no furthest block, then the UA must skip the\n      // subsequent steps and instead just pop all the nodes from the\n      // bottom of the stack of open elements, from the current node\n      // up to and including the formatting element, and remove the\n      // formatting element from the list of active formatting\n      // elements.\n\n\n      if (!furthestblock) {\n        stack.popElement(fmtelt);\n        afe.remove(fmtelt);\n        return true;\n      } else {\n        // Let the common ancestor be the element immediately above\n        // the formatting element in the stack of open elements.\n        var ancestor = stack.elements[index - 1]; // Let a bookmark note the position of the formatting\n        // element in the list of active formatting elements\n        // relative to the elements on either side of it in the\n        // list.\n\n        afe.insertAfter(fmtelt, BOOKMARK); // Let node and last node be the furthest block.\n\n        var node = furthestblock;\n        var lastnode = furthestblock;\n        var nodeindex = furthestblockindex;\n        var nodeafeindex; // Let inner loop counter be zero.\n\n        var inner = 0;\n\n        while (true) {\n          // Increment inner loop counter by one.\n          inner++; // Let node be the element immediately above node in\n          // the stack of open elements, or if node is no longer\n          // in the stack of open elements (e.g. because it got\n          // removed by this algorithm), the element that was\n          // immediately above node in the stack of open elements\n          // before node was removed.\n\n          node = stack.elements[--nodeindex]; // If node is the formatting element, then go\n          // to the next step in the overall algorithm.\n\n          if (node === fmtelt) break; // If the inner loop counter is greater than three and node\n          // is in the list of active formatting elements, then remove\n          // node from the list of active formatting elements.\n\n          nodeafeindex = afe.indexOf(node);\n\n          if (inner > 3 && nodeafeindex !== -1) {\n            afe.remove(node);\n            nodeafeindex = -1;\n          } // If node is not in the list of active formatting\n          // elements, then remove node from the stack of open\n          // elements and then go back to the step labeled inner\n          // loop.\n\n\n          if (nodeafeindex === -1) {\n            stack.removeElement(node);\n            continue;\n          } // Create an element for the token for which the\n          // element node was created with common ancestor as\n          // the intended parent, replace the entry for node\n          // in the list of active formatting elements with an\n          // entry for the new element, replace the entry for\n          // node in the stack of open elements with an entry for\n          // the new element, and let node be the new element.\n\n\n          var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);\n          afe.replace(node, newelt.elt, newelt.attrs);\n          stack.elements[nodeindex] = newelt.elt;\n          node = newelt.elt; // If last node is the furthest block, then move the\n          // aforementioned bookmark to be immediately after the\n          // new node in the list of active formatting elements.\n\n          if (lastnode === furthestblock) {\n            afe.remove(BOOKMARK);\n            afe.insertAfter(newelt.elt, BOOKMARK);\n          } // Insert last node into node, first removing it from\n          // its previous parent node if any.\n\n\n          node._appendChild(lastnode); // Let last node be node.\n\n\n          lastnode = node;\n        } // If the common ancestor node is a table, tbody, tfoot,\n        // thead, or tr element, then, foster parent whatever last\n        // node ended up being in the previous step, first removing\n        // it from its previous parent node if any.\n\n\n        if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {\n          fosterParent(function () {\n            return lastnode;\n          });\n        } // Otherwise, append whatever last node ended up being in\n        // the previous step to the common ancestor node, first\n        // removing it from its previous parent node if any.\n        else if (ancestor instanceof impl.HTMLTemplateElement) {\n            ancestor.content._appendChild(lastnode);\n          } else {\n            ancestor._appendChild(lastnode);\n          } // Create an element for the token for which the\n        // formatting element was created, with furthest block\n        // as the intended parent.\n\n\n        var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt)); // Take all of the child nodes of the furthest block and\n        // append them to the element created in the last step.\n\n        while (furthestblock.hasChildNodes()) {\n          newelt2.elt._appendChild(furthestblock.firstChild);\n        } // Append that new element to the furthest block.\n\n\n        furthestblock._appendChild(newelt2.elt); // Remove the formatting element from the list of active\n        // formatting elements, and insert the new element into the\n        // list of active formatting elements at the position of\n        // the aforementioned bookmark.\n\n\n        afe.remove(fmtelt);\n        afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs); // Remove the formatting element from the stack of open\n        // elements, and insert the new element into the stack of\n        // open elements immediately below the position of the\n        // furthest block in that stack.\n\n        stack.removeElement(fmtelt);\n        var pos = stack.elements.lastIndexOf(furthestblock);\n        stack.elements.splice(pos + 1, 0, newelt2.elt);\n      }\n    }\n\n    return true;\n  } // We do this when we get /script in in_text_mode\n\n\n  function handleScriptEnd() {\n    // XXX:\n    // This is just a stub implementation right now and doesn't run scripts.\n    // Getting this method right involves the event loop, URL resolution\n    // script fetching etc. For now I just want to be able to parse\n    // documents and test the parser.\n    //var script = stack.top;\n    stack.pop();\n    parser = originalInsertionMode; //script._prepare();\n\n    return; // XXX: here is what this method is supposed to do\n    // Provide a stable state.\n    // Let script be the current node (which will be a script\n    // element).\n    // Pop the current node off the stack of open elements.\n    // Switch the insertion mode to the original insertion mode.\n    // Let the old insertion point have the same value as the current\n    // insertion point. Let the insertion point be just before the\n    // next input character.\n    // Increment the parser's script nesting level by one.\n    // Prepare the script. This might cause some script to execute,\n    // which might cause new characters to be inserted into the\n    // tokenizer, and might cause the tokenizer to output more tokens,\n    // resulting in a reentrant invocation of the parser.\n    // Decrement the parser's script nesting level by one. If the\n    // parser's script nesting level is zero, then set the parser\n    // pause flag to false.\n    // Let the insertion point have the value of the old insertion\n    // point. (In other words, restore the insertion point to its\n    // previous value. This value might be the \"undefined\" value.)\n    // At this stage, if there is a pending parsing-blocking script,\n    // then:\n    // If the script nesting level is not zero:\n    //   Set the parser pause flag to true, and abort the processing\n    //   of any nested invocations of the tokenizer, yielding\n    //   control back to the caller. (Tokenization will resume when\n    //   the caller returns to the \"outer\" tree construction stage.)\n    //   The tree construction stage of this particular parser is\n    //   being called reentrantly, say from a call to\n    //   document.write().\n    // Otherwise:\n    //     Run these steps:\n    //       Let the script be the pending parsing-blocking\n    //       script. There is no longer a pending\n    //       parsing-blocking script.\n    //       Block the tokenizer for this instance of the HTML\n    //       parser, such that the event loop will not run tasks\n    //       that invoke the tokenizer.\n    //       If the parser's Document has a style sheet that is\n    //       blocking scripts or the script's \"ready to be\n    //       parser-executed\" flag is not set: spin the event\n    //       loop until the parser's Document has no style sheet\n    //       that is blocking scripts and the script's \"ready to\n    //       be parser-executed\" flag is set.\n    //       Unblock the tokenizer for this instance of the HTML\n    //       parser, such that tasks that invoke the tokenizer\n    //       can again be run.\n    //       Let the insertion point be just before the next\n    //       input character.\n    //       Increment the parser's script nesting level by one\n    //       (it should be zero before this step, so this sets\n    //       it to one).\n    //       Execute the script.\n    //       Decrement the parser's script nesting level by\n    //       one. If the parser's script nesting level is zero\n    //       (which it always should be at this point), then set\n    //       the parser pause flag to false.\n    //       Let the insertion point be undefined again.\n    //       If there is once again a pending parsing-blocking\n    //       script, then repeat these steps from step 1.\n  }\n\n  function stopParsing() {\n    // XXX This is just a temporary implementation to get the parser working.\n    // A full implementation involves scripts and events and the event loop.\n    // Remove the link from document to parser.\n    // This is instead of \"set the insertion point to undefined\".\n    // It means that document.write() can't write into the doc anymore.\n    delete doc._parser;\n    stack.elements.length = 0; // pop everything off\n    // If there is a window object associated with the document\n    // then trigger an load event on it\n\n    if (doc.defaultView) {\n      doc.defaultView.dispatchEvent(new impl.Event(\"load\", {}));\n    }\n  }\n  /****\n   * Tokenizer states\n   */\n\n  /**\n   * This file was partially mechanically generated from\n   * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html\n   *\n   * After mechanical conversion, it was further converted from\n   * prose to JS by hand, but the intent is that it is a very\n   * faithful rendering of the HTML tokenization spec in\n   * JavaScript.\n   *\n   * It is not a goal of this tokenizer to detect or report\n   * parse errors.\n   *\n   * XXX The tokenizer is supposed to work with straight UTF32\n   * codepoints. But I don't think it has any dependencies on\n   * any character outside of the BMP so I think it is safe to\n   * pass it UTF16 characters. I don't think it will ever change\n   * state in the middle of a surrogate pair.\n   */\n\n  /*\n   * Each state is represented by a function.  For most states, the\n   * scanner simply passes the next character (as an integer\n   * codepoint) to the current state function and automatically\n   * consumes the character.  If the state function can't process\n   * the character it can call pushback() to push it back to the\n   * scanner.\n   *\n   * Some states require lookahead, though.  If a state function has\n   * a lookahead property, then it is invoked differently.  In this\n   * case, the scanner invokes the function with 3 arguments: 1) the\n   * next codepoint 2) a string of lookahead text 3) a boolean that\n   * is true if the lookahead goes all the way to the EOF. (XXX\n   * actually maybe this third is not necessary... the lookahead\n   * could just include \\uFFFF?)\n   *\n   * If the lookahead property of a state function is an integer, it\n   * specifies the number of characters required. If it is a string,\n   * then the scanner will scan for that string and return all\n   * characters up to and including that sequence, or up to EOF.  If\n   * the lookahead property is a regexp, then the scanner will match\n   * the regexp at the current point and return the matching string.\n   *\n   * States that require lookahead are responsible for explicitly\n   * consuming the characters they process. They do this by\n   * incrementing nextchar by the number of processed characters.\n   */\n\n\n  function reconsume(c, new_state) {\n    tokenizer = new_state;\n    nextchar--; // pushback\n  }\n\n  function data_state(c) {\n    switch (c) {\n      case 0x0026:\n        // AMPERSAND\n        return_state = data_state;\n        tokenizer = character_reference_state;\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        if (emitSimpleTag()) // Shortcut for <p>, <dl>, </div> etc.\n          break;\n        tokenizer = tag_open_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        // Usually null characters emitted by the tokenizer will be\n        // ignored by the tree builder, but sometimes they'll be\n        // converted to \\uFFFD.  I don't want to have the search every\n        // string emitted to replace NULs, so I'll set a flag\n        // if I've emitted a NUL.\n        textrun.push(c);\n        textIncludesNUL = true;\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        // Instead of just pushing a single character and then\n        // coming back to the very same place, lookahead and\n        // emit everything we can at once.\n\n        /*jshint -W030 */\n        emitCharsWhile(DATATEXT) || textrun.push(c);\n        break;\n    }\n  }\n\n  function rcdata_state(c) {\n    // Save the open tag so we can find a matching close tag\n    switch (c) {\n      case 0x0026:\n        // AMPERSAND\n        return_state = rcdata_state;\n        tokenizer = character_reference_state;\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = rcdata_less_than_sign_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        textIncludesNUL = true;\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function rawtext_state(c) {\n    switch (c) {\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = rawtext_less_than_sign_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        /*jshint -W030 */\n        emitCharsWhile(RAWTEXT) || textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_state(c) {\n    switch (c) {\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_less_than_sign_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        /*jshint -W030 */\n        emitCharsWhile(RAWTEXT) || textrun.push(c);\n        break;\n    }\n  }\n\n  function plaintext_state(c) {\n    switch (c) {\n      case 0x0000:\n        // NULL\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        /*jshint -W030 */\n        emitCharsWhile(PLAINTEXT) || textrun.push(c);\n        break;\n    }\n  }\n\n  function tag_open_state(c) {\n    switch (c) {\n      case 0x0021:\n        // EXCLAMATION MARK\n        tokenizer = markup_declaration_open_state;\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        tokenizer = end_tag_open_state;\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginTagName();\n        reconsume(c, tag_name_state);\n        break;\n\n      case 0x003F:\n        // QUESTION MARK\n        reconsume(c, bogus_comment_state);\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        reconsume(c, data_state);\n        break;\n    }\n  }\n\n  function end_tag_open_state(c) {\n    switch (c) {\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginEndTagName();\n        reconsume(c, tag_name_state);\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        break;\n\n      case -1:\n        // EOF\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        textrun.push(0x002F); // SOLIDUS\n\n        emitEOF();\n        break;\n\n      default:\n        reconsume(c, bogus_comment_state);\n        break;\n    }\n  }\n\n  function tag_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = before_attribute_name_state;\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        tokenizer = self_closing_start_tag_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitTag();\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tagnamebuf += String.fromCharCode(c + 0x0020);\n        break;\n\n      case 0x0000:\n        // NULL\n        tagnamebuf += String.fromCharCode(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        tagnamebuf += getMatchingChars(TAGNAME);\n        break;\n    }\n  }\n\n  function rcdata_less_than_sign_state(c) {\n    /* identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g */\n    if (c === 0x002F) {\n      // SOLIDUS\n      beginTempBuf();\n      tokenizer = rcdata_end_tag_open_state;\n    } else {\n      textrun.push(0x003C); // LESS-THAN SIGN\n\n      reconsume(c, rcdata_state);\n    }\n  }\n\n  function rcdata_end_tag_open_state(c) {\n    /* identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g */\n    switch (c) {\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginEndTagName();\n        reconsume(c, rcdata_end_tag_name_state);\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        textrun.push(0x002F); // SOLIDUS\n\n        reconsume(c, rcdata_state);\n        break;\n    }\n  }\n\n  function rcdata_end_tag_name_state(c) {\n    /* identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g */\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = before_attribute_name_state;\n          return;\n        }\n\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = self_closing_start_tag_state;\n          return;\n        }\n\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = data_state;\n          emitTag();\n          return;\n        }\n\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tagnamebuf += String.fromCharCode(c + 0x0020);\n        tempbuf.push(c);\n        return;\n\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        tagnamebuf += String.fromCharCode(c);\n        tempbuf.push(c);\n        return;\n\n      default:\n        break;\n    } // If we don't return in one of the cases above, then this was not\n    // an appropriately matching close tag, so back out by emitting all\n    // the characters as text\n\n\n    textrun.push(0x003C); // LESS-THAN SIGN\n\n    textrun.push(0x002F); // SOLIDUS\n\n    pushAll(textrun, tempbuf);\n    reconsume(c, rcdata_state);\n  }\n\n  function rawtext_less_than_sign_state(c) {\n    /* identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g\n     */\n    if (c === 0x002F) {\n      // SOLIDUS\n      beginTempBuf();\n      tokenizer = rawtext_end_tag_open_state;\n    } else {\n      textrun.push(0x003C); // LESS-THAN SIGN\n\n      reconsume(c, rawtext_state);\n    }\n  }\n\n  function rawtext_end_tag_open_state(c) {\n    /* identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g */\n    switch (c) {\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginEndTagName();\n        reconsume(c, rawtext_end_tag_name_state);\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        textrun.push(0x002F); // SOLIDUS\n\n        reconsume(c, rawtext_state);\n        break;\n    }\n  }\n\n  function rawtext_end_tag_name_state(c) {\n    /* identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g */\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = before_attribute_name_state;\n          return;\n        }\n\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = self_closing_start_tag_state;\n          return;\n        }\n\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = data_state;\n          emitTag();\n          return;\n        }\n\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tagnamebuf += String.fromCharCode(c + 0x0020);\n        tempbuf.push(c);\n        return;\n\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        tagnamebuf += String.fromCharCode(c);\n        tempbuf.push(c);\n        return;\n\n      default:\n        break;\n    } // If we don't return in one of the cases above, then this was not\n    // an appropriately matching close tag, so back out by emitting all\n    // the characters as text\n\n\n    textrun.push(0x003C); // LESS-THAN SIGN\n\n    textrun.push(0x002F); // SOLIDUS\n\n    pushAll(textrun, tempbuf);\n    reconsume(c, rawtext_state);\n  }\n\n  function script_data_less_than_sign_state(c) {\n    switch (c) {\n      case 0x002F:\n        // SOLIDUS\n        beginTempBuf();\n        tokenizer = script_data_end_tag_open_state;\n        break;\n\n      case 0x0021:\n        // EXCLAMATION MARK\n        tokenizer = script_data_escape_start_state;\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        textrun.push(0x0021); // EXCLAMATION MARK\n\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        reconsume(c, script_data_state);\n        break;\n    }\n  }\n\n  function script_data_end_tag_open_state(c) {\n    /* identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g */\n    switch (c) {\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginEndTagName();\n        reconsume(c, script_data_end_tag_name_state);\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        textrun.push(0x002F); // SOLIDUS\n\n        reconsume(c, script_data_state);\n        break;\n    }\n  }\n\n  function script_data_end_tag_name_state(c) {\n    /* identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g */\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = before_attribute_name_state;\n          return;\n        }\n\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = self_closing_start_tag_state;\n          return;\n        }\n\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = data_state;\n          emitTag();\n          return;\n        }\n\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tagnamebuf += String.fromCharCode(c + 0x0020);\n        tempbuf.push(c);\n        return;\n\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        tagnamebuf += String.fromCharCode(c);\n        tempbuf.push(c);\n        return;\n\n      default:\n        break;\n    } // If we don't return in one of the cases above, then this was not\n    // an appropriately matching close tag, so back out by emitting all\n    // the characters as text\n\n\n    textrun.push(0x003C); // LESS-THAN SIGN\n\n    textrun.push(0x002F); // SOLIDUS\n\n    pushAll(textrun, tempbuf);\n    reconsume(c, script_data_state);\n  }\n\n  function script_data_escape_start_state(c) {\n    if (c === 0x002D) {\n      // HYPHEN-MINUS\n      tokenizer = script_data_escape_start_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n    } else {\n      reconsume(c, script_data_state);\n    }\n  }\n\n  function script_data_escape_start_dash_state(c) {\n    if (c === 0x002D) {\n      // HYPHEN-MINUS\n      tokenizer = script_data_escaped_dash_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n    } else {\n      reconsume(c, script_data_state);\n    }\n  }\n\n  function script_data_escaped_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = script_data_escaped_dash_state;\n        textrun.push(0x002D); // HYPHEN-MINUS\n\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_escaped_less_than_sign_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_escaped_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = script_data_escaped_dash_dash_state;\n        textrun.push(0x002D); // HYPHEN-MINUS\n\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_escaped_less_than_sign_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        tokenizer = script_data_escaped_state;\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        tokenizer = script_data_escaped_state;\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_escaped_dash_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        textrun.push(0x002D); // HYPHEN-MINUS\n\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_escaped_less_than_sign_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = script_data_state;\n        textrun.push(0x003E); // GREATER-THAN SIGN\n\n        break;\n\n      case 0x0000:\n        // NULL\n        tokenizer = script_data_escaped_state;\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        tokenizer = script_data_escaped_state;\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_escaped_less_than_sign_state(c) {\n    switch (c) {\n      case 0x002F:\n        // SOLIDUS\n        beginTempBuf();\n        tokenizer = script_data_escaped_end_tag_open_state;\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginTempBuf();\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        reconsume(c, script_data_double_escape_start_state);\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        reconsume(c, script_data_escaped_state);\n        break;\n    }\n  }\n\n  function script_data_escaped_end_tag_open_state(c) {\n    switch (c) {\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        beginEndTagName();\n        reconsume(c, script_data_escaped_end_tag_name_state);\n        break;\n\n      default:\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        textrun.push(0x002F); // SOLIDUS\n\n        reconsume(c, script_data_escaped_state);\n        break;\n    }\n  }\n\n  function script_data_escaped_end_tag_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = before_attribute_name_state;\n          return;\n        }\n\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = self_closing_start_tag_state;\n          return;\n        }\n\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        if (appropriateEndTag(tagnamebuf)) {\n          tokenizer = data_state;\n          emitTag();\n          return;\n        }\n\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tagnamebuf += String.fromCharCode(c + 0x0020);\n        tempbuf.push(c);\n        return;\n\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        tagnamebuf += String.fromCharCode(c);\n        tempbuf.push(c);\n        return;\n\n      default:\n        break;\n    } // We get here in the default case, and if the closing tagname\n    // is not an appropriate tagname.\n\n\n    textrun.push(0x003C); // LESS-THAN SIGN\n\n    textrun.push(0x002F); // SOLIDUS\n\n    pushAll(textrun, tempbuf);\n    reconsume(c, script_data_escaped_state);\n  }\n\n  function script_data_double_escape_start_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020: // SPACE\n\n      case 0x002F: // SOLIDUS\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        if (buf2str(tempbuf) === \"script\") {\n          tokenizer = script_data_double_escaped_state;\n        } else {\n          tokenizer = script_data_escaped_state;\n        }\n\n        textrun.push(c);\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tempbuf.push(c + 0x0020);\n        textrun.push(c);\n        break;\n\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        tempbuf.push(c);\n        textrun.push(c);\n        break;\n\n      default:\n        reconsume(c, script_data_escaped_state);\n        break;\n    }\n  }\n\n  function script_data_double_escaped_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = script_data_double_escaped_dash_state;\n        textrun.push(0x002D); // HYPHEN-MINUS\n\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_double_escaped_less_than_sign_state;\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        break;\n\n      case 0x0000:\n        // NULL\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_double_escaped_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = script_data_double_escaped_dash_dash_state;\n        textrun.push(0x002D); // HYPHEN-MINUS\n\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_double_escaped_less_than_sign_state;\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        break;\n\n      case 0x0000:\n        // NULL\n        tokenizer = script_data_double_escaped_state;\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        tokenizer = script_data_double_escaped_state;\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_double_escaped_dash_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        textrun.push(0x002D); // HYPHEN-MINUS\n\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        tokenizer = script_data_double_escaped_less_than_sign_state;\n        textrun.push(0x003C); // LESS-THAN SIGN\n\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = script_data_state;\n        textrun.push(0x003E); // GREATER-THAN SIGN\n\n        break;\n\n      case 0x0000:\n        // NULL\n        tokenizer = script_data_double_escaped_state;\n        textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        tokenizer = script_data_double_escaped_state;\n        textrun.push(c);\n        break;\n    }\n  }\n\n  function script_data_double_escaped_less_than_sign_state(c) {\n    if (c === 0x002F) {\n      // SOLIDUS\n      beginTempBuf();\n      tokenizer = script_data_double_escape_end_state;\n      textrun.push(0x002F); // SOLIDUS\n    } else {\n      reconsume(c, script_data_double_escaped_state);\n    }\n  }\n\n  function script_data_double_escape_end_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020: // SPACE\n\n      case 0x002F: // SOLIDUS\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        if (buf2str(tempbuf) === \"script\") {\n          tokenizer = script_data_escaped_state;\n        } else {\n          tokenizer = script_data_double_escaped_state;\n        }\n\n        textrun.push(c);\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        tempbuf.push(c + 0x0020);\n        textrun.push(c);\n        break;\n\n      case 0x0061: // [a-z]\n\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n      case 0x0067:\n      case 0x0068:\n      case 0x0069:\n      case 0x006A:\n      case 0x006B:\n      case 0x006C:\n      case 0x006D:\n      case 0x006E:\n      case 0x006F:\n      case 0x0070:\n      case 0x0071:\n      case 0x0072:\n      case 0x0073:\n      case 0x0074:\n      case 0x0075:\n      case 0x0076:\n      case 0x0077:\n      case 0x0078:\n      case 0x0079:\n      case 0x007A:\n        tempbuf.push(c);\n        textrun.push(c);\n        break;\n\n      default:\n        reconsume(c, script_data_double_escaped_state);\n        break;\n    }\n  }\n\n  function before_attribute_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        break;\n      // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says \"reconsume in\n      // the after attribute name state\", but in our implementation that\n      // state always has an active attribute in attrnamebuf.  Just clone\n      // the rules here, without the addAttribute business.\n\n      case 0x002F:\n        // SOLIDUS\n        tokenizer = self_closing_start_tag_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitTag();\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      case 0x003D:\n        // EQUALS SIGN\n        beginAttrName();\n        attrnamebuf += String.fromCharCode(c);\n        tokenizer = attribute_name_state;\n        break;\n\n      default:\n        if (handleSimpleAttribute()) break;\n        beginAttrName();\n        reconsume(c, attribute_name_state);\n        break;\n    }\n  } // beginAttrName() must have been called before this point\n  // There is an active attribute in attrnamebuf (but not attrvaluebuf)\n\n\n  function attribute_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020: // SPACE\n\n      case 0x002F: // SOLIDUS\n\n      case 0x003E: // GREATER-THAN SIGN\n\n      case -1:\n        // EOF\n        reconsume(c, after_attribute_name_state);\n        break;\n\n      case 0x003D:\n        // EQUALS SIGN\n        tokenizer = before_attribute_value_state;\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        attrnamebuf += String.fromCharCode(c + 0x0020);\n        break;\n\n      case 0x0000:\n        // NULL\n        attrnamebuf += String.fromCharCode(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case 0x0022: // QUOTATION MARK\n\n      case 0x0027: // APOSTROPHE\n\n      case 0x003C: // LESS-THAN SIGN\n\n      /* falls through */\n\n      default:\n        attrnamebuf += getMatchingChars(ATTRNAME);\n        break;\n    }\n  } // There is an active attribute in attrnamebuf, but not yet in attrvaluebuf.\n\n\n  function after_attribute_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        // Keep in sync with before_attribute_name_state.\n        addAttribute(attrnamebuf);\n        tokenizer = self_closing_start_tag_state;\n        break;\n\n      case 0x003D:\n        // EQUALS SIGN\n        tokenizer = before_attribute_value_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        // Keep in sync with before_attribute_name_state.\n        tokenizer = data_state;\n        addAttribute(attrnamebuf);\n        emitTag();\n        break;\n\n      case -1:\n        // EOF\n        // Keep in sync with before_attribute_name_state.\n        addAttribute(attrnamebuf);\n        emitEOF();\n        break;\n\n      default:\n        addAttribute(attrnamebuf);\n        beginAttrName();\n        reconsume(c, attribute_name_state);\n        break;\n    }\n  }\n\n  function before_attribute_value_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginAttrValue();\n        tokenizer = attribute_value_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginAttrValue();\n        tokenizer = attribute_value_single_quoted_state;\n        break;\n\n      case 0x003E: // GREATER-THAN SIGN\n\n      /* falls through */\n\n      default:\n        beginAttrValue();\n        reconsume(c, attribute_value_unquoted_state);\n        break;\n    }\n  }\n\n  function attribute_value_double_quoted_state(c) {\n    switch (c) {\n      case 0x0022:\n        // QUOTATION MARK\n        addAttribute(attrnamebuf, attrvaluebuf);\n        tokenizer = after_attribute_value_quoted_state;\n        break;\n\n      case 0x0026:\n        // AMPERSAND\n        return_state = attribute_value_double_quoted_state;\n        tokenizer = character_reference_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        attrvaluebuf += String.fromCharCode(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      case 0x000A:\n        // LF\n        // this could be a converted \\r, so don't use getMatchingChars\n        attrvaluebuf += String.fromCharCode(c);\n        break;\n\n      default:\n        attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);\n        break;\n    }\n  }\n\n  function attribute_value_single_quoted_state(c) {\n    switch (c) {\n      case 0x0027:\n        // APOSTROPHE\n        addAttribute(attrnamebuf, attrvaluebuf);\n        tokenizer = after_attribute_value_quoted_state;\n        break;\n\n      case 0x0026:\n        // AMPERSAND\n        return_state = attribute_value_single_quoted_state;\n        tokenizer = character_reference_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        attrvaluebuf += String.fromCharCode(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      case 0x000A:\n        // LF\n        // this could be a converted \\r, so don't use getMatchingChars\n        attrvaluebuf += String.fromCharCode(c);\n        break;\n\n      default:\n        attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);\n        break;\n    }\n  }\n\n  function attribute_value_unquoted_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        addAttribute(attrnamebuf, attrvaluebuf);\n        tokenizer = before_attribute_name_state;\n        break;\n\n      case 0x0026:\n        // AMPERSAND\n        return_state = attribute_value_unquoted_state;\n        tokenizer = character_reference_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        addAttribute(attrnamebuf, attrvaluebuf);\n        tokenizer = data_state;\n        emitTag();\n        break;\n\n      case 0x0000:\n        // NULL\n        attrvaluebuf += String.fromCharCode(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case -1:\n        // EOF\n        nextchar--; // pushback\n\n        tokenizer = data_state;\n        break;\n\n      case 0x0022: // QUOTATION MARK\n\n      case 0x0027: // APOSTROPHE\n\n      case 0x003C: // LESS-THAN SIGN\n\n      case 0x003D: // EQUALS SIGN\n\n      case 0x0060: // GRAVE ACCENT\n\n      /* falls through */\n\n      default:\n        attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);\n        break;\n    }\n  }\n\n  function after_attribute_value_quoted_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = before_attribute_name_state;\n        break;\n\n      case 0x002F:\n        // SOLIDUS\n        tokenizer = self_closing_start_tag_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitTag();\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        reconsume(c, before_attribute_name_state);\n        break;\n    }\n  }\n\n  function self_closing_start_tag_state(c) {\n    switch (c) {\n      case 0x003E:\n        // GREATER-THAN SIGN\n        // Set the <i>self-closing flag</i> of the current tag token.\n        tokenizer = data_state;\n        emitSelfClosingTag(true);\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      default:\n        reconsume(c, before_attribute_name_state);\n        break;\n    }\n  }\n\n  function bogus_comment_state(c, lookahead, eof) {\n    var len = lookahead.length;\n\n    if (eof) {\n      nextchar += len - 1; // don't consume the eof\n    } else {\n      nextchar += len;\n    }\n\n    var comment = lookahead.substring(0, len - 1);\n    comment = comment.replace(/\\u0000/g, \"\\uFFFD\");\n    comment = comment.replace(/\\u000D\\u000A/g, \"\\u000A\");\n    comment = comment.replace(/\\u000D/g, \"\\u000A\");\n    insertToken(COMMENT, comment);\n    tokenizer = data_state;\n  }\n\n  bogus_comment_state.lookahead = \">\";\n\n  function markup_declaration_open_state(c, lookahead, eof) {\n    if (lookahead[0] === \"-\" && lookahead[1] === \"-\") {\n      nextchar += 2;\n      beginComment();\n      tokenizer = comment_start_state;\n      return;\n    }\n\n    if (lookahead.toUpperCase() === \"DOCTYPE\") {\n      nextchar += 7;\n      tokenizer = doctype_state;\n    } else if (lookahead === \"[CDATA[\" && cdataAllowed()) {\n      nextchar += 7;\n      tokenizer = cdata_section_state;\n    } else {\n      tokenizer = bogus_comment_state;\n    }\n  }\n\n  markup_declaration_open_state.lookahead = 7;\n\n  function comment_start_state(c) {\n    beginComment();\n\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = comment_start_dash_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        insertToken(COMMENT, buf2str(commentbuf));\n        break;\n\n      /* see comment in comment end state */\n\n      default:\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function comment_start_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = comment_end_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        insertToken(COMMENT, buf2str(commentbuf));\n        break;\n\n      case -1:\n        // EOF\n        insertToken(COMMENT, buf2str(commentbuf));\n        emitEOF();\n        break;\n\n      /* see comment in comment end state */\n\n      default:\n        commentbuf.push(0x002D\n        /* HYPHEN-MINUS */\n        );\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function comment_state(c) {\n    switch (c) {\n      case 0x003C:\n        // LESS-THAN SIGN\n        commentbuf.push(c);\n        tokenizer = comment_less_than_sign_state;\n        break;\n\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = comment_end_dash_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        commentbuf.push(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case -1:\n        // EOF\n        insertToken(COMMENT, buf2str(commentbuf));\n        emitEOF();\n        break;\n\n      /* see comment in comment end state */\n\n      default:\n        commentbuf.push(c);\n        break;\n    }\n  }\n\n  function comment_less_than_sign_state(c) {\n    switch (c) {\n      case 0x0021:\n        // EXCLAMATION MARK\n        commentbuf.push(c);\n        tokenizer = comment_less_than_sign_bang_state;\n        break;\n\n      case 0x003C:\n        // LESS-THAN SIGN\n        commentbuf.push(c);\n        break;\n\n      default:\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function comment_less_than_sign_bang_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = comment_less_than_sign_bang_dash_state;\n        break;\n\n      default:\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function comment_less_than_sign_bang_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = comment_less_than_sign_bang_dash_dash_state;\n        break;\n\n      default:\n        reconsume(c, comment_end_dash_state);\n        break;\n    }\n  }\n\n  function comment_less_than_sign_bang_dash_dash_state(c) {\n    switch (c) {\n      case 0x003E: // GREATER-THAN SIGN\n\n      case -1:\n        // EOF\n        reconsume(c, comment_end_state);\n        break;\n\n      default:\n        // parse error\n        reconsume(c, comment_end_state);\n        break;\n    }\n  }\n\n  function comment_end_dash_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        tokenizer = comment_end_state;\n        break;\n\n      case -1:\n        // EOF\n        insertToken(COMMENT, buf2str(commentbuf));\n        emitEOF();\n        break;\n\n      /* see comment in comment end state */\n\n      default:\n        commentbuf.push(0x002D\n        /* HYPHEN-MINUS */\n        );\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function comment_end_state(c) {\n    switch (c) {\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        insertToken(COMMENT, buf2str(commentbuf));\n        break;\n\n      case 0x0021:\n        // EXCLAMATION MARK\n        tokenizer = comment_end_bang_state;\n        break;\n\n      case 0x002D:\n        // HYPHEN-MINUS\n        commentbuf.push(0x002D);\n        break;\n\n      case -1:\n        // EOF\n        insertToken(COMMENT, buf2str(commentbuf));\n        emitEOF();\n        break;\n\n      /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */\n\n      default:\n        commentbuf.push(0x002D);\n        commentbuf.push(0x002D);\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function comment_end_bang_state(c) {\n    switch (c) {\n      case 0x002D:\n        // HYPHEN-MINUS\n        commentbuf.push(0x002D);\n        commentbuf.push(0x002D);\n        commentbuf.push(0x0021);\n        tokenizer = comment_end_dash_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        insertToken(COMMENT, buf2str(commentbuf));\n        break;\n\n      case -1:\n        // EOF\n        insertToken(COMMENT, buf2str(commentbuf));\n        emitEOF();\n        break;\n\n      /* see comment in comment end state */\n\n      default:\n        commentbuf.push(0x002D);\n        commentbuf.push(0x002D);\n        commentbuf.push(0x0021);\n        reconsume(c, comment_state);\n        break;\n    }\n  }\n\n  function doctype_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = before_doctype_name_state;\n        break;\n\n      case -1:\n        // EOF\n        beginDoctype();\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        reconsume(c, before_doctype_name_state);\n        break;\n    }\n  }\n\n  function before_doctype_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        beginDoctype();\n        doctypenamebuf.push(c + 0x0020);\n        tokenizer = doctype_name_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        beginDoctype();\n        doctypenamebuf.push(0xFFFD);\n        tokenizer = doctype_name_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        beginDoctype();\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        beginDoctype();\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        beginDoctype();\n        doctypenamebuf.push(c);\n        tokenizer = doctype_name_state;\n        break;\n    }\n  }\n\n  function doctype_name_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = after_doctype_name_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case 0x0041: // [A-Z]\n\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n      case 0x0047:\n      case 0x0048:\n      case 0x0049:\n      case 0x004A:\n      case 0x004B:\n      case 0x004C:\n      case 0x004D:\n      case 0x004E:\n      case 0x004F:\n      case 0x0050:\n      case 0x0051:\n      case 0x0052:\n      case 0x0053:\n      case 0x0054:\n      case 0x0055:\n      case 0x0056:\n      case 0x0057:\n      case 0x0058:\n      case 0x0059:\n      case 0x005A:\n        doctypenamebuf.push(c + 0x0020);\n        break;\n\n      case 0x0000:\n        // NULL\n        doctypenamebuf.push(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        doctypenamebuf.push(c);\n        break;\n    }\n  }\n\n  function after_doctype_name_state(c, lookahead, eof) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        nextchar += 1;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        nextchar += 1;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        lookahead = lookahead.toUpperCase();\n\n        if (lookahead === \"PUBLIC\") {\n          nextchar += 6;\n          tokenizer = after_doctype_public_keyword_state;\n        } else if (lookahead === \"SYSTEM\") {\n          nextchar += 6;\n          tokenizer = after_doctype_system_keyword_state;\n        } else {\n          forcequirks();\n          tokenizer = bogus_doctype_state;\n        }\n\n        break;\n    }\n  }\n\n  after_doctype_name_state.lookahead = 6;\n\n  function after_doctype_public_keyword_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = before_doctype_public_identifier_state;\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginDoctypePublicId();\n        tokenizer = doctype_public_identifier_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginDoctypePublicId();\n        tokenizer = doctype_public_identifier_single_quoted_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n        break;\n    }\n  }\n\n  function before_doctype_public_identifier_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginDoctypePublicId();\n        tokenizer = doctype_public_identifier_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginDoctypePublicId();\n        tokenizer = doctype_public_identifier_single_quoted_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n        break;\n    }\n  }\n\n  function doctype_public_identifier_double_quoted_state(c) {\n    switch (c) {\n      case 0x0022:\n        // QUOTATION MARK\n        tokenizer = after_doctype_public_identifier_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        doctypepublicbuf.push(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        doctypepublicbuf.push(c);\n        break;\n    }\n  }\n\n  function doctype_public_identifier_single_quoted_state(c) {\n    switch (c) {\n      case 0x0027:\n        // APOSTROPHE\n        tokenizer = after_doctype_public_identifier_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        doctypepublicbuf.push(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        doctypepublicbuf.push(c);\n        break;\n    }\n  }\n\n  function after_doctype_public_identifier_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = between_doctype_public_and_system_identifiers_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_single_quoted_state;\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n        break;\n    }\n  }\n\n  function between_doctype_public_and_system_identifiers_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE Ignore the character.\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_single_quoted_state;\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n        break;\n    }\n  }\n\n  function after_doctype_system_keyword_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n        tokenizer = before_doctype_system_identifier_state;\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_single_quoted_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n        break;\n    }\n  }\n\n  function before_doctype_system_identifier_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE Ignore the character.\n        break;\n\n      case 0x0022:\n        // QUOTATION MARK\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_double_quoted_state;\n        break;\n\n      case 0x0027:\n        // APOSTROPHE\n        beginDoctypeSystemId();\n        tokenizer = doctype_system_identifier_single_quoted_state;\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n        break;\n    }\n  }\n\n  function doctype_system_identifier_double_quoted_state(c) {\n    switch (c) {\n      case 0x0022:\n        // QUOTATION MARK\n        tokenizer = after_doctype_system_identifier_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        doctypesystembuf.push(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        doctypesystembuf.push(c);\n        break;\n    }\n  }\n\n  function doctype_system_identifier_single_quoted_state(c) {\n    switch (c) {\n      case 0x0027:\n        // APOSTROPHE\n        tokenizer = after_doctype_system_identifier_state;\n        break;\n\n      case 0x0000:\n        // NULL\n        doctypesystembuf.push(0xFFFD\n        /* REPLACEMENT CHARACTER */\n        );\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        forcequirks();\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        doctypesystembuf.push(c);\n        break;\n    }\n  }\n\n  function after_doctype_system_identifier_state(c) {\n    switch (c) {\n      case 0x0009: // CHARACTER TABULATION (tab)\n\n      case 0x000A: // LINE FEED (LF)\n\n      case 0x000C: // FORM FEED (FF)\n\n      case 0x0020:\n        // SPACE\n\n        /* Ignore the character. */\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        forcequirks();\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        tokenizer = bogus_doctype_state;\n        /* This does *not* set the DOCTYPE token's force-quirks flag. */\n\n        break;\n    }\n  }\n\n  function bogus_doctype_state(c) {\n    switch (c) {\n      case 0x003E:\n        // GREATER-THAN SIGN\n        tokenizer = data_state;\n        emitDoctype();\n        break;\n\n      case -1:\n        // EOF\n        emitDoctype();\n        emitEOF();\n        break;\n\n      default:\n        /* Ignore the character. */\n        break;\n    }\n  }\n\n  function cdata_section_state(c) {\n    switch (c) {\n      case 0x005D:\n        // RIGHT SQUARE BRACKET\n        tokenizer = cdata_section_bracket_state;\n        break;\n\n      case -1:\n        // EOF\n        emitEOF();\n        break;\n\n      case 0x0000:\n        // NULL\n        textIncludesNUL = true;\n\n      /* fall through */\n\n      default:\n        // Instead of just pushing a single character and then\n        // coming back to the very same place, lookahead and\n        // emit everything we can at once.\n\n        /*jshint -W030 */\n        emitCharsWhile(CDATATEXT) || textrun.push(c);\n        break;\n    }\n  }\n\n  function cdata_section_bracket_state(c) {\n    switch (c) {\n      case 0x005D:\n        // RIGHT SQUARE BRACKET\n        tokenizer = cdata_section_end_state;\n        break;\n\n      default:\n        textrun.push(0x005D);\n        reconsume(c, cdata_section_state);\n        break;\n    }\n  }\n\n  function cdata_section_end_state(c) {\n    switch (c) {\n      case 0x005D:\n        // RIGHT SQUARE BRACKET\n        textrun.push(0x005D);\n        break;\n\n      case 0x003E:\n        // GREATER-THAN SIGN\n        flushText();\n        tokenizer = data_state;\n        break;\n\n      default:\n        textrun.push(0x005D);\n        textrun.push(0x005D);\n        reconsume(c, cdata_section_state);\n        break;\n    }\n  }\n\n  function character_reference_state(c) {\n    beginTempBuf();\n    tempbuf.push(0x0026);\n\n    switch (c) {\n      case 0x0009: // TAB\n\n      case 0x000A: // LINE FEED\n\n      case 0x000C: // FORM FEED\n\n      case 0x0020: // SPACE\n\n      case 0x003C: // LESS-THAN SIGN\n\n      case 0x0026: // AMPERSAND\n\n      case -1:\n        // EOF\n        reconsume(c, character_reference_end_state);\n        break;\n\n      case 0x0023:\n        // NUMBER SIGN\n        tempbuf.push(c);\n        tokenizer = numeric_character_reference_state;\n        break;\n\n      default:\n        reconsume(c, named_character_reference_state);\n        break;\n    }\n  }\n\n  function named_character_reference_state(c) {\n    NAMEDCHARREF.lastIndex = nextchar; // w/ lookahead no char has been consumed\n\n    var matched = NAMEDCHARREF.exec(chars);\n    if (!matched) throw new Error(\"should never happen\");\n    var name = matched[1];\n\n    if (!name) {\n      // If no match can be made, switch to the character reference end state\n      tokenizer = character_reference_end_state;\n      return;\n    } // Consume the matched characters and append them to temporary buffer\n\n\n    nextchar += name.length;\n    pushAll(tempbuf, str2buf(name));\n\n    switch (return_state) {\n      case attribute_value_double_quoted_state:\n      case attribute_value_single_quoted_state:\n      case attribute_value_unquoted_state:\n        // If the character reference was consumed as part of an attribute...\n        if (name[name.length - 1] !== ';') {\n          // ...and the last char is not ;\n          if (/[=A-Za-z0-9]/.test(chars[nextchar])) {\n            tokenizer = character_reference_end_state;\n            return;\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    beginTempBuf();\n    var rv = namedCharRefs[name];\n\n    if (typeof rv === 'number') {\n      tempbuf.push(rv);\n    } else {\n      pushAll(tempbuf, rv);\n    }\n\n    tokenizer = character_reference_end_state;\n  } // We might need to pause tokenization until we have enough characters\n  // in the buffer for longest possible character reference.\n\n\n  named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;\n\n  function numeric_character_reference_state(c) {\n    character_reference_code = 0;\n\n    switch (c) {\n      case 0x0078: // x\n\n      case 0x0058:\n        // X\n        tempbuf.push(c);\n        tokenizer = hexadecimal_character_reference_start_state;\n        break;\n\n      default:\n        reconsume(c, decimal_character_reference_start_state);\n        break;\n    }\n  }\n\n  function hexadecimal_character_reference_start_state(c) {\n    switch (c) {\n      case 0x0030:\n      case 0x0031:\n      case 0x0032:\n      case 0x0033:\n      case 0x0034:\n      case 0x0035:\n      case 0x0036:\n      case 0x0037:\n      case 0x0038:\n      case 0x0039: // [0-9]\n\n      case 0x0041:\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046: // [A-F]\n\n      case 0x0061:\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n        // [a-f]\n        reconsume(c, hexadecimal_character_reference_state);\n        break;\n\n      default:\n        reconsume(c, character_reference_end_state);\n        break;\n    }\n  }\n\n  function decimal_character_reference_start_state(c) {\n    switch (c) {\n      case 0x0030:\n      case 0x0031:\n      case 0x0032:\n      case 0x0033:\n      case 0x0034:\n      case 0x0035:\n      case 0x0036:\n      case 0x0037:\n      case 0x0038:\n      case 0x0039:\n        // [0-9]\n        reconsume(c, decimal_character_reference_state);\n        break;\n\n      default:\n        reconsume(c, character_reference_end_state);\n        break;\n    }\n  }\n\n  function hexadecimal_character_reference_state(c) {\n    switch (c) {\n      case 0x0041:\n      case 0x0042:\n      case 0x0043:\n      case 0x0044:\n      case 0x0045:\n      case 0x0046:\n        // [A-F]\n        character_reference_code *= 16;\n        character_reference_code += c - 0x0037;\n        break;\n\n      case 0x0061:\n      case 0x0062:\n      case 0x0063:\n      case 0x0064:\n      case 0x0065:\n      case 0x0066:\n        // [a-f]\n        character_reference_code *= 16;\n        character_reference_code += c - 0x0057;\n        break;\n\n      case 0x0030:\n      case 0x0031:\n      case 0x0032:\n      case 0x0033:\n      case 0x0034:\n      case 0x0035:\n      case 0x0036:\n      case 0x0037:\n      case 0x0038:\n      case 0x0039:\n        // [0-9]\n        character_reference_code *= 16;\n        character_reference_code += c - 0x0030;\n        break;\n\n      case 0x003B:\n        // SEMICOLON\n        tokenizer = numeric_character_reference_end_state;\n        break;\n\n      default:\n        reconsume(c, numeric_character_reference_end_state);\n        break;\n    }\n  }\n\n  function decimal_character_reference_state(c) {\n    switch (c) {\n      case 0x0030:\n      case 0x0031:\n      case 0x0032:\n      case 0x0033:\n      case 0x0034:\n      case 0x0035:\n      case 0x0036:\n      case 0x0037:\n      case 0x0038:\n      case 0x0039:\n        // [0-9]\n        character_reference_code *= 10;\n        character_reference_code += c - 0x0030;\n        break;\n\n      case 0x003B:\n        // SEMICOLON\n        tokenizer = numeric_character_reference_end_state;\n        break;\n\n      default:\n        reconsume(c, numeric_character_reference_end_state);\n        break;\n    }\n  }\n\n  function numeric_character_reference_end_state(c) {\n    if (character_reference_code in numericCharRefReplacements) {\n      character_reference_code = numericCharRefReplacements[character_reference_code];\n    } else if (character_reference_code > 0x10FFFF || character_reference_code >= 0xD800 && character_reference_code < 0xE000) {\n      character_reference_code = 0xFFFD;\n    }\n\n    beginTempBuf();\n\n    if (character_reference_code <= 0xFFFF) {\n      tempbuf.push(character_reference_code);\n    } else {\n      character_reference_code = character_reference_code - 0x10000;\n      /* jshint bitwise: false */\n\n      tempbuf.push(0xD800 + (character_reference_code >> 10));\n      tempbuf.push(0xDC00 + (character_reference_code & 0x03FF));\n    }\n\n    reconsume(c, character_reference_end_state);\n  }\n\n  function character_reference_end_state(c) {\n    switch (return_state) {\n      case attribute_value_double_quoted_state:\n      case attribute_value_single_quoted_state:\n      case attribute_value_unquoted_state:\n        // append each character to the current attribute's value\n        attrvaluebuf += buf2str(tempbuf);\n        break;\n\n      default:\n        pushAll(textrun, tempbuf);\n        break;\n    }\n\n    reconsume(c, return_state);\n  }\n  /***\n   * The tree builder insertion modes\n   */\n  // 11.2.5.4.1 The \"initial\" insertion mode\n\n\n  function initial_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        value = value.replace(LEADINGWS, \"\"); // Ignore spaces\n\n        if (value.length === 0) return; // Are we done?\n\n        break;\n      // Handle anything non-space text below\n\n      case 4:\n        // COMMENT\n        doc._appendChild(doc.createComment(value));\n\n        return;\n\n      case 5:\n        // DOCTYPE\n        var name = value;\n        var publicid = arg3;\n        var systemid = arg4; // Use the constructor directly instead of\n        // implementation.createDocumentType because the create\n        // function throws errors on invalid characters, and\n        // we don't want the parser to throw them.\n\n        doc.appendChild(new DocumentType(doc, name, publicid, systemid)); // Note that there is no public API for setting quirks mode We can\n        // do this here because we have access to implementation details\n\n        if (force_quirks || name.toLowerCase() !== \"html\" || quirkyPublicIds.test(publicid) || systemid && systemid.toLowerCase() === quirkySystemId || systemid === undefined && conditionallyQuirkyPublicIds.test(publicid)) doc._quirks = true;else if (limitedQuirkyPublicIds.test(publicid) || systemid !== undefined && conditionallyQuirkyPublicIds.test(publicid)) doc._limitedQuirks = true;\n        parser = before_html_mode;\n        return;\n    } // tags or non-whitespace text\n\n\n    doc._quirks = true;\n    parser = before_html_mode;\n    parser(t, value, arg3, arg4);\n  } // 11.2.5.4.2 The \"before html\" insertion mode\n\n\n  function before_html_mode(t, value, arg3, arg4) {\n    var elt;\n\n    switch (t) {\n      case 1:\n        // TEXT\n        value = value.replace(LEADINGWS, \"\"); // Ignore spaces\n\n        if (value.length === 0) return; // Are we done?\n\n        break;\n      // Handle anything non-space text below\n\n      case 5:\n        // DOCTYPE\n\n        /* ignore the token */\n        return;\n\n      case 4:\n        // COMMENT\n        doc._appendChild(doc.createComment(value));\n\n        return;\n\n      case 2:\n        // TAG\n        if (value === \"html\") {\n          elt = createHTMLElt(doc, value, arg3);\n          stack.push(elt);\n          doc.appendChild(elt); // XXX: handle application cache here\n\n          parser = before_head_mode;\n          return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"html\":\n          case \"head\":\n          case \"body\":\n          case \"br\":\n            break;\n          // fall through on these\n\n          default:\n            return;\n          // ignore most end tags\n        }\n\n    } // Anything that didn't get handled above is handled like this:\n\n\n    elt = createHTMLElt(doc, \"html\", null);\n    stack.push(elt);\n    doc.appendChild(elt); // XXX: handle application cache here\n\n    parser = before_head_mode;\n    parser(t, value, arg3, arg4);\n  } // 11.2.5.4.3 The \"before head\" insertion mode\n\n\n  function before_head_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        value = value.replace(LEADINGWS, \"\"); // Ignore spaces\n\n        if (value.length === 0) return; // Are we done?\n\n        break;\n      // Handle anything non-space text below\n\n      case 5:\n        // DOCTYPE\n\n        /* ignore the token */\n        return;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"head\":\n            var elt = insertHTMLElement(value, arg3);\n            head_element_pointer = elt;\n            parser = in_head_mode;\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"html\":\n          case \"head\":\n          case \"body\":\n          case \"br\":\n            break;\n\n          default:\n            return;\n          // ignore most end tags\n        }\n\n    } // If not handled explicitly above\n\n\n    before_head_mode(TAG, \"head\", null); // create a head tag\n\n    parser(t, value, arg3, arg4); // then try again with this token\n  }\n\n  function in_head_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        var ws = value.match(LEADINGWS);\n\n        if (ws) {\n          insertText(ws[0]);\n          value = value.substring(ws[0].length);\n        }\n\n        if (value.length === 0) return;\n        break;\n      // Handle non-whitespace below\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"meta\": // XXX:\n          // May need to change the encoding based on this tag\n\n          /* falls through */\n\n          case \"base\":\n          case \"basefont\":\n          case \"bgsound\":\n          case \"link\":\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            return;\n\n          case \"title\":\n            parseRCDATA(value, arg3);\n            return;\n\n          case \"noscript\":\n            if (!scripting_enabled) {\n              insertHTMLElement(value, arg3);\n              parser = in_head_noscript_mode;\n              return;\n            }\n\n          // Otherwise, if scripting is enabled...\n\n          /* falls through */\n\n          case \"noframes\":\n          case \"style\":\n            parseRawText(value, arg3);\n            return;\n\n          case \"script\":\n            insertElement(function (doc) {\n              var elt = createHTMLElt(doc, value, arg3);\n              elt._parser_inserted = true;\n              elt._force_async = false;\n              if (fragment) elt._already_started = true;\n              flushText();\n              return elt;\n            });\n            tokenizer = script_data_state;\n            originalInsertionMode = parser;\n            parser = text_mode;\n            return;\n\n          case \"template\":\n            insertHTMLElement(value, arg3);\n            afe.insertMarker();\n            frameset_ok = false;\n            parser = in_template_mode;\n            templateInsertionModes.push(parser);\n            return;\n\n          case \"head\":\n            return;\n          // ignore it\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"head\":\n            stack.pop();\n            parser = after_head_mode;\n            return;\n\n          case \"body\":\n          case \"html\":\n          case \"br\":\n            break;\n          // handle these at the bottom of the function\n\n          case \"template\":\n            if (!stack.contains(\"template\")) {\n              return;\n            }\n\n            stack.generateImpliedEndTags(null, \"thorough\");\n            stack.popTag(\"template\");\n            afe.clearToMarker();\n            templateInsertionModes.pop();\n            resetInsertionMode();\n            return;\n\n          default:\n            // ignore any other end tag\n            return;\n        }\n\n        break;\n    } // If not handled above\n\n\n    in_head_mode(ENDTAG, \"head\", null); // synthetic </head>\n\n    parser(t, value, arg3, arg4); // Then redo this one\n  } // 13.2.5.4.5 The \"in head noscript\" insertion mode\n\n\n  function in_head_noscript_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 5:\n        // DOCTYPE\n        return;\n\n      case 4:\n        // COMMENT\n        in_head_mode(t, value);\n        return;\n\n      case 1:\n        // TEXT\n        var ws = value.match(LEADINGWS);\n\n        if (ws) {\n          in_head_mode(t, ws[0]);\n          value = value.substring(ws[0].length);\n        }\n\n        if (value.length === 0) return; // no more text\n\n        break;\n      // Handle non-whitespace below\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"basefont\":\n          case \"bgsound\":\n          case \"link\":\n          case \"meta\":\n          case \"noframes\":\n          case \"style\":\n            in_head_mode(t, value, arg3);\n            return;\n\n          case \"head\":\n          case \"noscript\":\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"noscript\":\n            stack.pop();\n            parser = in_head_mode;\n            return;\n\n          case \"br\":\n            break;\n          // goes to the outer default\n\n          default:\n            return;\n          // ignore other end tags\n        }\n\n        break;\n    } // If not handled above\n\n\n    in_head_noscript_mode(ENDTAG, \"noscript\", null);\n    parser(t, value, arg3, arg4);\n  }\n\n  function after_head_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        var ws = value.match(LEADINGWS);\n\n        if (ws) {\n          insertText(ws[0]);\n          value = value.substring(ws[0].length);\n        }\n\n        if (value.length === 0) return;\n        break;\n      // Handle non-whitespace below\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"body\":\n            insertHTMLElement(value, arg3);\n            frameset_ok = false;\n            parser = in_body_mode;\n            return;\n\n          case \"frameset\":\n            insertHTMLElement(value, arg3);\n            parser = in_frameset_mode;\n            return;\n\n          case \"base\":\n          case \"basefont\":\n          case \"bgsound\":\n          case \"link\":\n          case \"meta\":\n          case \"noframes\":\n          case \"script\":\n          case \"style\":\n          case \"template\":\n          case \"title\":\n            stack.push(head_element_pointer);\n            in_head_mode(TAG, value, arg3);\n            stack.removeElement(head_element_pointer);\n            return;\n\n          case \"head\":\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"template\":\n            return in_head_mode(t, value, arg3, arg4);\n\n          case \"body\":\n          case \"html\":\n          case \"br\":\n            break;\n\n          default:\n            return;\n          // ignore any other end tag\n        }\n\n        break;\n    }\n\n    after_head_mode(TAG, \"body\", null);\n    frameset_ok = true;\n    parser(t, value, arg3, arg4);\n  } // 13.2.5.4.7 The \"in body\" insertion mode\n\n\n  function in_body_mode(t, value, arg3, arg4) {\n    var body, i, node, elt;\n\n    switch (t) {\n      case 1:\n        // TEXT\n        if (textIncludesNUL) {\n          value = value.replace(NULCHARS, \"\");\n          if (value.length === 0) return;\n        } // If any non-space characters\n\n\n        if (frameset_ok && NONWS.test(value)) frameset_ok = false;\n        afereconstruct();\n        insertText(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case -1:\n        // EOF\n        if (templateInsertionModes.length) {\n          return in_template_mode(t);\n        }\n\n        stopParsing();\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            if (stack.contains(\"template\")) {\n              return;\n            }\n\n            transferAttributes(arg3, stack.elements[0]);\n            return;\n\n          case \"base\":\n          case \"basefont\":\n          case \"bgsound\":\n          case \"link\":\n          case \"meta\":\n          case \"noframes\":\n          case \"script\":\n          case \"style\":\n          case \"template\":\n          case \"title\":\n            in_head_mode(TAG, value, arg3);\n            return;\n\n          case \"body\":\n            body = stack.elements[1];\n            if (!body || !(body instanceof impl.HTMLBodyElement) || stack.contains(\"template\")) return;\n            frameset_ok = false;\n            transferAttributes(arg3, body);\n            return;\n\n          case \"frameset\":\n            if (!frameset_ok) return;\n            body = stack.elements[1];\n            if (!body || !(body instanceof impl.HTMLBodyElement)) return;\n            if (body.parentNode) body.parentNode.removeChild(body);\n\n            while (!(stack.top instanceof impl.HTMLHtmlElement)) stack.pop();\n\n            insertHTMLElement(value, arg3);\n            parser = in_frameset_mode;\n            return;\n\n          case \"address\":\n          case \"article\":\n          case \"aside\":\n          case \"blockquote\":\n          case \"center\":\n          case \"details\":\n          case \"dialog\":\n          case \"dir\":\n          case \"div\":\n          case \"dl\":\n          case \"fieldset\":\n          case \"figcaption\":\n          case \"figure\":\n          case \"footer\":\n          case \"header\":\n          case \"hgroup\":\n          case \"main\":\n          case \"nav\":\n          case \"ol\":\n          case \"p\":\n          case \"section\":\n          case \"summary\":\n          case \"ul\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"menu\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n\n            if (isA(stack.top, 'menuitem')) {\n              stack.pop();\n            }\n\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"h1\":\n          case \"h2\":\n          case \"h3\":\n          case \"h4\":\n          case \"h5\":\n          case \"h6\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            if (stack.top instanceof impl.HTMLHeadingElement) stack.pop();\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"pre\":\n          case \"listing\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            insertHTMLElement(value, arg3);\n            ignore_linefeed = true;\n            frameset_ok = false;\n            return;\n\n          case \"form\":\n            if (form_element_pointer && !stack.contains(\"template\")) return;\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            elt = insertHTMLElement(value, arg3);\n            if (!stack.contains(\"template\")) form_element_pointer = elt;\n            return;\n\n          case \"li\":\n            frameset_ok = false;\n\n            for (i = stack.elements.length - 1; i >= 0; i--) {\n              node = stack.elements[i];\n\n              if (node instanceof impl.HTMLLIElement) {\n                in_body_mode(ENDTAG, \"li\");\n                break;\n              }\n\n              if (isA(node, specialSet) && !isA(node, addressdivpSet)) break;\n            }\n\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"dd\":\n          case \"dt\":\n            frameset_ok = false;\n\n            for (i = stack.elements.length - 1; i >= 0; i--) {\n              node = stack.elements[i];\n\n              if (isA(node, dddtSet)) {\n                in_body_mode(ENDTAG, node.localName);\n                break;\n              }\n\n              if (isA(node, specialSet) && !isA(node, addressdivpSet)) break;\n            }\n\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"plaintext\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            insertHTMLElement(value, arg3);\n            tokenizer = plaintext_state;\n            return;\n\n          case \"button\":\n            if (stack.inScope(\"button\")) {\n              in_body_mode(ENDTAG, \"button\");\n              parser(t, value, arg3, arg4);\n            } else {\n              afereconstruct();\n              insertHTMLElement(value, arg3);\n              frameset_ok = false;\n            }\n\n            return;\n\n          case \"a\":\n            var activeElement = afe.findElementByTag(\"a\");\n\n            if (activeElement) {\n              in_body_mode(ENDTAG, value);\n              afe.remove(activeElement);\n              stack.removeElement(activeElement);\n            }\n\n          /* falls through */\n\n          case \"b\":\n          case \"big\":\n          case \"code\":\n          case \"em\":\n          case \"font\":\n          case \"i\":\n          case \"s\":\n          case \"small\":\n          case \"strike\":\n          case \"strong\":\n          case \"tt\":\n          case \"u\":\n            afereconstruct();\n            afe.push(insertHTMLElement(value, arg3), arg3);\n            return;\n\n          case \"nobr\":\n            afereconstruct();\n\n            if (stack.inScope(value)) {\n              in_body_mode(ENDTAG, value);\n              afereconstruct();\n            }\n\n            afe.push(insertHTMLElement(value, arg3), arg3);\n            return;\n\n          case \"applet\":\n          case \"marquee\":\n          case \"object\":\n            afereconstruct();\n            insertHTMLElement(value, arg3);\n            afe.insertMarker();\n            frameset_ok = false;\n            return;\n\n          case \"table\":\n            if (!doc._quirks && stack.inButtonScope(\"p\")) {\n              in_body_mode(ENDTAG, \"p\");\n            }\n\n            insertHTMLElement(value, arg3);\n            frameset_ok = false;\n            parser = in_table_mode;\n            return;\n\n          case \"area\":\n          case \"br\":\n          case \"embed\":\n          case \"img\":\n          case \"keygen\":\n          case \"wbr\":\n            afereconstruct();\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            frameset_ok = false;\n            return;\n\n          case \"input\":\n            afereconstruct();\n            elt = insertHTMLElement(value, arg3);\n            stack.pop();\n            var type = elt.getAttribute(\"type\");\n            if (!type || type.toLowerCase() !== \"hidden\") frameset_ok = false;\n            return;\n\n          case \"param\":\n          case \"source\":\n          case \"track\":\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            return;\n\n          case \"hr\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n\n            if (isA(stack.top, 'menuitem')) {\n              stack.pop();\n            }\n\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            frameset_ok = false;\n            return;\n\n          case \"image\":\n            in_body_mode(TAG, \"img\", arg3, arg4);\n            return;\n\n          case \"textarea\":\n            insertHTMLElement(value, arg3);\n            ignore_linefeed = true;\n            frameset_ok = false;\n            tokenizer = rcdata_state;\n            originalInsertionMode = parser;\n            parser = text_mode;\n            return;\n\n          case \"xmp\":\n            if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n            afereconstruct();\n            frameset_ok = false;\n            parseRawText(value, arg3);\n            return;\n\n          case \"iframe\":\n            frameset_ok = false;\n            parseRawText(value, arg3);\n            return;\n\n          case \"noembed\":\n            parseRawText(value, arg3);\n            return;\n\n          case \"noscript\":\n            if (scripting_enabled) {\n              parseRawText(value, arg3);\n              return;\n            }\n\n            break;\n          // XXX Otherwise treat it as any other open tag?\n\n          case \"select\":\n            afereconstruct();\n            insertHTMLElement(value, arg3);\n            frameset_ok = false;\n            if (parser === in_table_mode || parser === in_caption_mode || parser === in_table_body_mode || parser === in_row_mode || parser === in_cell_mode) parser = in_select_in_table_mode;else parser = in_select_mode;\n            return;\n\n          case \"optgroup\":\n          case \"option\":\n            if (stack.top instanceof impl.HTMLOptionElement) {\n              in_body_mode(ENDTAG, \"option\");\n            }\n\n            afereconstruct();\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"menuitem\":\n            if (isA(stack.top, 'menuitem')) {\n              stack.pop();\n            }\n\n            afereconstruct();\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"rb\":\n          case \"rtc\":\n            if (stack.inScope(\"ruby\")) {\n              stack.generateImpliedEndTags();\n            }\n\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"rp\":\n          case \"rt\":\n            if (stack.inScope(\"ruby\")) {\n              stack.generateImpliedEndTags(\"rtc\");\n            }\n\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"math\":\n            afereconstruct();\n            adjustMathMLAttributes(arg3);\n            adjustForeignAttributes(arg3);\n            insertForeignElement(value, arg3, NAMESPACE.MATHML);\n            if (arg4) // self-closing flag\n              stack.pop();\n            return;\n\n          case \"svg\":\n            afereconstruct();\n            adjustSVGAttributes(arg3);\n            adjustForeignAttributes(arg3);\n            insertForeignElement(value, arg3, NAMESPACE.SVG);\n            if (arg4) // self-closing flag\n              stack.pop();\n            return;\n\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"frame\":\n          case \"head\":\n          case \"tbody\":\n          case \"td\":\n          case \"tfoot\":\n          case \"th\":\n          case \"thead\":\n          case \"tr\":\n            // Ignore table tags if we're not in_table mode\n            return;\n        } // Handle any other start tag here\n        // (and also noscript tags when scripting is disabled)\n\n\n        afereconstruct();\n        insertHTMLElement(value, arg3);\n        return;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"template\":\n            in_head_mode(ENDTAG, value, arg3);\n            return;\n\n          case \"body\":\n            if (!stack.inScope(\"body\")) return;\n            parser = after_body_mode;\n            return;\n\n          case \"html\":\n            if (!stack.inScope(\"body\")) return;\n            parser = after_body_mode;\n            parser(t, value, arg3);\n            return;\n\n          case \"address\":\n          case \"article\":\n          case \"aside\":\n          case \"blockquote\":\n          case \"button\":\n          case \"center\":\n          case \"details\":\n          case \"dialog\":\n          case \"dir\":\n          case \"div\":\n          case \"dl\":\n          case \"fieldset\":\n          case \"figcaption\":\n          case \"figure\":\n          case \"footer\":\n          case \"header\":\n          case \"hgroup\":\n          case \"listing\":\n          case \"main\":\n          case \"menu\":\n          case \"nav\":\n          case \"ol\":\n          case \"pre\":\n          case \"section\":\n          case \"summary\":\n          case \"ul\":\n            // Ignore if there is not a matching open tag\n            if (!stack.inScope(value)) return;\n            stack.generateImpliedEndTags();\n            stack.popTag(value);\n            return;\n\n          case \"form\":\n            if (!stack.contains(\"template\")) {\n              var openform = form_element_pointer;\n              form_element_pointer = null;\n              if (!openform || !stack.elementInScope(openform)) return;\n              stack.generateImpliedEndTags();\n              stack.removeElement(openform);\n            } else {\n              if (!stack.inScope(\"form\")) return;\n              stack.generateImpliedEndTags();\n              stack.popTag(\"form\");\n            }\n\n            return;\n\n          case \"p\":\n            if (!stack.inButtonScope(value)) {\n              in_body_mode(TAG, value, null);\n              parser(t, value, arg3, arg4);\n            } else {\n              stack.generateImpliedEndTags(value);\n              stack.popTag(value);\n            }\n\n            return;\n\n          case \"li\":\n            if (!stack.inListItemScope(value)) return;\n            stack.generateImpliedEndTags(value);\n            stack.popTag(value);\n            return;\n\n          case \"dd\":\n          case \"dt\":\n            if (!stack.inScope(value)) return;\n            stack.generateImpliedEndTags(value);\n            stack.popTag(value);\n            return;\n\n          case \"h1\":\n          case \"h2\":\n          case \"h3\":\n          case \"h4\":\n          case \"h5\":\n          case \"h6\":\n            if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;\n            stack.generateImpliedEndTags();\n            stack.popElementType(impl.HTMLHeadingElement);\n            return;\n\n          case \"sarcasm\":\n            // Take a deep breath, and then:\n            break;\n\n          case \"a\":\n          case \"b\":\n          case \"big\":\n          case \"code\":\n          case \"em\":\n          case \"font\":\n          case \"i\":\n          case \"nobr\":\n          case \"s\":\n          case \"small\":\n          case \"strike\":\n          case \"strong\":\n          case \"tt\":\n          case \"u\":\n            var result = adoptionAgency(value);\n            if (result) return; // If we did something we're done\n\n            break;\n          // Go to the \"any other end tag\" case\n\n          case \"applet\":\n          case \"marquee\":\n          case \"object\":\n            if (!stack.inScope(value)) return;\n            stack.generateImpliedEndTags();\n            stack.popTag(value);\n            afe.clearToMarker();\n            return;\n\n          case \"br\":\n            in_body_mode(TAG, value, null); // Turn </br> into <br>\n\n            return;\n        } // Any other end tag goes here\n\n\n        for (i = stack.elements.length - 1; i >= 0; i--) {\n          node = stack.elements[i];\n\n          if (isA(node, value)) {\n            stack.generateImpliedEndTags(value);\n            stack.popElement(node);\n            break;\n          } else if (isA(node, specialSet)) {\n            return;\n          }\n        }\n\n        return;\n    }\n  }\n\n  function text_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        insertText(value);\n        return;\n\n      case -1:\n        // EOF\n        if (stack.top instanceof impl.HTMLScriptElement) stack.top._already_started = true;\n        stack.pop();\n        parser = originalInsertionMode;\n        parser(t);\n        return;\n\n      case 3:\n        // ENDTAG\n        if (value === \"script\") {\n          handleScriptEnd();\n        } else {\n          stack.pop();\n          parser = originalInsertionMode;\n        }\n\n        return;\n\n      default:\n        // We should never get any other token types\n        return;\n    }\n  }\n\n  function in_table_mode(t, value, arg3, arg4) {\n    function getTypeAttr(attrs) {\n      for (var i = 0, n = attrs.length; i < n; i++) {\n        if (attrs[i][0] === \"type\") return attrs[i][1].toLowerCase();\n      }\n\n      return null;\n    }\n\n    switch (t) {\n      case 1:\n        // TEXT\n        // XXX the text_integration_mode stuff is\n        // just a hack I made up\n        if (text_integration_mode) {\n          in_body_mode(t, value, arg3, arg4);\n          return;\n        } else if (isA(stack.top, tablesectionrowSet)) {\n          pending_table_text = [];\n          originalInsertionMode = parser;\n          parser = in_table_text_mode;\n          parser(t, value, arg3, arg4);\n          return;\n        }\n\n        break;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"caption\":\n            stack.clearToContext(tableContextSet);\n            afe.insertMarker();\n            insertHTMLElement(value, arg3);\n            parser = in_caption_mode;\n            return;\n\n          case \"colgroup\":\n            stack.clearToContext(tableContextSet);\n            insertHTMLElement(value, arg3);\n            parser = in_column_group_mode;\n            return;\n\n          case \"col\":\n            in_table_mode(TAG, \"colgroup\", null);\n            parser(t, value, arg3, arg4);\n            return;\n\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n            stack.clearToContext(tableContextSet);\n            insertHTMLElement(value, arg3);\n            parser = in_table_body_mode;\n            return;\n\n          case \"td\":\n          case \"th\":\n          case \"tr\":\n            in_table_mode(TAG, \"tbody\", null);\n            parser(t, value, arg3, arg4);\n            return;\n\n          case \"table\":\n            if (!stack.inTableScope(value)) {\n              return; // Ignore the token\n            }\n\n            in_table_mode(ENDTAG, value);\n            parser(t, value, arg3, arg4);\n            return;\n\n          case \"style\":\n          case \"script\":\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n\n          case \"input\":\n            var type = getTypeAttr(arg3);\n            if (type !== \"hidden\") break; // to the anything else case\n\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            return;\n\n          case \"form\":\n            if (form_element_pointer || stack.contains(\"template\")) return;\n            form_element_pointer = insertHTMLElement(value, arg3);\n            stack.popElement(form_element_pointer);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"table\":\n            if (!stack.inTableScope(value)) return;\n            stack.popTag(value);\n            resetInsertionMode();\n            return;\n\n          case \"body\":\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"html\":\n          case \"tbody\":\n          case \"td\":\n          case \"tfoot\":\n          case \"th\":\n          case \"thead\":\n          case \"tr\":\n            return;\n\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case -1:\n        // EOF\n        in_body_mode(t, value, arg3, arg4);\n        return;\n    } // This is the anything else case\n\n\n    foster_parent_mode = true;\n    in_body_mode(t, value, arg3, arg4);\n    foster_parent_mode = false;\n  }\n\n  function in_table_text_mode(t, value, arg3, arg4) {\n    if (t === TEXT) {\n      if (textIncludesNUL) {\n        value = value.replace(NULCHARS, \"\");\n        if (value.length === 0) return;\n      }\n\n      pending_table_text.push(value);\n    } else {\n      var s = pending_table_text.join(\"\");\n      pending_table_text.length = 0;\n\n      if (NONWS.test(s)) {\n        // If any non-whitespace characters\n        // This must be the same code as the \"anything else\"\n        // case of the in_table mode above.\n        foster_parent_mode = true;\n        in_body_mode(TEXT, s);\n        foster_parent_mode = false;\n      } else {\n        insertText(s);\n      }\n\n      parser = originalInsertionMode;\n      parser(t, value, arg3, arg4);\n    }\n  }\n\n  function in_caption_mode(t, value, arg3, arg4) {\n    function end_caption() {\n      if (!stack.inTableScope(\"caption\")) return false;\n      stack.generateImpliedEndTags();\n      stack.popTag(\"caption\");\n      afe.clearToMarker();\n      parser = in_table_mode;\n      return true;\n    }\n\n    switch (t) {\n      case 2:\n        // TAG\n        switch (value) {\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"tbody\":\n          case \"td\":\n          case \"tfoot\":\n          case \"th\":\n          case \"thead\":\n          case \"tr\":\n            if (end_caption()) parser(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"caption\":\n            end_caption();\n            return;\n\n          case \"table\":\n            if (end_caption()) parser(t, value, arg3, arg4);\n            return;\n\n          case \"body\":\n          case \"col\":\n          case \"colgroup\":\n          case \"html\":\n          case \"tbody\":\n          case \"td\":\n          case \"tfoot\":\n          case \"th\":\n          case \"thead\":\n          case \"tr\":\n            return;\n        }\n\n        break;\n    } // The Anything Else case\n\n\n    in_body_mode(t, value, arg3, arg4);\n  }\n\n  function in_column_group_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        var ws = value.match(LEADINGWS);\n\n        if (ws) {\n          insertText(ws[0]);\n          value = value.substring(ws[0].length);\n        }\n\n        if (value.length === 0) return;\n        break;\n      // Handle non-whitespace below\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"col\":\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            return;\n\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"colgroup\":\n            if (!isA(stack.top, 'colgroup')) {\n              return; // Ignore the token.\n            }\n\n            stack.pop();\n            parser = in_table_mode;\n            return;\n\n          case \"col\":\n            return;\n\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case -1:\n        // EOF\n        in_body_mode(t, value, arg3, arg4);\n        return;\n    } // Anything else\n\n\n    if (!isA(stack.top, 'colgroup')) {\n      return; // Ignore the token.\n    }\n\n    in_column_group_mode(ENDTAG, \"colgroup\");\n    parser(t, value, arg3, arg4);\n  }\n\n  function in_table_body_mode(t, value, arg3, arg4) {\n    function endsect() {\n      if (!stack.inTableScope(\"tbody\") && !stack.inTableScope(\"thead\") && !stack.inTableScope(\"tfoot\")) return;\n      stack.clearToContext(tableBodyContextSet);\n      in_table_body_mode(ENDTAG, stack.top.localName, null);\n      parser(t, value, arg3, arg4);\n    }\n\n    switch (t) {\n      case 2:\n        // TAG\n        switch (value) {\n          case \"tr\":\n            stack.clearToContext(tableBodyContextSet);\n            insertHTMLElement(value, arg3);\n            parser = in_row_mode;\n            return;\n\n          case \"th\":\n          case \"td\":\n            in_table_body_mode(TAG, \"tr\", null);\n            parser(t, value, arg3, arg4);\n            return;\n\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n            endsect();\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"table\":\n            endsect();\n            return;\n\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n            if (stack.inTableScope(value)) {\n              stack.clearToContext(tableBodyContextSet);\n              stack.pop();\n              parser = in_table_mode;\n            }\n\n            return;\n\n          case \"body\":\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"html\":\n          case \"td\":\n          case \"th\":\n          case \"tr\":\n            return;\n        }\n\n        break;\n    } // Anything else:\n\n\n    in_table_mode(t, value, arg3, arg4);\n  }\n\n  function in_row_mode(t, value, arg3, arg4) {\n    function endrow() {\n      if (!stack.inTableScope(\"tr\")) return false;\n      stack.clearToContext(tableRowContextSet);\n      stack.pop();\n      parser = in_table_body_mode;\n      return true;\n    }\n\n    switch (t) {\n      case 2:\n        // TAG\n        switch (value) {\n          case \"th\":\n          case \"td\":\n            stack.clearToContext(tableRowContextSet);\n            insertHTMLElement(value, arg3);\n            parser = in_cell_mode;\n            afe.insertMarker();\n            return;\n\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n          case \"tr\":\n            if (endrow()) parser(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"tr\":\n            endrow();\n            return;\n\n          case \"table\":\n            if (endrow()) parser(t, value, arg3, arg4);\n            return;\n\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n            if (stack.inTableScope(value)) {\n              if (endrow()) parser(t, value, arg3, arg4);\n            }\n\n            return;\n\n          case \"body\":\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"html\":\n          case \"td\":\n          case \"th\":\n            return;\n        }\n\n        break;\n    } // anything else\n\n\n    in_table_mode(t, value, arg3, arg4);\n  }\n\n  function in_cell_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 2:\n        // TAG\n        switch (value) {\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"tbody\":\n          case \"td\":\n          case \"tfoot\":\n          case \"th\":\n          case \"thead\":\n          case \"tr\":\n            if (stack.inTableScope(\"td\")) {\n              in_cell_mode(ENDTAG, \"td\");\n              parser(t, value, arg3, arg4);\n            } else if (stack.inTableScope(\"th\")) {\n              in_cell_mode(ENDTAG, \"th\");\n              parser(t, value, arg3, arg4);\n            }\n\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"td\":\n          case \"th\":\n            if (!stack.inTableScope(value)) return;\n            stack.generateImpliedEndTags();\n            stack.popTag(value);\n            afe.clearToMarker();\n            parser = in_row_mode;\n            return;\n\n          case \"body\":\n          case \"caption\":\n          case \"col\":\n          case \"colgroup\":\n          case \"html\":\n            return;\n\n          case \"table\":\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n          case \"tr\":\n            if (!stack.inTableScope(value)) return;\n            in_cell_mode(ENDTAG, stack.inTableScope(\"td\") ? \"td\" : \"th\");\n            parser(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n    } // anything else\n\n\n    in_body_mode(t, value, arg3, arg4);\n  }\n\n  function in_select_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        if (textIncludesNUL) {\n          value = value.replace(NULCHARS, \"\");\n          if (value.length === 0) return;\n        }\n\n        insertText(value);\n        return;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case -1:\n        // EOF\n        in_body_mode(t, value, arg3, arg4);\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"option\":\n            if (stack.top instanceof impl.HTMLOptionElement) in_select_mode(ENDTAG, value);\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"optgroup\":\n            if (stack.top instanceof impl.HTMLOptionElement) in_select_mode(ENDTAG, \"option\");\n            if (stack.top instanceof impl.HTMLOptGroupElement) in_select_mode(ENDTAG, value);\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"select\":\n            in_select_mode(ENDTAG, value); // treat it as a close tag\n\n            return;\n\n          case \"input\":\n          case \"keygen\":\n          case \"textarea\":\n            if (!stack.inSelectScope(\"select\")) return;\n            in_select_mode(ENDTAG, \"select\");\n            parser(t, value, arg3, arg4);\n            return;\n\n          case \"script\":\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"optgroup\":\n            if (stack.top instanceof impl.HTMLOptionElement && stack.elements[stack.elements.length - 2] instanceof impl.HTMLOptGroupElement) {\n              in_select_mode(ENDTAG, \"option\");\n            }\n\n            if (stack.top instanceof impl.HTMLOptGroupElement) stack.pop();\n            return;\n\n          case \"option\":\n            if (stack.top instanceof impl.HTMLOptionElement) stack.pop();\n            return;\n\n          case \"select\":\n            if (!stack.inSelectScope(value)) return;\n            stack.popTag(value);\n            resetInsertionMode();\n            return;\n\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n    } // anything else: just ignore the token\n\n  }\n\n  function in_select_in_table_mode(t, value, arg3, arg4) {\n    switch (value) {\n      case \"caption\":\n      case \"table\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n      case \"tr\":\n      case \"td\":\n      case \"th\":\n        switch (t) {\n          case 2:\n            // TAG\n            in_select_in_table_mode(ENDTAG, \"select\");\n            parser(t, value, arg3, arg4);\n            return;\n\n          case 3:\n            // ENDTAG\n            if (stack.inTableScope(value)) {\n              in_select_in_table_mode(ENDTAG, \"select\");\n              parser(t, value, arg3, arg4);\n            }\n\n            return;\n        }\n\n    } // anything else\n\n\n    in_select_mode(t, value, arg3, arg4);\n  }\n\n  function in_template_mode(t, value, arg3, arg4) {\n    function switchModeAndReprocess(mode) {\n      parser = mode;\n      templateInsertionModes[templateInsertionModes.length - 1] = parser;\n      parser(t, value, arg3, arg4);\n    }\n\n    switch (t) {\n      case 1: // TEXT\n\n      case 4: // COMMENT\n\n      case 5:\n        // DOCTYPE\n        in_body_mode(t, value, arg3, arg4);\n        return;\n\n      case -1:\n        // EOF\n        if (!stack.contains(\"template\")) {\n          stopParsing();\n        } else {\n          stack.popTag(\"template\");\n          afe.clearToMarker();\n          templateInsertionModes.pop();\n          resetInsertionMode();\n          parser(t, value, arg3, arg4);\n        }\n\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"base\":\n          case \"basefont\":\n          case \"bgsound\":\n          case \"link\":\n          case \"meta\":\n          case \"noframes\":\n          case \"script\":\n          case \"style\":\n          case \"template\":\n          case \"title\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n\n          case \"caption\":\n          case \"colgroup\":\n          case \"tbody\":\n          case \"tfoot\":\n          case \"thead\":\n            switchModeAndReprocess(in_table_mode);\n            return;\n\n          case \"col\":\n            switchModeAndReprocess(in_column_group_mode);\n            return;\n\n          case \"tr\":\n            switchModeAndReprocess(in_table_body_mode);\n            return;\n\n          case \"td\":\n          case \"th\":\n            switchModeAndReprocess(in_row_mode);\n            return;\n        }\n\n        switchModeAndReprocess(in_body_mode);\n        return;\n\n      case 3:\n        // ENDTAG\n        switch (value) {\n          case \"template\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n\n          default:\n            return;\n        }\n\n    }\n  }\n\n  function after_body_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        // If any non-space chars, handle below\n        if (NONWS.test(value)) break;\n        in_body_mode(t, value);\n        return;\n\n      case 4:\n        // COMMENT\n        // Append it to the <html> element\n        stack.elements[0]._appendChild(doc.createComment(value));\n\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case -1:\n        // EOF\n        stopParsing();\n        return;\n\n      case 2:\n        // TAG\n        if (value === \"html\") {\n          in_body_mode(t, value, arg3, arg4);\n          return;\n        }\n\n        break;\n      // for any other tags\n\n      case 3:\n        // ENDTAG\n        if (value === \"html\") {\n          if (fragment) return;\n          parser = after_after_body_mode;\n          return;\n        }\n\n        break;\n      // for any other tags\n    } // anything else\n\n\n    parser = in_body_mode;\n    parser(t, value, arg3, arg4);\n  }\n\n  function in_frameset_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        // Ignore any non-space characters\n        value = value.replace(ALLNONWS, \"\");\n        if (value.length > 0) insertText(value);\n        return;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case -1:\n        // EOF\n        stopParsing();\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"frameset\":\n            insertHTMLElement(value, arg3);\n            return;\n\n          case \"frame\":\n            insertHTMLElement(value, arg3);\n            stack.pop();\n            return;\n\n          case \"noframes\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        if (value === \"frameset\") {\n          if (fragment && stack.top instanceof impl.HTMLHtmlElement) return;\n          stack.pop();\n          if (!fragment && !(stack.top instanceof impl.HTMLFrameSetElement)) parser = after_frameset_mode;\n          return;\n        }\n\n        break;\n    } // ignore anything else\n\n  }\n\n  function after_frameset_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        // Ignore any non-space characters\n        value = value.replace(ALLNONWS, \"\");\n        if (value.length > 0) insertText(value);\n        return;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        return;\n\n      case -1:\n        // EOF\n        stopParsing();\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"noframes\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n\n      case 3:\n        // ENDTAG\n        if (value === \"html\") {\n          parser = after_after_frameset_mode;\n          return;\n        }\n\n        break;\n    } // ignore anything else\n\n  }\n\n  function after_after_body_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        // If any non-space chars, handle below\n        if (NONWS.test(value)) break;\n        in_body_mode(t, value, arg3, arg4);\n        return;\n\n      case 4:\n        // COMMENT\n        doc._appendChild(doc.createComment(value));\n\n        return;\n\n      case 5:\n        // DOCTYPE\n        in_body_mode(t, value, arg3, arg4);\n        return;\n\n      case -1:\n        // EOF\n        stopParsing();\n        return;\n\n      case 2:\n        // TAG\n        if (value === \"html\") {\n          in_body_mode(t, value, arg3, arg4);\n          return;\n        }\n\n        break;\n    } // anything else\n\n\n    parser = in_body_mode;\n    parser(t, value, arg3, arg4);\n  }\n\n  function after_after_frameset_mode(t, value, arg3, arg4) {\n    switch (t) {\n      case 1:\n        // TEXT\n        // Ignore any non-space characters\n        value = value.replace(ALLNONWS, \"\");\n        if (value.length > 0) in_body_mode(t, value, arg3, arg4);\n        return;\n\n      case 4:\n        // COMMENT\n        doc._appendChild(doc.createComment(value));\n\n        return;\n\n      case 5:\n        // DOCTYPE\n        in_body_mode(t, value, arg3, arg4);\n        return;\n\n      case -1:\n        // EOF\n        stopParsing();\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"html\":\n            in_body_mode(t, value, arg3, arg4);\n            return;\n\n          case \"noframes\":\n            in_head_mode(t, value, arg3, arg4);\n            return;\n        }\n\n        break;\n    } // ignore anything else\n\n  } // 13.2.5.5 The rules for parsing tokens in foreign content\n  //\n  // This is like one of the insertion modes above, but is\n  // invoked somewhat differently when the current token is not HTML.\n  // See the insertToken() function.\n\n\n  function insertForeignToken(t, value, arg3, arg4) {\n    // A <font> tag is an HTML font tag if it has a color, font, or size\n    // attribute.  Otherwise we assume it is foreign content\n    function isHTMLFont(attrs) {\n      for (var i = 0, n = attrs.length; i < n; i++) {\n        switch (attrs[i][0]) {\n          case \"color\":\n          case \"face\":\n          case \"size\":\n            return true;\n        }\n      }\n\n      return false;\n    }\n\n    var current;\n\n    switch (t) {\n      case 1:\n        // TEXT\n        // If any non-space, non-nul characters\n        if (frameset_ok && NONWSNONNUL.test(value)) frameset_ok = false;\n\n        if (textIncludesNUL) {\n          value = value.replace(NULCHARS, \"\\uFFFD\");\n        }\n\n        insertText(value);\n        return;\n\n      case 4:\n        // COMMENT\n        insertComment(value);\n        return;\n\n      case 5:\n        // DOCTYPE\n        // ignore it\n        return;\n\n      case 2:\n        // TAG\n        switch (value) {\n          case \"font\":\n            if (!isHTMLFont(arg3)) break;\n\n          /* falls through */\n\n          case \"b\":\n          case \"big\":\n          case \"blockquote\":\n          case \"body\":\n          case \"br\":\n          case \"center\":\n          case \"code\":\n          case \"dd\":\n          case \"div\":\n          case \"dl\":\n          case \"dt\":\n          case \"em\":\n          case \"embed\":\n          case \"h1\":\n          case \"h2\":\n          case \"h3\":\n          case \"h4\":\n          case \"h5\":\n          case \"h6\":\n          case \"head\":\n          case \"hr\":\n          case \"i\":\n          case \"img\":\n          case \"li\":\n          case \"listing\":\n          case \"menu\":\n          case \"meta\":\n          case \"nobr\":\n          case \"ol\":\n          case \"p\":\n          case \"pre\":\n          case \"ruby\":\n          case \"s\":\n          case \"small\":\n          case \"span\":\n          case \"strong\":\n          case \"strike\":\n          case \"sub\":\n          case \"sup\":\n          case \"table\":\n          case \"tt\":\n          case \"u\":\n          case \"ul\":\n          case \"var\":\n            if (fragment) {\n              break;\n            }\n\n            do {\n              stack.pop();\n              current = stack.top;\n            } while (current.namespaceURI !== NAMESPACE.HTML && !isMathmlTextIntegrationPoint(current) && !isHTMLIntegrationPoint(current));\n\n            insertToken(t, value, arg3, arg4); // reprocess\n\n            return;\n        } // Any other start tag case goes here\n\n\n        current = stack.elements.length === 1 && fragment ? fragmentContext : stack.top;\n\n        if (current.namespaceURI === NAMESPACE.MATHML) {\n          adjustMathMLAttributes(arg3);\n        } else if (current.namespaceURI === NAMESPACE.SVG) {\n          value = adjustSVGTagName(value);\n          adjustSVGAttributes(arg3);\n        }\n\n        adjustForeignAttributes(arg3);\n        insertForeignElement(value, arg3, current.namespaceURI);\n\n        if (arg4) {\n          // the self-closing flag\n          if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {// XXX deal with SVG scripts here\n          }\n\n          stack.pop();\n        }\n\n        return;\n\n      case 3:\n        // ENDTAG\n        current = stack.top;\n\n        if (value === \"script\" && current.namespaceURI === NAMESPACE.SVG && current.localName === \"script\") {\n          stack.pop(); // XXX\n          // Deal with SVG scripts here\n        } else {\n          // The any other end tag case\n          var i = stack.elements.length - 1;\n          var node = stack.elements[i];\n\n          for (;;) {\n            if (node.localName.toLowerCase() === value) {\n              stack.popElement(node);\n              break;\n            }\n\n            node = stack.elements[--i]; // If non-html, keep looping\n\n            if (node.namespaceURI !== NAMESPACE.HTML) continue; // Otherwise process the end tag as html\n\n            parser(t, value, arg3, arg4);\n            break;\n          }\n        }\n\n        return;\n    }\n  }\n  /***\n   * Finally, this is the end of the HTMLParser() factory function.\n   * It returns the htmlparser object with the append() and end() methods.\n   */\n  // Sneak another method into the htmlparser object to allow us to run\n  // tokenizer tests.  This can be commented out in production code.\n  // This is a hook for testing the tokenizer. It has to be here\n  // because the tokenizer details are all hidden away within the closure.\n  // It should return an array of tokens generated while parsing the\n  // input string.\n\n\n  htmlparser.testTokenizer = function (input, initialState, lastStartTag, charbychar) {\n    var tokens = [];\n\n    switch (initialState) {\n      case \"PCDATA state\":\n        tokenizer = data_state;\n        break;\n\n      case \"RCDATA state\":\n        tokenizer = rcdata_state;\n        break;\n\n      case \"RAWTEXT state\":\n        tokenizer = rawtext_state;\n        break;\n\n      case \"PLAINTEXT state\":\n        tokenizer = plaintext_state;\n        break;\n    }\n\n    if (lastStartTag) {\n      lasttagname = lastStartTag;\n    }\n\n    insertToken = function (t, value, arg3, arg4) {\n      flushText();\n\n      switch (t) {\n        case 1:\n          // TEXT\n          if (tokens.length > 0 && tokens[tokens.length - 1][0] === \"Character\") {\n            tokens[tokens.length - 1][1] += value;\n          } else tokens.push([\"Character\", value]);\n\n          break;\n\n        case 4:\n          // COMMENT\n          tokens.push([\"Comment\", value]);\n          break;\n\n        case 5:\n          // DOCTYPE\n          tokens.push([\"DOCTYPE\", value, arg3 === undefined ? null : arg3, arg4 === undefined ? null : arg4, !force_quirks]);\n          break;\n\n        case 2:\n          // TAG\n          var attrs = Object.create(null);\n\n          for (var i = 0; i < arg3.length; i++) {\n            // XXX: does attribute order matter?\n            var a = arg3[i];\n\n            if (a.length === 1) {\n              attrs[a[0]] = \"\";\n            } else {\n              attrs[a[0]] = a[1];\n            }\n          }\n\n          var token = [\"StartTag\", value, attrs];\n          if (arg4) token.push(true);\n          tokens.push(token);\n          break;\n\n        case 3:\n          // ENDTAG\n          tokens.push([\"EndTag\", value]);\n          break;\n\n        case -1:\n          // EOF\n          break;\n      }\n    };\n\n    if (!charbychar) {\n      this.parse(input, true);\n    } else {\n      for (var i = 0; i < input.length; i++) {\n        this.parse(input[i]);\n      }\n\n      this.parse(\"\", true);\n    }\n\n    return tokens;\n  }; // Return the parser object from the HTMLParser() factory function\n\n\n  return htmlparser;\n}","map":null,"metadata":{},"sourceType":"script"}