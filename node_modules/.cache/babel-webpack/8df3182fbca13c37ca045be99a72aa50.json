{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\n\nconst filter_1 = require(\"./filter\");\n\nconst constants_1 = require(\"./constants\");\n\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n  constructor(options, callStream) {\n    super();\n    this.options = options;\n    this.callStream = callStream;\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n\n  sendMessage(message) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      /* A configured size of -1 means that there is no limit, so skip the check\n       * entirely */\n      if (_this.maxSendMessageSize === -1) {\n        return message;\n      } else {\n        const concreteMessage = yield message;\n\n        if (concreteMessage.message.length > _this.maxSendMessageSize) {\n          _this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${_this.maxSendMessageSize})`);\n\n          return Promise.reject('Message too large');\n        } else {\n          return concreteMessage;\n        }\n      }\n    })();\n  }\n\n  receiveMessage(message) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      /* A configured size of -1 means that there is no limit, so skip the check\n       * entirely */\n      if (_this2.maxReceiveMessageSize === -1) {\n        return message;\n      } else {\n        const concreteMessage = yield message;\n\n        if (concreteMessage.length > _this2.maxReceiveMessageSize) {\n          _this2.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${_this2.maxReceiveMessageSize})`);\n\n          return Promise.reject('Message too large');\n        } else {\n          return concreteMessage;\n        }\n      }\n    })();\n  }\n\n}\n\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\n\nclass MaxMessageSizeFilterFactory {\n  constructor(options) {\n    this.options = options;\n  }\n\n  createFilter(callStream) {\n    return new MaxMessageSizeFilter(this.options, callStream);\n  }\n\n}\n\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory; //# sourceMappingURL=max-message-size-filter.js.map","map":null,"metadata":{},"sourceType":"script"}