{"ast":null,"code":"import _asyncToGenerator from \"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * True if the custom elements polyfill is in use.\n */\nconst isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\n\nconst removeNodes = (container, start, end = null) => {\n  while (start !== end) {\n    const n = start.nextSibling;\n    container.removeChild(start);\n    start = n;\n  }\n};\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\n\n\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\n\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\n\nconst boundAttributeSuffix = '$lit$';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\n\nclass Template {\n  constructor(result, element) {\n    this.parts = [];\n    this.element = element;\n    const nodesToRemove = [];\n    const stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n\n    const walker = document.createTreeWalker(element.content, 133\n    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n    , null, false); // Keeps track of the last index associated with a part. We try to delete\n    // unnecessary nodes, but we never want to associate two different parts\n    // to the same index. They must have a constant node between.\n\n    let lastPartIndex = 0;\n    let index = -1;\n    let partIndex = 0;\n    const {\n      strings,\n      values: {\n        length\n      }\n    } = result;\n\n    while (partIndex < length) {\n      const node = walker.nextNode();\n\n      if (node === null) {\n        // We've exhausted the content inside a nested template element.\n        // Because we still have parts (the outer for-loop), we know:\n        // - There is a template in the stack\n        // - The walker will find a nextNode outside the template\n        walker.currentNode = stack.pop();\n        continue;\n      }\n\n      index++;\n\n      if (node.nodeType === 1\n      /* Node.ELEMENT_NODE */\n      ) {\n          if (node.hasAttributes()) {\n            const attributes = node.attributes;\n            const {\n              length\n            } = attributes; // Per\n            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n            // attributes are not guaranteed to be returned in document order.\n            // In particular, Edge/IE can return them out of order, so we cannot\n            // assume a correspondence between part index and attribute index.\n\n            let count = 0;\n\n            for (let i = 0; i < length; i++) {\n              if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                count++;\n              }\n            }\n\n            while (count-- > 0) {\n              // Get the template literal section leading up to the first\n              // expression in this attribute\n              const stringForPart = strings[partIndex]; // Find the attribute name\n\n              const name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute\n              // All bound attributes have had a suffix added in\n              // TemplateResult#getHTML to opt out of special attribute\n              // handling. To look up the attribute value we also need to add\n              // the suffix.\n\n              const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n              const attributeValue = node.getAttribute(attributeLookupName);\n              node.removeAttribute(attributeLookupName);\n              const statics = attributeValue.split(markerRegex);\n              this.parts.push({\n                type: 'attribute',\n                index,\n                name,\n                strings: statics\n              });\n              partIndex += statics.length - 1;\n            }\n          }\n\n          if (node.tagName === 'TEMPLATE') {\n            stack.push(node);\n            walker.currentNode = node.content;\n          }\n        } else if (node.nodeType === 3\n      /* Node.TEXT_NODE */\n      ) {\n          const data = node.data;\n\n          if (data.indexOf(marker) >= 0) {\n            const parent = node.parentNode;\n            const strings = data.split(markerRegex);\n            const lastIndex = strings.length - 1; // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n\n            for (let i = 0; i < lastIndex; i++) {\n              let insert;\n              let s = strings[i];\n\n              if (s === '') {\n                insert = createMarker();\n              } else {\n                const match = lastAttributeNameRegex.exec(s);\n\n                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                  s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                }\n\n                insert = document.createTextNode(s);\n              }\n\n              parent.insertBefore(insert, node);\n              this.parts.push({\n                type: 'node',\n                index: ++index\n              });\n            } // If there's no text, we must insert a comment to mark our place.\n            // Else, we can trust it will stick around after cloning.\n\n\n            if (strings[lastIndex] === '') {\n              parent.insertBefore(createMarker(), node);\n              nodesToRemove.push(node);\n            } else {\n              node.data = strings[lastIndex];\n            } // We have a part for each match found\n\n\n            partIndex += lastIndex;\n          }\n        } else if (node.nodeType === 8\n      /* Node.COMMENT_NODE */\n      ) {\n          if (node.data === marker) {\n            const parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of\n            // the following are true:\n            //  * We don't have a previousSibling\n            //  * The previousSibling is already the start of a previous part\n\n            if (node.previousSibling === null || index === lastPartIndex) {\n              index++;\n              parent.insertBefore(createMarker(), node);\n            }\n\n            lastPartIndex = index;\n            this.parts.push({\n              type: 'node',\n              index\n            }); // If we don't have a nextSibling, keep this node so we have an end.\n            // Else, we can remove it to save future costs.\n\n            if (node.nextSibling === null) {\n              node.data = '';\n            } else {\n              nodesToRemove.push(node);\n              index--;\n            }\n\n            partIndex++;\n          } else {\n            let i = -1;\n\n            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n              // Comment node has a binding marker inside, make an inactive part\n              // The binding won't work, but subsequent bindings will\n              // TODO (justinfagnani): consider whether it's even worth it to\n              // make bindings in comments work\n              this.parts.push({\n                type: 'node',\n                index: -1\n              });\n              partIndex++;\n            }\n          }\n        }\n    } // Remove text binding nodes after the walk to not disturb the TreeWalker\n\n\n    for (const n of nodesToRemove) {\n      n.parentNode.removeChild(n);\n    }\n  }\n\n}\n\nconst endsWith = (str, suffix) => {\n  const index = str.length - suffix.length;\n  return index >= 0 && str.slice(index) === suffix;\n};\n\nconst isTemplatePartActive = part => part.index !== -1; // Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\n\n\nconst createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\n\n\nconst lastAttributeNameRegex = // eslint-disable-next-line no-control-regex\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst walkerNodeFilter = 133\n/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\n\nfunction removeNodesFromTemplate(template, nodesToRemove) {\n  const {\n    element: {\n      content\n    },\n    parts\n  } = template;\n  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let part = parts[partIndex];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode = null;\n\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode; // End removal if stepped past the removing node\n\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    } // A node to remove was found in the template\n\n\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node); // Track node we're removing\n\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    } // When removing, increment count by which to adjust subsequent part indices\n\n\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.\n\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n      part = parts[partIndex];\n    }\n  }\n\n  nodesToRemoveInTemplate.forEach(n => n.parentNode.removeChild(n));\n}\n\nconst countNodes = node => {\n  let count = node.nodeType === 11\n  /* Node.DOCUMENT_FRAGMENT_NODE */\n  ? 0 : 1;\n  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n\n  while (walker.nextNode()) {\n    count++;\n  }\n\n  return count;\n};\n\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n  for (let i = startIndex + 1; i < parts.length; i++) {\n    const part = parts[i];\n\n    if (isTemplatePartActive(part)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\n\n\nfunction insertNodeIntoTemplate(template, node, refNode = null) {\n  const {\n    element: {\n      content\n    },\n    parts\n  } = template; // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n\n  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode;\n\n    if (walkerNode === refNode) {\n      insertCount = countNodes(node);\n      refNode.parentNode.insertBefore(node, refNode);\n    }\n\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n\n        return;\n      }\n\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\nconst directives = new WeakMap();\n\nconst isDirective = o => {\n  return typeof o === 'function' && directives.has(o);\n};\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\n\n\nconst noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\n\nconst nothing = {};\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\n\nclass TemplateInstance {\n  constructor(template, processor, options) {\n    this.__parts = [];\n    this.template = template;\n    this.processor = processor;\n    this.options = options;\n  }\n\n  update(values) {\n    let i = 0;\n\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.setValue(values[i]);\n      }\n\n      i++;\n    }\n\n    for (const part of this.__parts) {\n      if (part !== undefined) {\n        part.commit();\n      }\n    }\n  }\n\n  _clone() {\n    // There are a number of steps in the lifecycle of a template instance's\n    // DOM fragment:\n    //  1. Clone - create the instance fragment\n    //  2. Adopt - adopt into the main document\n    //  3. Process - find part markers and create parts\n    //  4. Upgrade - upgrade custom elements\n    //  5. Update - set node, attribute, property, etc., values\n    //  6. Connect - connect to the document. Optional and outside of this\n    //     method.\n    //\n    // We have a few constraints on the ordering of these steps:\n    //  * We need to upgrade before updating, so that property values will pass\n    //    through any property setters.\n    //  * We would like to process before upgrading so that we're sure that the\n    //    cloned fragment is inert and not disturbed by self-modifying DOM.\n    //  * We want custom elements to upgrade even in disconnected fragments.\n    //\n    // Given these constraints, with full custom elements support we would\n    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n    //\n    // But Safari does not implement CustomElementRegistry#upgrade, so we\n    // can not implement that order and still have upgrade-before-update and\n    // upgrade disconnected fragments. So we instead sacrifice the\n    // process-before-upgrade constraint, since in Custom Elements v1 elements\n    // must not modify their light DOM in the constructor. We still have issues\n    // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n    // that don't strictly adhere to the no-modification rule because shadow\n    // DOM, which may be created in the constructor, is emulated by being placed\n    // in the light DOM.\n    //\n    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n    // in one step.\n    //\n    // The Custom Elements v1 polyfill supports upgrade(), so the order when\n    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n    // Connect.\n    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);\n    const stack = [];\n    const parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n\n    const walker = document.createTreeWalker(fragment, 133\n    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */\n    , null, false);\n    let partIndex = 0;\n    let nodeIndex = 0;\n    let part;\n    let node = walker.nextNode(); // Loop through all the nodes and parts of a template\n\n    while (partIndex < parts.length) {\n      part = parts[partIndex];\n\n      if (!isTemplatePartActive(part)) {\n        this.__parts.push(undefined);\n\n        partIndex++;\n        continue;\n      } // Progress the tree walker until we find our next part's node.\n      // Note that multiple parts may share the same node (attribute parts\n      // on a single element), so this loop may not run at all.\n\n\n      while (nodeIndex < part.index) {\n        nodeIndex++;\n\n        if (node.nodeName === 'TEMPLATE') {\n          stack.push(node);\n          walker.currentNode = node.content;\n        }\n\n        if ((node = walker.nextNode()) === null) {\n          // We've exhausted the content inside a nested template element.\n          // Because we still have parts (the outer for-loop), we know:\n          // - There is a template in the stack\n          // - The walker will find a nextNode outside the template\n          walker.currentNode = stack.pop();\n          node = walker.nextNode();\n        }\n      } // We've arrived at our part's node.\n\n\n      if (part.type === 'node') {\n        const part = this.processor.handleTextExpression(this.options);\n        part.insertAfterNode(node.previousSibling);\n\n        this.__parts.push(part);\n      } else {\n        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n      }\n\n      partIndex++;\n    }\n\n    if (isCEPolyfill) {\n      document.adoptNode(fragment);\n      customElements.upgrade(fragment);\n    }\n\n    return fragment;\n  }\n\n}\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\n\n\nconst policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', {\n  createHTML: s => s\n});\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\n\nclass TemplateResult {\n  constructor(strings, values, type, processor) {\n    this.strings = strings;\n    this.values = values;\n    this.type = type;\n    this.processor = processor;\n  }\n  /**\n   * Returns a string of HTML used to create a `<template>` element.\n   */\n\n\n  getHTML() {\n    const l = this.strings.length - 1;\n    let html = '';\n    let isCommentBinding = false;\n\n    for (let i = 0; i < l; i++) {\n      const s = this.strings[i]; // For each binding we want to determine the kind of marker to insert\n      // into the template source before it's parsed by the browser's HTML\n      // parser. The marker type is based on whether the expression is in an\n      // attribute, text, or comment position.\n      //   * For node-position bindings we insert a comment with the marker\n      //     sentinel as its text content, like <!--{{lit-guid}}-->.\n      //   * For attribute bindings we insert just the marker sentinel for the\n      //     first binding, so that we support unquoted attribute bindings.\n      //     Subsequent bindings can use a comment marker because multi-binding\n      //     attributes must be quoted.\n      //   * For comment bindings we insert just the marker sentinel so we don't\n      //     close the comment.\n      //\n      // The following code scans the template source, but is *not* an HTML\n      // parser. We don't need to track the tree structure of the HTML, only\n      // whether a binding is inside a comment, and if not, if it appears to be\n      // the first binding in an attribute.\n\n      const commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following\n      // comment close. Because <-- can appear in an attribute value there can\n      // be false positives.\n\n      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the\n      // expression. This can match \"name=value\" like structures in text,\n      // comments, and attribute values, so there can be false-positives.\n\n      const attributeMatch = lastAttributeNameRegex.exec(s);\n\n      if (attributeMatch === null) {\n        // We're only in this branch if we don't have a attribute-like\n        // preceding sequence. For comments, this guards against unusual\n        // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\n        // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\n        // below.\n        html += s + (isCommentBinding ? commentMarker : nodeMarker);\n      } else {\n        // For attributes we use just a marker sentinel, and also append a\n        // $lit$ suffix to the name to opt-out of attribute-specific parsing\n        // that IE and Edge do for style and certain SVG attributes.\n        html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;\n      }\n    }\n\n    html += this.strings[l];\n    return html;\n  }\n\n  getTemplateElement() {\n    const template = document.createElement('template');\n    let value = this.getHTML();\n\n    if (policy !== undefined) {\n      // this is secure because `this.strings` is a TemplateStringsArray.\n      // TODO: validate this when\n      // https://github.com/tc39/proposal-array-is-template-object is\n      // implemented.\n      value = policy.createHTML(value);\n    }\n\n    template.innerHTML = value;\n    return template;\n  }\n\n}\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\nconst isPrimitive = value => {\n  return value === null || !(typeof value === 'object' || typeof value === 'function');\n};\n\nconst isIterable = value => {\n  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  !!(value && value[Symbol.iterator]);\n};\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\n\n\nclass NodePart {\n  constructor(options) {\n    this.value = undefined;\n    this.__pendingValue = undefined;\n    this.options = options;\n  }\n  /**\n   * Appends this part into a container.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  appendInto(container) {\n    this.startNode = container.appendChild(createMarker());\n    this.endNode = container.appendChild(createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n   * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n   * such as those that appear in a literal section of a template.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  insertAfterNode(ref) {\n    this.startNode = ref;\n    this.endNode = ref.nextSibling;\n  }\n  /**\n   * Appends this part into a parent part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  appendIntoPart(part) {\n    part.__insert(this.startNode = createMarker());\n\n    part.__insert(this.endNode = createMarker());\n  }\n  /**\n   * Inserts this part after the `ref` part.\n   *\n   * This part must be empty, as its contents are not automatically moved.\n   */\n\n\n  insertAfterPart(ref) {\n    ref.__insert(this.startNode = createMarker());\n\n    this.endNode = ref.endNode;\n    ref.endNode = this.startNode;\n  }\n\n  setValue(value) {\n    this.__pendingValue = value;\n  }\n\n  commit() {\n    if (this.startNode.parentNode === null) {\n      return;\n    }\n\n    while (isDirective(this.__pendingValue)) {\n      const directive = this.__pendingValue;\n      this.__pendingValue = noChange;\n      directive(this);\n    }\n\n    const value = this.__pendingValue;\n\n    if (value === noChange) {\n      return;\n    }\n\n    if (isPrimitive(value)) {\n      if (value !== this.value) {\n        this.__commitText(value);\n      }\n    } else if (value instanceof TemplateResult) {\n      this.__commitTemplateResult(value);\n    } else if (value instanceof Node) {\n      this.__commitNode(value);\n    } else if (isIterable(value)) {\n      this.__commitIterable(value);\n    } else if (value === nothing) {\n      this.value = nothing;\n      this.clear();\n    } else {\n      // Fallback, will render the string representation\n      this.__commitText(value);\n    }\n  }\n\n  __insert(node) {\n    this.endNode.parentNode.insertBefore(node, this.endNode);\n  }\n\n  __commitNode(value) {\n    if (this.value === value) {\n      return;\n    }\n\n    this.clear();\n\n    this.__insert(value);\n\n    this.value = value;\n  }\n\n  __commitText(value) {\n    const node = this.startNode.nextSibling;\n    value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case\n    // it can't be implicitly converted - i.e. it's a symbol.\n\n    const valueAsString = typeof value === 'string' ? value : String(value);\n\n    if (node === this.endNode.previousSibling && node.nodeType === 3\n    /* Node.TEXT_NODE */\n    ) {\n        // If we only have a single text node between the markers, we can just\n        // set its value, rather than replacing it.\n        // TODO(justinfagnani): Can we just check if this.value is primitive?\n        node.data = valueAsString;\n      } else {\n      this.__commitNode(document.createTextNode(valueAsString));\n    }\n\n    this.value = value;\n  }\n\n  __commitTemplateResult(value) {\n    const template = this.options.templateFactory(value);\n\n    if (this.value instanceof TemplateInstance && this.value.template === template) {\n      this.value.update(value.values);\n    } else {\n      // Make sure we propagate the template processor from the TemplateResult\n      // so that we use its syntax extension, etc. The template factory comes\n      // from the render function options so that it can control template\n      // caching and preprocessing.\n      const instance = new TemplateInstance(template, value.processor, this.options);\n\n      const fragment = instance._clone();\n\n      instance.update(value.values);\n\n      this.__commitNode(fragment);\n\n      this.value = instance;\n    }\n  }\n\n  __commitIterable(value) {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n    // If _value is an array, then the previous render was of an\n    // iterable and _value will contain the NodeParts from the previous\n    // render. If _value is not an array, clear this part and make a new\n    // array for NodeParts.\n    if (!Array.isArray(this.value)) {\n      this.value = [];\n      this.clear();\n    } // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n\n\n    const itemParts = this.value;\n    let partIndex = 0;\n    let itemPart;\n\n    for (const item of value) {\n      // Try to reuse an existing part\n      itemPart = itemParts[partIndex]; // If no existing part, create a new one\n\n      if (itemPart === undefined) {\n        itemPart = new NodePart(this.options);\n        itemParts.push(itemPart);\n\n        if (partIndex === 0) {\n          itemPart.appendIntoPart(this);\n        } else {\n          itemPart.insertAfterPart(itemParts[partIndex - 1]);\n        }\n      }\n\n      itemPart.setValue(item);\n      itemPart.commit();\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n      this.clear(itemPart && itemPart.endNode);\n    }\n  }\n\n  clear(startNode = this.startNode) {\n    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n  }\n\n} // Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\n\n\nlet eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n\n(() => {\n  try {\n    const options = {\n      get capture() {\n        eventOptionsSupported = true;\n        return false;\n      }\n\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    window.removeEventListener('test', options, options);\n  } catch (_e) {// event options not supported\n  }\n})();\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\n\n\nfunction templateFactory(result) {\n  let templateCache = templateCaches.get(result.type);\n\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap(),\n      keyString: new Map()\n    };\n    templateCaches.set(result.type, templateCache);\n  }\n\n  let template = templateCache.stringsArray.get(result.strings);\n\n  if (template !== undefined) {\n    return template;\n  } // If the TemplateStringsArray is new, generate a key from the strings\n  // This key is shared between all templates with identical content\n\n\n  const key = result.strings.join(marker); // Check if we already have a Template for this key\n\n  template = templateCache.keyString.get(key);\n\n  if (template === undefined) {\n    // If we have not seen this key before, create a new Template\n    template = new Template(result, result.getTemplateElement()); // Cache the Template for this key\n\n    templateCache.keyString.set(key, template);\n  } // Cache all future queries for this TemplateStringsArray\n\n\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n}\n\nconst templateCaches = new Map();\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\n\nconst render$1 = (result, container, options) => {\n  let part = parts.get(container);\n\n  if (part === undefined) {\n    removeNodes(container, container.firstChild);\n    parts.set(container, part = new NodePart(Object.assign({\n      templateFactory\n    }, options)));\n    part.appendInto(container);\n  }\n\n  part.setValue(result);\n  part.commit();\n};\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n\n\nif (typeof window !== 'undefined') {\n  (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');\n}\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// Get a key to lookup in `templateCaches`.\n\n\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\n\nlet compatibleShadyCSSVersion = true;\n\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(`Incompatible ShadyCSS version detected. ` + `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` + `@webcomponents/shadycss@1.3.1.`);\n  compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\n\n\nconst shadyTemplateFactory = scopeName => result => {\n  const cacheKey = getTemplateCacheKey(result.type, scopeName);\n  let templateCache = templateCaches.get(cacheKey);\n\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap(),\n      keyString: new Map()\n    };\n    templateCaches.set(cacheKey, templateCache);\n  }\n\n  let template = templateCache.stringsArray.get(result.strings);\n\n  if (template !== undefined) {\n    return template;\n  }\n\n  const key = result.strings.join(marker);\n  template = templateCache.keyString.get(key);\n\n  if (template === undefined) {\n    const element = result.getTemplateElement();\n\n    if (compatibleShadyCSSVersion) {\n      window.ShadyCSS.prepareTemplateDom(element, scopeName);\n    }\n\n    template = new Template(result, element);\n    templateCache.keyString.set(key, template);\n  }\n\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n};\n\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\n\nconst removeStylesFromLitTemplates = scopeName => {\n  TEMPLATE_TYPES.forEach(type => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n\n    if (templates !== undefined) {\n      templates.keyString.forEach(template => {\n        const {\n          element: {\n            content\n          }\n        } = template; // IE 11 doesn't support the iterable param Set constructor\n\n        const styles = new Set();\n        Array.from(content.querySelectorAll('style')).forEach(s => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\n\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\n\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n  shadyRenderSet.add(scopeName); // If `renderedDOM` is stamped from a Template, then we need to edit that\n  // Template's underlying template element. Otherwise, we create one here\n  // to give to ShadyCSS, which still requires one while scoping.\n\n  const templateElement = !!template ? template.element : document.createElement('template'); // Move styles out of rendered DOM and store.\n\n  const styles = renderedDOM.querySelectorAll('style');\n  const {\n    length\n  } = styles; // If there are no styles, skip unnecessary work\n\n  if (length === 0) {\n    // Ensure prepareTemplateStyles is called to support adding\n    // styles via `prepareAdoptedCssText` since that requires that\n    // `prepareTemplateStyles` is called.\n    //\n    // ShadyCSS will only update styles containing @apply in the template\n    // given to `prepareTemplateStyles`. If no lit Template was given,\n    // ShadyCSS will not be able to update uses of @apply in any relevant\n    // template. However, this is not a problem because we only create the\n    // template for the purpose of supporting `prepareAdoptedCssText`,\n    // which doesn't support @apply at all.\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    return;\n  }\n\n  const condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS\n  // manipulations will not prevent us from being able to fix up template\n  // part indices.\n  // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n  // currently does this anyway. When it does not, this should be changed.\n\n  for (let i = 0; i < length; i++) {\n    const style = styles[i];\n    style.parentNode.removeChild(style);\n    condensedStyle.textContent += style.textContent;\n  } // Remove styles from nested templates in this scope.\n\n\n  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the \"root\" template passed in as\n  // `template`.\n\n  const content = templateElement.content;\n\n  if (!!template) {\n    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n  } else {\n    content.insertBefore(condensedStyle, content.firstChild);\n  } // Note, it's important that ShadyCSS gets the template that `lit-html`\n  // will actually render so that it can update the style inside when\n  // needed (e.g. @apply native Shadow DOM case).\n\n\n  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n  const style = content.querySelector('style');\n\n  if (window.ShadyCSS.nativeShadow && style !== null) {\n    // When in native Shadow DOM, ensure the style created by ShadyCSS is\n    // included in initially rendered output (`renderedDOM`).\n    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n  } else if (!!template) {\n    // When no style is left in the template, parts will be broken as a\n    // result. To fix this, we put back the style node ShadyCSS removed\n    // and then tell lit to remove that node from the template.\n    // There can be no style in the template in 2 cases (1) when Shady DOM\n    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n    // is in use ShadyCSS removes the style if it contains no content.\n    // NOTE, ShadyCSS creates its own style so we can safely add/remove\n    // `condensedStyle` here.\n    content.insertBefore(condensedStyle, content.firstChild);\n    const removes = new Set();\n    removes.add(condensedStyle);\n    removeNodesFromTemplate(template, removes);\n  }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\n\n\nconst render = (result, container, options) => {\n  if (!options || typeof options !== 'object' || !options.scopeName) {\n    throw new Error('The `scopeName` option is required.');\n  }\n\n  const scopeName = options.scopeName;\n  const hasRendered = parts.has(container);\n  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11\n  /* Node.DOCUMENT_FRAGMENT_NODE */\n  && !!container.host; // Handle first render to a scope specially...\n\n  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single\n  // fragment that is reused since nested renders can occur synchronously.\n\n  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n  render$1(result, renderContainer, Object.assign({\n    templateFactory: shadyTemplateFactory(scopeName)\n  }, options)); // When performing first scope render,\n  // (1) We've rendered into a fragment so that there's a chance to\n  // `prepareTemplateStyles` before sub-elements hit the DOM\n  // (which might cause them to render based on a common pattern of\n  // rendering in a custom element's `connectedCallback`);\n  // (2) Scope the template with ShadyCSS one time only for this scope.\n  // (3) Render the fragment into the container and make sure the\n  // container knows its `part` is the one we just rendered. This ensures\n  // DOM will be re-used on subsequent renders.\n\n  if (firstScopeRender) {\n    const part = parts.get(renderContainer);\n    parts.delete(renderContainer); // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n    // that should apply to `renderContainer` even if the rendered value is\n    // not a TemplateInstance. However, it will only insert scoped styles\n    // into the document if `prepareTemplateStyles` has already been called\n    // for the given scope name.\n\n    const template = part.value instanceof TemplateInstance ? part.value.template : undefined;\n    prepareTemplateStyles(scopeName, renderContainer, template);\n    removeNodes(container, container.firstChild);\n    container.appendChild(renderContainer);\n    parts.set(container, part);\n  } // After elements have hit the DOM, update styling if this is the\n  // initial render to this container.\n  // This is needed whenever dynamic changes are made so it would be\n  // safest to do every render; however, this would regress performance\n  // so we leave it up to the user to call `ShadyCSS.styleElement`\n  // for dynamic changes.\n\n\n  if (!hasRendered && needsScoping) {\n    window.ShadyCSS.styleElement(container.host);\n  }\n};\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\nvar _a$b;\n/**\n * Use this module if you want to create your own base class extending\n * [[UpdatingElement]].\n * @packageDocumentation\n */\n\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n\n\nwindow.JSCompiler_renameProperty = (prop, _obj) => prop;\n\nconst defaultConverter = {\n  toAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        return value ? '' : null;\n\n      case Object:\n      case Array:\n        // if the value is `null` or `undefined` pass this through\n        // to allow removing/no change behavior.\n        return value == null ? value : JSON.stringify(value);\n    }\n\n    return value;\n  },\n\n  fromAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        return value !== null;\n\n      case Number:\n        return value === null ? null : Number(value);\n\n      case Object:\n      case Array:\n        // Type assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n        return JSON.parse(value);\n    }\n\n    return value;\n  }\n\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\n\nconst notEqual = (value, old) => {\n  // This ensures (old==NaN, value==NaN) always returns false\n  return old !== value && (old === old || value === value);\n};\n\nconst defaultPropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual\n};\nconst STATE_HAS_UPDATED = 1;\nconst STATE_UPDATE_REQUESTED = 1 << 2;\nconst STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\nconst STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\n\nconst finalized = 'finalized';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n * @noInheritDoc\n */\n\nclass UpdatingElement extends HTMLElement {\n  constructor() {\n    super();\n    this.initialize();\n  }\n  /**\n   * Returns a list of attributes corresponding to the registered properties.\n   * @nocollapse\n   */\n\n\n  static get observedAttributes() {\n    // note: piggy backing on this to ensure we're finalized.\n    this.finalize();\n    const attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n\n    this._classProperties.forEach((v, p) => {\n      const attr = this._attributeNameForProperty(p, v);\n\n      if (attr !== undefined) {\n        this._attributeToPropertyMap.set(attr, p);\n\n        attributes.push(attr);\n      }\n    });\n\n    return attributes;\n  }\n  /**\n   * Ensures the private `_classProperties` property metadata is created.\n   * In addition to `finalize` this is also called in `createProperty` to\n   * ensure the `@property` decorator can add property metadata.\n   */\n\n  /** @nocollapse */\n\n\n  static _ensureClassProperties() {\n    // ensure private storage for property declarations.\n    if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {\n      this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.\n\n      const superProperties = Object.getPrototypeOf(this)._classProperties;\n\n      if (superProperties !== undefined) {\n        superProperties.forEach((v, k) => this._classProperties.set(k, v));\n      }\n    }\n  }\n  /**\n   * Creates a property accessor on the element prototype if one does not exist\n   * and stores a PropertyDeclaration for the property with the given options.\n   * The property setter calls the property's `hasChanged` property option\n   * or uses a strict identity check to determine whether or not to request\n   * an update.\n   *\n   * This method may be overridden to customize properties; however,\n   * when doing so, it's important to call `super.createProperty` to ensure\n   * the property is setup correctly. This method calls\n   * `getPropertyDescriptor` internally to get a descriptor to install.\n   * To customize what properties do when they are get or set, override\n   * `getPropertyDescriptor`. To customize the options for a property,\n   * implement `createProperty` like this:\n   *\n   * static createProperty(name, options) {\n   *   options = Object.assign(options, {myOption: true});\n   *   super.createProperty(name, options);\n   * }\n   *\n   * @nocollapse\n   */\n\n\n  static createProperty(name, options = defaultPropertyDeclaration) {\n    // Note, since this can be called by the `@property` decorator which\n    // is called before `finalize`, we ensure storage exists for property\n    // metadata.\n    this._ensureClassProperties();\n\n    this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since\n    // it would be lost otherwise and that would never be the user's intention;\n    // Instead, we expect users to call `requestUpdate` themselves from\n    // user-defined accessors. Note that if the super has an accessor we will\n    // still overwrite it\n\n\n    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\n      return;\n    }\n\n    const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n    const descriptor = this.getPropertyDescriptor(name, key, options);\n\n    if (descriptor !== undefined) {\n      Object.defineProperty(this.prototype, name, descriptor);\n    }\n  }\n  /**\n   * Returns a property descriptor to be defined on the given named property.\n   * If no descriptor is returned, the property will not become an accessor.\n   * For example,\n   *\n   *   class MyElement extends LitElement {\n   *     static getPropertyDescriptor(name, key, options) {\n   *       const defaultDescriptor =\n   *           super.getPropertyDescriptor(name, key, options);\n   *       const setter = defaultDescriptor.set;\n   *       return {\n   *         get: defaultDescriptor.get,\n   *         set(value) {\n   *           setter.call(this, value);\n   *           // custom action.\n   *         },\n   *         configurable: true,\n   *         enumerable: true\n   *       }\n   *     }\n   *   }\n   *\n   * @nocollapse\n   */\n\n\n  static getPropertyDescriptor(name, key, options) {\n    return {\n      // tslint:disable-next-line:no-any no symbol in index\n      get() {\n        return this[key];\n      },\n\n      set(value) {\n        const oldValue = this[name];\n        this[key] = value;\n        this.requestUpdateInternal(name, oldValue, options);\n      },\n\n      configurable: true,\n      enumerable: true\n    };\n  }\n  /**\n   * Returns the property options associated with the given property.\n   * These options are defined with a PropertyDeclaration via the `properties`\n   * object or the `@property` decorator and are registered in\n   * `createProperty(...)`.\n   *\n   * Note, this method should be considered \"final\" and not overridden. To\n   * customize the options for a given property, override `createProperty`.\n   *\n   * @nocollapse\n   * @final\n   */\n\n\n  static getPropertyOptions(name) {\n    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;\n  }\n  /**\n   * Creates property accessors for registered properties and ensures\n   * any superclasses are also finalized.\n   * @nocollapse\n   */\n\n\n  static finalize() {\n    // finalize any superclasses\n    const superCtor = Object.getPrototypeOf(this);\n\n    if (!superCtor.hasOwnProperty(finalized)) {\n      superCtor.finalize();\n    }\n\n    this[finalized] = true;\n\n    this._ensureClassProperties(); // initialize Map populated in observedAttributes\n\n\n    this._attributeToPropertyMap = new Map(); // make any properties\n    // Note, only process \"own\" properties since this element will inherit\n    // any properties defined on the superClass, and finalization ensures\n    // the entire prototype chain is finalized.\n\n    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n      const props = this.properties; // support symbols in properties (IE11 does not support this)\n\n      const propKeys = [...Object.getOwnPropertyNames(props), ...(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])]; // This for/of is ok because propKeys is an array\n\n      for (const p of propKeys) {\n        // note, use of `any` is due to TypeSript lack of support for symbol in\n        // index types\n        // tslint:disable-next-line:no-any no symbol in index\n        this.createProperty(p, props[p]);\n      }\n    }\n  }\n  /**\n   * Returns the property name for the given attribute `name`.\n   * @nocollapse\n   */\n\n\n  static _attributeNameForProperty(name, options) {\n    const attribute = options.attribute;\n    return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;\n  }\n  /**\n   * Returns true if a property should request an update.\n   * Called when a property value is set and uses the `hasChanged`\n   * option for the property if present or a strict identity check.\n   * @nocollapse\n   */\n\n\n  static _valueHasChanged(value, old, hasChanged = notEqual) {\n    return hasChanged(value, old);\n  }\n  /**\n   * Returns the property value for the given attribute value.\n   * Called via the `attributeChangedCallback` and uses the property's\n   * `converter` or `converter.fromAttribute` property option.\n   * @nocollapse\n   */\n\n\n  static _propertyValueFromAttribute(value, options) {\n    const type = options.type;\n    const converter = options.converter || defaultConverter;\n    const fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;\n    return fromAttribute ? fromAttribute(value, type) : value;\n  }\n  /**\n   * Returns the attribute value for the given property value. If this\n   * returns undefined, the property will *not* be reflected to an attribute.\n   * If this returns null, the attribute will be removed, otherwise the\n   * attribute will be set to the value.\n   * This uses the property's `reflect` and `type.toAttribute` property options.\n   * @nocollapse\n   */\n\n\n  static _propertyValueToAttribute(value, options) {\n    if (options.reflect === undefined) {\n      return;\n    }\n\n    const type = options.type;\n    const converter = options.converter;\n    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;\n    return toAttribute(value, type);\n  }\n  /**\n   * Performs element initialization. By default captures any pre-set values for\n   * registered properties.\n   */\n\n\n  initialize() {\n    this._updateState = 0;\n    this._updatePromise = new Promise(res => this._enableUpdatingResolver = res);\n    this._changedProperties = new Map();\n\n    this._saveInstanceProperties(); // ensures first update will be caught by an early access of\n    // `updateComplete`\n\n\n    this.requestUpdateInternal();\n  }\n  /**\n   * Fixes any properties set on the instance before upgrade time.\n   * Otherwise these would shadow the accessor and break these properties.\n   * The properties are stored in a Map which is played back after the\n   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n   * (<=41), properties created for native platform properties like (`id` or\n   * `name`) may not have default values set in the element constructor. On\n   * these browsers native properties appear on instances and therefore their\n   * default value will overwrite any element default (e.g. if the element sets\n   * this.id = 'id' in the constructor, the 'id' will become '' since this is\n   * the native platform default).\n   */\n\n\n  _saveInstanceProperties() {\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    this.constructor._classProperties.forEach((_v, p) => {\n      if (this.hasOwnProperty(p)) {\n        const value = this[p];\n        delete this[p];\n\n        if (!this._instanceProperties) {\n          this._instanceProperties = new Map();\n        }\n\n        this._instanceProperties.set(p, value);\n      }\n    });\n  }\n  /**\n   * Applies previously saved instance properties.\n   */\n\n\n  _applyInstanceProperties() {\n    // Use forEach so this works even if for/of loops are compiled to for loops\n    // expecting arrays\n    // tslint:disable-next-line:no-any\n    this._instanceProperties.forEach((v, p) => this[p] = v);\n\n    this._instanceProperties = undefined;\n  }\n\n  connectedCallback() {\n    // Ensure first connection completes an update. Updates cannot complete\n    // before connection.\n    this.enableUpdating();\n  }\n\n  enableUpdating() {\n    if (this._enableUpdatingResolver !== undefined) {\n      this._enableUpdatingResolver();\n\n      this._enableUpdatingResolver = undefined;\n    }\n  }\n  /**\n   * Allows for `super.disconnectedCallback()` in extensions while\n   * reserving the possibility of making non-breaking feature additions\n   * when disconnecting at some point in the future.\n   */\n\n\n  disconnectedCallback() {}\n  /**\n   * Synchronizes property values when attributes change.\n   */\n\n\n  attributeChangedCallback(name, old, value) {\n    if (old !== value) {\n      this._attributeToProperty(name, value);\n    }\n  }\n\n  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n    const ctor = this.constructor;\n\n    const attr = ctor._attributeNameForProperty(name, options);\n\n    if (attr !== undefined) {\n      const attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.\n\n\n      if (attrValue === undefined) {\n        return;\n      } // Track if the property is being reflected to avoid\n      // setting the property again via `attributeChangedCallback`. Note:\n      // 1. this takes advantage of the fact that the callback is synchronous.\n      // 2. will behave incorrectly if multiple attributes are in the reaction\n      // stack at time of calling. However, since we process attributes\n      // in `update` this should not be possible (or an extreme corner case\n      // that we'd like to discover).\n      // mark state reflecting\n\n\n      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\n\n      if (attrValue == null) {\n        this.removeAttribute(attr);\n      } else {\n        this.setAttribute(attr, attrValue);\n      } // mark state not reflecting\n\n\n      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\n    }\n  }\n\n  _attributeToProperty(name, value) {\n    // Use tracking info to avoid deserializing attribute value if it was\n    // just set from a property setter.\n    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\n      return;\n    }\n\n    const ctor = this.constructor; // Note, hint this as an `AttributeMap` so closure clearly understands\n    // the type; it has issues with tracking types through statics\n    // tslint:disable-next-line:no-unnecessary-type-assertion\n\n    const propName = ctor._attributeToPropertyMap.get(name);\n\n    if (propName !== undefined) {\n      const options = ctor.getPropertyOptions(propName); // mark state reflecting\n\n      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\n      this[propName] = // tslint:disable-next-line:no-any\n      ctor._propertyValueFromAttribute(value, options); // mark state not reflecting\n\n      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\n    }\n  }\n  /**\n   * This protected version of `requestUpdate` does not access or return the\n   * `updateComplete` promise. This promise can be overridden and is therefore\n   * not free to access.\n   */\n\n\n  requestUpdateInternal(name, oldValue, options) {\n    let shouldRequestUpdate = true; // If we have a property key, perform property update steps.\n\n    if (name !== undefined) {\n      const ctor = this.constructor;\n      options = options || ctor.getPropertyOptions(name);\n\n      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\n        if (!this._changedProperties.has(name)) {\n          this._changedProperties.set(name, oldValue);\n        } // Add to reflecting properties set.\n        // Note, it's important that every change has a chance to add the\n        // property to `_reflectingProperties`. This ensures setting\n        // attribute + property reflects correctly.\n\n\n        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {\n          if (this._reflectingProperties === undefined) {\n            this._reflectingProperties = new Map();\n          }\n\n          this._reflectingProperties.set(name, options);\n        }\n      } else {\n        // Abort the request if the property should not be considered changed.\n        shouldRequestUpdate = false;\n      }\n    }\n\n    if (!this._hasRequestedUpdate && shouldRequestUpdate) {\n      this._updatePromise = this._enqueueUpdate();\n    }\n  }\n  /**\n   * Requests an update which is processed asynchronously. This should\n   * be called when an element should update based on some state not triggered\n   * by setting a property. In this case, pass no arguments. It should also be\n   * called when manually implementing a property setter. In this case, pass the\n   * property `name` and `oldValue` to ensure that any configured property\n   * options are honored. Returns the `updateComplete` Promise which is resolved\n   * when the update completes.\n   *\n   * @param name {PropertyKey} (optional) name of requesting property\n   * @param oldValue {any} (optional) old value of requesting property\n   * @returns {Promise} A Promise that is resolved when the update completes.\n   */\n\n\n  requestUpdate(name, oldValue) {\n    this.requestUpdateInternal(name, oldValue);\n    return this.updateComplete;\n  }\n  /**\n   * Sets up the element to asynchronously update.\n   */\n\n\n  _enqueueUpdate() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2._updateState = _this2._updateState | STATE_UPDATE_REQUESTED;\n\n      try {\n        // Ensure any previous update has resolved before updating.\n        // This `await` also ensures that property changes are batched.\n        yield _this2._updatePromise;\n      } catch (e) {// Ignore any previous errors. We only care that the previous cycle is\n        // done. Any error should have been handled in the previous update.\n      }\n\n      const result = _this2.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to\n      // enable coordinating updates with a scheduler. Note, the result is\n      // checked to avoid delaying an additional microtask unless we need to.\n\n\n      if (result != null) {\n        yield result;\n      }\n\n      return !_this2._hasRequestedUpdate;\n    })();\n  }\n\n  get _hasRequestedUpdate() {\n    return this._updateState & STATE_UPDATE_REQUESTED;\n  }\n\n  get hasUpdated() {\n    return this._updateState & STATE_HAS_UPDATED;\n  }\n  /**\n   * Performs an element update. Note, if an exception is thrown during the\n   * update, `firstUpdated` and `updated` will not be called.\n   *\n   * You can override this method to change the timing of updates. If this\n   * method is overridden, `super.performUpdate()` must be called.\n   *\n   * For instance, to schedule updates to occur just before the next frame:\n   *\n   * ```\n   * protected async performUpdate(): Promise<unknown> {\n   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n   *   super.performUpdate();\n   * }\n   * ```\n   */\n\n\n  performUpdate() {\n    // Abort any update if one is not pending when this is called.\n    // This can happen if `performUpdate` is called early to \"flush\"\n    // the update.\n    if (!this._hasRequestedUpdate) {\n      return;\n    } // Mixin instance properties once, if they exist.\n\n\n    if (this._instanceProperties) {\n      this._applyInstanceProperties();\n    }\n\n    let shouldUpdate = false;\n    const changedProperties = this._changedProperties;\n\n    try {\n      shouldUpdate = this.shouldUpdate(changedProperties);\n\n      if (shouldUpdate) {\n        this.update(changedProperties);\n      } else {\n        this._markUpdated();\n      }\n    } catch (e) {\n      // Prevent `firstUpdated` and `updated` from running when there's an\n      // update exception.\n      shouldUpdate = false; // Ensure element can accept additional updates after an exception.\n\n      this._markUpdated();\n\n      throw e;\n    }\n\n    if (shouldUpdate) {\n      if (!(this._updateState & STATE_HAS_UPDATED)) {\n        this._updateState = this._updateState | STATE_HAS_UPDATED;\n        this.firstUpdated(changedProperties);\n      }\n\n      this.updated(changedProperties);\n    }\n  }\n\n  _markUpdated() {\n    this._changedProperties = new Map();\n    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\n  }\n  /**\n   * Returns a Promise that resolves when the element has completed updating.\n   * The Promise value is a boolean that is `true` if the element completed the\n   * update without triggering another update. The Promise result is `false` if\n   * a property was set inside `updated()`. If the Promise is rejected, an\n   * exception was thrown during the update.\n   *\n   * To await additional asynchronous work, override the `_getUpdateComplete`\n   * method. For example, it is sometimes useful to await a rendered element\n   * before fulfilling this Promise. To do this, first await\n   * `super._getUpdateComplete()`, then any subsequent state.\n   *\n   * @returns {Promise} The Promise returns a boolean that indicates if the\n   * update resolved without triggering another update.\n   */\n\n\n  get updateComplete() {\n    return this._getUpdateComplete();\n  }\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   *   class MyElement extends LitElement {\n   *     async _getUpdateComplete() {\n   *       await super._getUpdateComplete();\n   *       await this._myChild.updateComplete;\n   *     }\n   *   }\n   * @deprecated Override `getUpdateComplete()` instead for forward\n   *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.\n   */\n\n\n  _getUpdateComplete() {\n    return this.getUpdateComplete();\n  }\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   *   class MyElement extends LitElement {\n   *     async getUpdateComplete() {\n   *       await super.getUpdateComplete();\n   *       await this._myChild.updateComplete;\n   *     }\n   *   }\n   */\n\n\n  getUpdateComplete() {\n    return this._updatePromise;\n  }\n  /**\n   * Controls whether or not `update` should be called when the element requests\n   * an update. By default, this method always returns `true`, but this can be\n   * customized to control when to update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n\n\n  shouldUpdate(_changedProperties) {\n    return true;\n  }\n  /**\n   * Updates the element. This method reflects property values to attributes.\n   * It can be overridden to render and keep updated element DOM.\n   * Setting properties inside this method will *not* trigger\n   * another update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n\n\n  update(_changedProperties) {\n    if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {\n      // Use forEach so this works even if for/of loops are compiled to for\n      // loops expecting arrays\n      this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));\n\n      this._reflectingProperties = undefined;\n    }\n\n    this._markUpdated();\n  }\n  /**\n   * Invoked whenever the element is updated. Implement to perform\n   * post-updating tasks via DOM APIs, for example, focusing an element.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n\n\n  updated(_changedProperties) {}\n  /**\n   * Invoked when the element is first updated. Implement to perform one time\n   * work on the element after update.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   */\n\n\n  firstUpdated(_changedProperties) {}\n\n}\n\n_a$b = finalized;\n/**\n * Marks class as having finished creating properties.\n */\n\nUpdatingElement[_a$b] = true;\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nconst standardProperty = (options, element) => {\n  // When decorating an accessor, pass it through and add property metadata.\n  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n  // stomp over the user's accessor.\n  if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {\n    return Object.assign(Object.assign({}, element), {\n      finisher(clazz) {\n        clazz.createProperty(element.key, options);\n      }\n\n    });\n  } else {\n    // createProperty() takes care of defining the property, but we still\n    // must return some kind of descriptor, so return a descriptor for an\n    // unused prototype field. The finisher calls createProperty().\n    return {\n      kind: 'field',\n      key: Symbol(),\n      placement: 'own',\n      descriptor: {},\n\n      // When @babel/plugin-proposal-decorators implements initializers,\n      // do this instead of the initializer below. See:\n      // https://github.com/babel/babel/issues/9260 extras: [\n      //   {\n      //     kind: 'initializer',\n      //     placement: 'own',\n      //     initializer: descriptor.initializer,\n      //   }\n      // ],\n      initializer() {\n        if (typeof element.initializer === 'function') {\n          this[element.key] = element.initializer.call(this);\n        }\n      },\n\n      finisher(clazz) {\n        clazz.createProperty(element.key, options);\n      }\n\n    };\n  }\n};\n\nconst legacyProperty = (options, proto, name) => {\n  proto.constructor.createProperty(name, options);\n};\n/**\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A [[`PropertyDeclaration`]] may optionally be\n * supplied to configure property features.\n *\n * This decorator should only be used for public fields. Private or protected\n * fields should use the [[`internalProperty`]] decorator.\n *\n * @example\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\n\n\nfunction property(options) {\n  // tslint:disable-next-line:no-any decorator\n  return (protoOrDescriptor, name) => name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);\n}\n/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */\n\n\nconst supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) && 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;\nconst constructionToken = Symbol();\n\nclass CSSResult {\n  constructor(cssText, safeToken) {\n    if (safeToken !== constructionToken) {\n      throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');\n    }\n\n    this.cssText = cssText;\n  } // Note, this is a getter so that it's lazy. In practice, this means\n  // stylesheets are not created until the first element instance is made.\n\n\n  get styleSheet() {\n    if (this._styleSheet === undefined) {\n      // Note, if `supportsAdoptingStyleSheets` is true then we assume\n      // CSSStyleSheet is constructable.\n      if (supportsAdoptingStyleSheets) {\n        this._styleSheet = new CSSStyleSheet();\n\n        this._styleSheet.replaceSync(this.cssText);\n      } else {\n        this._styleSheet = null;\n      }\n    }\n\n    return this._styleSheet;\n  }\n\n  toString() {\n    return this.cssText;\n  }\n\n}\n/**\n * Wrap a value for interpolation in a [[`css`]] tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\n\n\nconst unsafeCSS = value => {\n  return new CSSResult(String(value), constructionToken);\n};\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n\n\n(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.5.1');\n/**\n * Sentinal value used to avoid calling lit-html's render function when\n * subclasses do not implement `render`\n */\n\nconst renderNotImplemented = {};\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the [[`properties`]] property or the [[`property`]] decorator.\n */\n\nclass LitElement extends UpdatingElement {\n  /**\n   * Return the array of styles to apply to the element.\n   * Override this method to integrate into a style management system.\n   *\n   * @nocollapse\n   */\n  static getStyles() {\n    return this.styles;\n  }\n  /** @nocollapse */\n\n\n  static _getUniqueStyles() {\n    // Only gather styles once per class\n    if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {\n      return;\n    } // Take care not to call `this.getStyles()` multiple times since this\n    // generates new CSSResults each time.\n    // TODO(sorvell): Since we do not cache CSSResults by input, any\n    // shared styles will generate new stylesheet objects, which is wasteful.\n    // This should be addressed when a browser ships constructable\n    // stylesheets.\n\n\n    const userStyles = this.getStyles();\n\n    if (Array.isArray(userStyles)) {\n      // De-duplicate styles preserving the _last_ instance in the set.\n      // This is a performance optimization to avoid duplicated styles that can\n      // occur especially when composing via subclassing.\n      // The last item is kept to try to preserve the cascade order with the\n      // assumption that it's most important that last added styles override\n      // previous styles.\n      const addStyles = (styles, set) => styles.reduceRight((set, s) => // Note: On IE set.add() does not return the set\n      Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set); // Array.from does not work on Set in IE, otherwise return\n      // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\n\n\n      const set = addStyles(userStyles, new Set());\n      const styles = [];\n      set.forEach(v => styles.unshift(v));\n      this._styles = styles;\n    } else {\n      this._styles = userStyles === undefined ? [] : [userStyles];\n    } // Ensure that there are no invalid CSSStyleSheet instances here. They are\n    // invalid in two conditions.\n    // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but\n    //     this is impossible to check except via .replaceSync or use\n    // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is\n    //     false)\n\n\n    this._styles = this._styles.map(s => {\n      if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {\n        // Flatten the cssText from the passed constructible stylesheet (or\n        // undetectable non-constructible stylesheet). The user might have\n        // expected to update their stylesheets over time, but the alternative\n        // is a crash.\n        const cssText = Array.prototype.slice.call(s.cssRules).reduce((css, rule) => css + rule.cssText, '');\n        return unsafeCSS(cssText);\n      }\n\n      return s;\n    });\n  }\n  /**\n   * Performs element initialization. By default this calls\n   * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and\n   * captures any pre-set values for registered properties.\n   */\n\n\n  initialize() {\n    super.initialize();\n\n    this.constructor._getUniqueStyles();\n\n    this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n    // element's getRootNode(). While this could be done, we're choosing not to\n    // support this now since it would require different logic around de-duping.\n\n    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n      this.adoptStyles();\n    }\n  }\n  /**\n   * Returns the node into which the element should render and by default\n   * creates and returns an open shadowRoot. Implement to customize where the\n   * element's DOM is rendered. For example, to render into the element's\n   * childNodes, return `this`.\n   * @returns {Element|DocumentFragment} Returns a node into which to render.\n   */\n\n\n  createRenderRoot() {\n    return this.attachShadow(this.constructor.shadowRootOptions);\n  }\n  /**\n   * Applies styling to the element shadowRoot using the [[`styles`]]\n   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n   * available and will fallback otherwise. When Shadow DOM is polyfilled,\n   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n   * is available but `adoptedStyleSheets` is not, styles are appended to the\n   * end of the `shadowRoot` to [mimic spec\n   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n   */\n\n\n  adoptStyles() {\n    const styles = this.constructor._styles;\n\n    if (styles.length === 0) {\n      return;\n    } // There are three separate cases here based on Shadow DOM support.\n    // (1) shadowRoot polyfilled: use ShadyCSS\n    // (2) shadowRoot.adoptedStyleSheets available: use it\n    // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n    // rendering\n\n\n    if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(s => s.cssText), this.localName);\n    } else if (supportsAdoptingStyleSheets) {\n      this.renderRoot.adoptedStyleSheets = styles.map(s => s instanceof CSSStyleSheet ? s : s.styleSheet);\n    } else {\n      // This must be done after rendering so the actual style insertion is done\n      // in `update`.\n      this._needsShimAdoptedStyleSheets = true;\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback(); // Note, first update/render handles styleElement so we only call this if\n    // connected after first update.\n\n    if (this.hasUpdated && window.ShadyCSS !== undefined) {\n      window.ShadyCSS.styleElement(this);\n    }\n  }\n  /**\n   * Updates the element. This method reflects property values to attributes\n   * and calls `render` to render DOM via lit-html. Setting properties inside\n   * this method will *not* trigger another update.\n   * @param _changedProperties Map of changed properties with old values\n   */\n\n\n  update(changedProperties) {\n    // Setting properties in `render` should not trigger an update. Since\n    // updates are allowed after super.update, it's important to call `render`\n    // before that.\n    const templateResult = this.render();\n    super.update(changedProperties); // If render is not implemented by the component, don't call lit-html render\n\n    if (templateResult !== renderNotImplemented) {\n      this.constructor.render(templateResult, this.renderRoot, {\n        scopeName: this.localName,\n        eventContext: this\n      });\n    } // When native Shadow DOM is used but adoptedStyles are not supported,\n    // insert styling after rendering to ensure adoptedStyles have highest\n    // priority.\n\n\n    if (this._needsShimAdoptedStyleSheets) {\n      this._needsShimAdoptedStyleSheets = false;\n\n      this.constructor._styles.forEach(s => {\n        const style = document.createElement('style');\n        style.textContent = s.cssText;\n        this.renderRoot.appendChild(style);\n      });\n    }\n  }\n  /**\n   * Invoked on each update to perform rendering tasks. This method may return\n   * any value renderable by lit-html's `NodePart` - typically a\n   * `TemplateResult`. Setting properties inside this method will *not* trigger\n   * the element to update.\n   */\n\n\n  render() {\n    return renderNotImplemented;\n  }\n\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See updating-element.ts for more information.\n */\n\n\nLitElement['finalized'] = true;\n/**\n * Reference to the underlying library method used to render the element's\n * DOM. By default, points to the `render` method from lit-html's shady-render\n * module.\n *\n * **Most users will never need to touch this property.**\n *\n * This  property should not be confused with the `render` instance method,\n * which should be overridden to define a template for the element.\n *\n * Advanced users creating a new base class based on LitElement can override\n * this property to point to a custom render method with a signature that\n * matches [shady-render's `render`\n * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).\n *\n * @nocollapse\n */\n\nLitElement.render = render;\n/** @nocollapse */\n\nLitElement.shadowRootOptions = {\n  mode: 'open'\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// NOTE(cdata): The HAS_WEBXR_* constants can be enabled in Chrome by turning on\n// the appropriate flags. However, just because we have the API does not\n// guarantee that AR will work.\n\nconst HAS_WEBXR_DEVICE_API = navigator.xr != null && self.XRSession != null && navigator.xr.isSessionSupported != null;\nconst HAS_WEBXR_HIT_TEST_API = HAS_WEBXR_DEVICE_API && self.XRSession.prototype.requestHitTestSource;\nconst HAS_RESIZE_OBSERVER = self.ResizeObserver != null;\nconst HAS_INTERSECTION_OBSERVER = self.IntersectionObserver != null;\nconst IS_WEBXR_AR_CANDIDATE = HAS_WEBXR_HIT_TEST_API;\n\n(() => {\n  const userAgent = navigator.userAgent || navigator.vendor || self.opera;\n  let check = false; // eslint-disable-next-line\n\n  if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(userAgent.substr(0, 4))) {\n    check = true;\n  }\n\n  return check;\n})();\n\n/\\bCrOS\\b/.test(navigator.userAgent);\nconst IS_ANDROID = /android/i.test(navigator.userAgent); // Prior to iOS 13, detecting iOS Safari was relatively straight-forward.\n// As of iOS 13, Safari on iPad (in its default configuration) reports the same\n// user-agent string as Safari on desktop MacOS. Strictly speaking, we only care\n// about iOS for the purposes if selecting for cases where Quick Look is known\n// to be supported. However, for API correctness purposes, we must rely on\n// known, detectable signals to distinguish iOS Safari from MacOS Safari. At the\n// time of this writing, there are no non-iOS/iPadOS Apple devices with\n// multi-touch displays.\n// @see https://stackoverflow.com/questions/57765958/how-to-detect-ipad-and-ipad-os-version-in-ios-13-and-up\n// @see https://forums.developer.apple.com/thread/119186\n// @see https://github.com/google/model-viewer/issues/758\n\nconst IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;\n\nconst IS_AR_QUICKLOOK_CANDIDATE = (() => {\n  const tempAnchor = document.createElement('a');\n  return Boolean(tempAnchor.relList && tempAnchor.relList.supports && tempAnchor.relList.supports('ar'));\n})(); // @see https://developer.chrome.com/multidevice/user-agent\n\n\n/Safari\\//.test(navigator.userAgent);\nconst IS_FIREFOX = /firefox/i.test(navigator.userAgent);\nconst IS_OCULUS = /OculusBrowser/.test(navigator.userAgent);\nIS_IOS && /CriOS\\//.test(navigator.userAgent);\nconst IS_SCENEVIEWER_CANDIDATE = IS_ANDROID && !IS_FIREFOX && !IS_OCULUS;\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar CloseIcon = `\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" fill=\"#000000\">\n    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components -->\n    <defs>\n      <filter id=\"drop-shadow\" x=\"-100%\" y=\"-100%\" width=\"300%\" height=\"300%\">\n        <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"1\"/>\n        <feOffset dx=\"0\" dy=\"0\" result=\"offsetblur\"/>\n        <feFlood flood-color=\"#000000\"/>\n        <feComposite in2=\"offsetblur\" operator=\"in\"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in=\"SourceGraphic\"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter=\"url(#drop-shadow)\" d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"/>\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n</svg>`;\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar ControlsPrompt = `\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"36\">\n    <defs>\n        <path id=\"A\" d=\"M.001.232h24.997V36H.001z\" />\n    </defs>\n    <g transform=\"translate(-11 -4)\" fill=\"none\" fill-rule=\"evenodd\">\n        <path fill-opacity=\"0\" fill=\"#fff\" d=\"M0 0h44v44H0z\" />\n        <g transform=\"translate(11 3)\">\n            <path d=\"M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z\" fill-opacity=\".5\" fill=\"#e4e4e4\" />\n            <path d=\"M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91\" fill-opacity=\".6\" fill=\"#000\" />\n            <path d=\"M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z\" fill=\"#fff\" />\n            <g transform=\"translate(0 .769)\">\n                <mask id=\"B\" fill=\"#fff\">\n                    <use xlink:href=\"#A\" />\n                </mask>\n                <path d=\"M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325\" fill-opacity=\".05\" fill=\"#000\" mask=\"url(#B)\" />\n            </g>\n        </g>\n    </g>\n</svg>`;\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar ARGlyph = `\n<svg version=\"1.1\" id=\"view_x5F_in_x5F_AR_x5F_icon\"\n\t xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"24px\" height=\"24px\"\n\t viewBox=\"0 0 24 24\" enable-background=\"new 0 0 24 24\" xml:space=\"preserve\">\n<rect id=\"Bounding_Box\" x=\"0\" y=\"0\" fill=\"none\" width=\"24\" height=\"24\"/>\n<g id=\"Art_layer\">\n\t<path d=\"M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z\"/>\n\t<path d=\"M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z\"/>\n\t<path d=\"M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z\"/>\n\t<path d=\"M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z\"/>\n\t<g>\n\t\t<path d=\"M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z\"/>\n\t</g>\n</g>\n</svg>`;\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar.hide {\n  transition: opacity 0.3s 1s;\n  opacity: 0;\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class=\"container\">\n  <div class=\"userInput\" tabindex=\"0\" role=\"img\"\n      aria-label=\"A depiction of a 3D model\"\n      aria-live=\"polite\">\n      <div class=\"slot canvas\">\n        <slot name=\"canvas\">\n          <canvas></canvas>\n        </slot>\n      </div>\n  </div>\n\n  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS -->\n  <div class=\"slot poster\">\n    <slot name=\"poster\">\n      <button type=\"button\" id=\"default-poster\" aria-hidden=\"true\" aria-label=\"Activate to view in 3D!\"></button>\n    </slot>\n  </div>\n\n  <div class=\"slot ar-button\">\n    <slot name=\"ar-button\">\n      <a id=\"default-ar-button\" part=\"default-ar-button\" class=\"fab\"\n          tabindex=\"2\"\n          aria-label=\"View this 3D model up close\">\n        ${ARGlyph}\n      </a>\n    </slot>\n  </div>\n\n  <div class=\"slot interaction-prompt\">\n    <div class=\"animated-container\">\n      <slot name=\"interaction-prompt\" aria-hidden=\"true\">\n        ${ControlsPrompt}\n      </slot>\n    </div>\n  </div>\n\n  <div class=\"slot default\">\n    <slot></slot>\n\n    <div class=\"slot progress-bar\">\n      <slot name=\"progress-bar\">\n        <div id=\"default-progress-bar\" aria-hidden=\"true\">\n          <div class=\"mask\" part=\"default-progress-mask\"></div>\n          <div class=\"bar\" part=\"default-progress-bar\"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class=\"slot exit-webxr-ar-button\">\n      <slot name=\"exit-webxr-ar-button\">\n        <a id=\"default-exit-webxr-ar-button\" part=\"default-exit-webxr-ar-button\"\n            tabindex=\"3\"\n            aria-label=\"Exit AR\"\n            aria-hidden=\"true\">\n          ${CloseIcon}\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>`;\n\nconst makeTemplate = tagName => {\n  const clone = document.createElement('template');\n  clone.innerHTML = template.innerHTML;\n\n  if (window.ShadyCSS) {\n    window.ShadyCSS.prepareTemplate(clone, tagName);\n  }\n\n  return clone;\n};\n/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\n\n\nconst REVISION = '131';\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst FlatShading = 1;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst CubeUVRefractionMapping = 307;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedShort565Type = 1019;\nconst UnsignedInt248Type = 1020;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst RGBEFormat = RGBAFormat;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\nconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\nconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\nconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\nconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\nconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\nconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\nconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\nconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\nconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\nconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\nconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\nconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\nconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\nconst GammaEncoding = 3007;\nconst RGBEEncoding = 3002;\nconst LogLuvEncoding = 3003;\nconst RGBM7Encoding = 3004;\nconst RGBM16Encoding = 3005;\nconst RGBDEncoding = 3006;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\nconst KeepStencilOp = 7680;\nconst AlwaysStencilFunc = 519;\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst GLSL3 = '300 es';\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n  addEventListener(type, listener) {\n    if (this._listeners === undefined) this._listeners = {};\n    const listeners = this._listeners;\n\n    if (listeners[type] === undefined) {\n      listeners[type] = [];\n    }\n\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n\n  hasEventListener(type, listener) {\n    if (this._listeners === undefined) return false;\n    const listeners = this._listeners;\n    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n  }\n\n  removeEventListener(type, listener) {\n    if (this._listeners === undefined) return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n\n    if (listenerArray !== undefined) {\n      const index = listenerArray.indexOf(listener);\n\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n\n  dispatchEvent(event) {\n    if (this._listeners === undefined) return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n\n    if (listenerArray !== undefined) {\n      event.target = this; // Make a copy, in case listeners are removed while iterating.\n\n      const array = listenerArray.slice(0);\n\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n\n      event.target = null;\n    }\n  }\n\n}\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nlet _seed = 1234567;\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\nfunction generateUUID() {\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n  return uuid.toUpperCase();\n}\n\nfunction clamp$1(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n} // compute euclidian modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\n\n\nfunction euclideanModulo(n, m) {\n  return (n % m + m) % m;\n} // Linear mapping from range <a1, a2> to range <b1, b2>\n\n\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n} // https://en.wikipedia.org/wiki/Linear_interpolation\n\n\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n\n\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n} // https://www.desmos.com/calculator/vcsjnyz7x4\n\n\nfunction pingpong(x, length = 1) {\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n} // http://en.wikipedia.org/wiki/Smoothstep\n\n\nfunction smoothstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * (3 - 2 * x);\n}\n\nfunction smootherstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n} // Random integer from <low, high> interval\n\n\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n} // Random float from <low, high> interval\n\n\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n} // Random float from <-range/2, range/2> interval\n\n\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n} // Deterministic pseudo-random float in the interval [ 0, 1 ]\n\n\nfunction seededRandom(s) {\n  if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm\n\n  _seed = _seed * 16807 % 2147483647;\n  return (_seed - 1) / 2147483646;\n}\n\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\n\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\n\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === 0 && value !== 0;\n}\n\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\n\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n  // rotations are applied to the axes in the order specified by 'order'\n  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n  // angles are in radians\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n\n  switch (order) {\n    case 'XYX':\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n\n    case 'YZY':\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n\n    case 'ZXZ':\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n\n    case 'XZX':\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n\n    case 'YXY':\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n\n    case 'ZYZ':\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n\n    default:\n      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);\n  }\n}\n\nvar MathUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  DEG2RAD: DEG2RAD,\n  RAD2DEG: RAD2DEG,\n  generateUUID: generateUUID,\n  clamp: clamp$1,\n  euclideanModulo: euclideanModulo,\n  mapLinear: mapLinear,\n  inverseLerp: inverseLerp,\n  lerp: lerp,\n  damp: damp,\n  pingpong: pingpong,\n  smoothstep: smoothstep,\n  smootherstep: smootherstep,\n  randInt: randInt,\n  randFloat: randFloat,\n  randFloatSpread: randFloatSpread,\n  seededRandom: seededRandom,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  isPowerOfTwo: isPowerOfTwo,\n  ceilPowerOfTwo: ceilPowerOfTwo,\n  floorPowerOfTwo: floorPowerOfTwo,\n  setQuaternionFromProperEuler: setQuaternionFromProperEuler\n});\n\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  get width() {\n    return this.x;\n  }\n\n  set width(value) {\n    this.x = value;\n  }\n\n  get height() {\n    return this.y;\n  }\n\n  set height(value) {\n    this.y = value;\n  }\n\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  }\n\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  applyMatrix3(m) {\n    const x = this.x,\n          y = this.y;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n    return this;\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  angle() {\n    // computes the angle in radians with respect to the positive x-axis\n    const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n          dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    return this;\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y;\n  }\n\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    return this;\n  }\n\n  rotateAround(center, angle) {\n    const c = Math.cos(angle),\n          s = Math.sin(angle);\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  }\n\n}\n\nVector2.prototype.isVector2 = true;\n\nclass Matrix3 {\n  constructor() {\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (arguments.length > 0) {\n      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n    }\n  }\n\n  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n    return this;\n  }\n\n  identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  }\n\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    return this;\n  }\n\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n\n  setFromMatrix4(m) {\n    const me = m.elements;\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n    return this;\n  }\n\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0],\n          a12 = ae[3],\n          a13 = ae[6];\n    const a21 = ae[1],\n          a22 = ae[4],\n          a23 = ae[7];\n    const a31 = ae[2],\n          a32 = ae[5],\n          a33 = ae[8];\n    const b11 = be[0],\n          b12 = be[3],\n          b13 = be[6];\n    const b21 = be[1],\n          b22 = be[4],\n          b23 = be[7];\n    const b31 = be[2],\n          b32 = be[5],\n          b33 = be[8];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n    return this;\n  }\n\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  }\n\n  determinant() {\n    const te = this.elements;\n    const a = te[0],\n          b = te[1],\n          c = te[2],\n          d = te[3],\n          e = te[4],\n          f = te[5],\n          g = te[6],\n          h = te[7],\n          i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  }\n\n  invert() {\n    const te = this.elements,\n          n11 = te[0],\n          n21 = te[1],\n          n31 = te[2],\n          n12 = te[3],\n          n22 = te[4],\n          n32 = te[5],\n          n13 = te[6],\n          n23 = te[7],\n          n33 = te[8],\n          t11 = n33 * n22 - n32 * n23,\n          t12 = n32 * n13 - n33 * n12,\n          t13 = n23 * n12 - n22 * n13,\n          det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return this;\n  }\n\n  transpose() {\n    let tmp;\n    const m = this.elements;\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n    return this;\n  }\n\n  getNormalMatrix(matrix4) {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n\n  transposeIntoArray(r) {\n    const m = this.elements;\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n    return this;\n  }\n\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n    return this;\n  }\n\n  scale(sx, sy) {\n    const te = this.elements;\n    te[0] *= sx;\n    te[3] *= sx;\n    te[6] *= sx;\n    te[1] *= sy;\n    te[4] *= sy;\n    te[7] *= sy;\n    return this;\n  }\n\n  rotate(theta) {\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    const te = this.elements;\n    const a11 = te[0],\n          a12 = te[3],\n          a13 = te[6];\n    const a21 = te[1],\n          a22 = te[4],\n          a23 = te[7];\n    te[0] = c * a11 + s * a21;\n    te[3] = c * a12 + s * a22;\n    te[6] = c * a13 + s * a23;\n    te[1] = -s * a11 + c * a21;\n    te[4] = -s * a12 + c * a22;\n    te[7] = -s * a13 + c * a23;\n    return this;\n  }\n\n  translate(tx, ty) {\n    const te = this.elements;\n    te[0] += tx * te[2];\n    te[3] += tx * te[5];\n    te[6] += tx * te[8];\n    te[1] += ty * te[2];\n    te[4] += ty * te[5];\n    te[7] += ty * te[8];\n    return this;\n  }\n\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n\n    for (let i = 0; i < 9; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n\n}\n\nMatrix3.prototype.isMatrix3 = true;\n\nlet _canvas;\n\nclass ImageUtils {\n  static getDataURL(image) {\n    if (/^data:/i.test(image.src)) {\n      return image.src;\n    }\n\n    if (typeof HTMLCanvasElement == 'undefined') {\n      return image.src;\n    }\n\n    let canvas;\n\n    if (image instanceof HTMLCanvasElement) {\n      canvas = image;\n    } else {\n      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n      _canvas.width = image.width;\n      _canvas.height = image.height;\n\n      const context = _canvas.getContext('2d');\n\n      if (image instanceof ImageData) {\n        context.putImageData(image, 0, 0);\n      } else {\n        context.drawImage(image, 0, 0, image.width, image.height);\n      }\n\n      canvas = _canvas;\n    }\n\n    if (canvas.width > 2048 || canvas.height > 2048) {\n      console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);\n      return canvas.toDataURL('image/jpeg', 0.6);\n    } else {\n      return canvas.toDataURL('image/png');\n    }\n  }\n\n}\n\nlet textureId = 0;\n\nclass Texture$1 extends EventDispatcher {\n  constructor(image = Texture$1.DEFAULT_IMAGE, mapping = Texture$1.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: textureId++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.image = image;\n    this.mipmaps = [];\n    this.mapping = mapping;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.anisotropy = anisotropy;\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n    this.encoding = encoding;\n    this.version = 0;\n    this.onUpdate = null;\n    this.isRenderTargetTexture = false;\n  }\n\n  updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n    return this;\n  }\n\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    const output = {\n      metadata: {\n        version: 4.5,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n\n    if (this.image !== undefined) {\n      // TODO: Move to THREE.Image\n      const image = this.image;\n\n      if (image.uuid === undefined) {\n        image.uuid = generateUUID(); // UGH\n      }\n\n      if (!isRootObject && meta.images[image.uuid] === undefined) {\n        let url;\n\n        if (Array.isArray(image)) {\n          // process array of images e.g. CubeTexture\n          url = [];\n\n          for (let i = 0, l = image.length; i < l; i++) {\n            // check cube texture with data textures\n            if (image[i].isDataTexture) {\n              url.push(serializeImage(image[i].image));\n            } else {\n              url.push(serializeImage(image[i]));\n            }\n          }\n        } else {\n          // process single image\n          url = serializeImage(image);\n        }\n\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url: url\n        };\n      }\n\n      output.image = image.uuid;\n    }\n\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n\n    return output;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n}\n\nTexture$1.DEFAULT_IMAGE = undefined;\nTexture$1.DEFAULT_MAPPING = UVMapping;\nTexture$1.prototype.isTexture = true;\n\nfunction serializeImage(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    // default images\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      // images of DataTexture\n      return {\n        data: Array.prototype.slice.call(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name\n      };\n    } else {\n      console.warn('THREE.Texture: Unable to serialize Texture.');\n      return {};\n    }\n  }\n}\n\nclass Vector4 {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  get width() {\n    return this.z;\n  }\n\n  set width(value) {\n    this.z = value;\n  }\n\n  get height() {\n    return this.w;\n  }\n\n  set height(value) {\n    this.w = value;\n  }\n\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n\n  setW(w) {\n    this.w = w;\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      case 2:\n        this.z = value;\n        break;\n\n      case 3:\n        this.w = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      case 2:\n        return this.z;\n\n      case 3:\n        return this.w;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== undefined ? v.w : 1;\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  }\n\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  }\n\n  applyMatrix4(m) {\n    const x = this.x,\n          y = this.y,\n          z = this.z,\n          w = this.w;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  setAxisAngleFromQuaternion(q) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n    // q is assumed to be normalized\n    this.w = 2 * Math.acos(q.w);\n    const s = Math.sqrt(1 - q.w * q.w);\n\n    if (s < 0.0001) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n\n    return this;\n  }\n\n  setAxisAngleFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    let angle, x, y, z; // variables for result\n\n    const epsilon = 0.01,\n          // margin to allow for rounding errors\n    epsilon2 = 0.1,\n          // margin to distinguish between 0 and 180 degrees\n    te = m.elements,\n          m11 = te[0],\n          m12 = te[4],\n          m13 = te[8],\n          m21 = te[1],\n          m22 = te[5],\n          m23 = te[9],\n          m31 = te[2],\n          m32 = te[6],\n          m33 = te[10];\n\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      // singularity found\n      // first check for identity matrix which must have +1 for all terms\n      // in leading diagonal and zero in other terms\n      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        // this singularity is identity matrix so angle = 0\n        this.set(1, 0, 0, 0);\n        return this; // zero angle, arbitrary axis\n      } // otherwise this singularity is angle = 180\n\n\n      angle = Math.PI;\n      const xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + 1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / 4;\n      const yz = (m23 + m32) / 4;\n\n      if (xx > yy && xx > zz) {\n        // m11 is the largest diagonal term\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        // m22 is the largest diagonal term\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        // m33 is the largest diagonal term so base result on this\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n\n      this.set(x, y, z, angle);\n      return this; // return 180 deg rotation\n    } // as we have reached here there are no singularities so we can handle normally\n\n\n    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be\n    // caught by singularity test above, but I've left it in just in case\n\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    this.w = Math.min(this.w, v.w);\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    this.w = Math.max(min.w, Math.min(max.w, this.w));\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    this.w = Math.max(minVal, Math.min(maxVal, this.w));\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n    return this;\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    return this;\n  }\n\n}\n\nVector4.prototype.isVector4 = true;\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\n\nclass WebGLRenderTarget extends EventDispatcher {\n  constructor(width, height, options = {}) {\n    super();\n    this.width = width;\n    this.height = height;\n    this.depth = 1;\n    this.scissor = new Vector4(0, 0, width, height);\n    this.scissorTest = false;\n    this.viewport = new Vector4(0, 0, width, height);\n    this.texture = new Texture$1(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n    this.texture.isRenderTargetTexture = true;\n    this.texture.image = {\n      width: width,\n      height: height,\n      depth: 1\n    };\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n  }\n\n  setTexture(texture) {\n    texture.image = {\n      width: this.width,\n      height: this.height,\n      depth: this.depth\n    };\n    this.texture = texture;\n  }\n\n  setSize(width, height, depth = 1) {\n    if (this.width !== width || this.height !== height || this.depth !== depth) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n      this.texture.image.width = width;\n      this.texture.image.height = height;\n      this.texture.image.depth = depth;\n      this.dispose();\n    }\n\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n    this.viewport.copy(source.viewport);\n    this.texture = source.texture.clone();\n    this.texture.image = { ...this.texture.image\n    }; // See #20328.\n\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.depthTexture = source.depthTexture;\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n  constructor(width, height, count) {\n    super(width, height);\n    const texture = this.texture;\n    this.texture = [];\n\n    for (let i = 0; i < count; i++) {\n      this.texture[i] = texture.clone();\n    }\n  }\n\n  setSize(width, height, depth = 1) {\n    if (this.width !== width || this.height !== height || this.depth !== depth) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n\n      for (let i = 0, il = this.texture.length; i < il; i++) {\n        this.texture[i].image.width = width;\n        this.texture[i].image.height = height;\n        this.texture[i].image.depth = depth;\n      }\n\n      this.dispose();\n    }\n\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n    return this;\n  }\n\n  copy(source) {\n    this.dispose();\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n    this.viewport.set(0, 0, this.width, this.height);\n    this.scissor.set(0, 0, this.width, this.height);\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.depthTexture = source.depthTexture;\n    this.texture.length = 0;\n\n    for (let i = 0, il = source.texture.length; i < il; i++) {\n      this.texture[i] = source.texture[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nWebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;\n\nclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n  constructor(width, height, options) {\n    super(width, height, options);\n    this.samples = 4;\n  }\n\n  copy(source) {\n    super.copy.call(this, source);\n    this.samples = source.samples;\n    return this;\n  }\n\n}\n\nWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\nclass Quaternion {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  static slerp(qa, qb, qm, t) {\n    console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');\n    return qm.slerpQuaternions(qa, qb, t);\n  }\n\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n    // fuzz-free, array-based Quaternion SLERP operation\n    let x0 = src0[srcOffset0 + 0],\n        y0 = src0[srcOffset0 + 1],\n        z0 = src0[srcOffset0 + 2],\n        w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1 + 0],\n          y1 = src1[srcOffset1 + 1],\n          z1 = src1[srcOffset1 + 2],\n          w1 = src1[srcOffset1 + 3];\n\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n            dir = cos >= 0 ? 1 : -1,\n            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin),\n              len = Math.atan2(sin, cos * dir);\n        s = Math.sin(s * len) / sin;\n        t = Math.sin(t * len) / sin;\n      }\n\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n    return dst;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(value) {\n    this._x = value;\n\n    this._onChangeCallback();\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(value) {\n    this._y = value;\n\n    this._onChangeCallback();\n  }\n\n  get z() {\n    return this._z;\n  }\n\n  set z(value) {\n    this._z = value;\n\n    this._onChangeCallback();\n  }\n\n  get w() {\n    return this._w;\n  }\n\n  set w(value) {\n    this._w = value;\n\n    this._onChangeCallback();\n  }\n\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromEuler(euler, update) {\n    if (!(euler && euler.isEuler)) {\n      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n    }\n\n    const x = euler._x,\n          y = euler._y,\n          z = euler._z,\n          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    const cos = Math.cos;\n    const sin = Math.sin;\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n\n    switch (order) {\n      case 'XYZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'YXZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case 'ZXY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'ZYX':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case 'YZX':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'XZY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      default:\n        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n    }\n\n    if (update !== false) this._onChangeCallback();\n    return this;\n  }\n\n  setFromAxisAngle(axis, angle) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n    // assumes axis is normalized\n    const halfAngle = angle / 2,\n          s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    const te = m.elements,\n          m11 = te[0],\n          m12 = te[4],\n          m13 = te[8],\n          m21 = te[1],\n          m22 = te[5],\n          m23 = te[9],\n          m31 = te[2],\n          m32 = te[6],\n          m33 = te[10],\n          trace = m11 + m22 + m33;\n\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1.0);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromUnitVectors(vFrom, vTo) {\n    // assumes direction vectors vFrom and vTo are normalized\n    let r = vFrom.dot(vTo) + 1;\n\n    if (r < Number.EPSILON) {\n      // vFrom and vTo point in opposite directions\n      r = 0;\n\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n\n    return this.normalize();\n  }\n\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));\n  }\n\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n    if (angle === 0) return this;\n    const t = Math.min(1, step / angle);\n    this.slerp(q, t);\n    return this;\n  }\n\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n\n  invert() {\n    // quaternion is assumed to have unit length\n    return this.conjugate();\n  }\n\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n\n  lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n\n  length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n\n  normalize() {\n    let l = this.length();\n\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  multiply(q, p) {\n    if (p !== undefined) {\n      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n      return this.multiplyQuaternions(q, p);\n    }\n\n    return this.multiplyQuaternions(this, q);\n  }\n\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n\n  multiplyQuaternions(a, b) {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n    const qax = a._x,\n          qay = a._y,\n          qaz = a._z,\n          qaw = a._w;\n    const qbx = b._x,\n          qby = b._y,\n          qbz = b._z,\n          qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  slerp(qb, t) {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n    const x = this._x,\n          y = this._y,\n          z = this._z,\n          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n\n    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n      this.normalize();\n\n      this._onChangeCallback();\n\n      return this;\n    }\n\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  slerpQuaternions(qa, qb, t) {\n    this.copy(qa).slerp(qb, t);\n  }\n\n  equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n\n  fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n    return this;\n  }\n\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n\n  _onChangeCallback() {}\n\n}\n\nQuaternion.prototype.isQuaternion = true;\n\nclass Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  set(x, y, z) {\n    if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      case 2:\n        this.z = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      case 2:\n        return this.z;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  }\n\n  multiply(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n      return this.multiplyVectors(v, w);\n    }\n\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  }\n\n  applyEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n    }\n\n    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n  }\n\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n  }\n\n  applyMatrix3(m) {\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n\n  applyMatrix4(m) {\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const e = m.elements;\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n    return this;\n  }\n\n  applyQuaternion(q) {\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const qx = q.x,\n          qy = q.y,\n          qz = q.z,\n          qw = q.w; // calculate quat * vector\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return this;\n  }\n\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n\n  transformDirection(m) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    return this.normalize();\n  }\n\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  } // TODO lengthSquared?\n\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    return this;\n  }\n\n  cross(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n      return this.crossVectors(v, w);\n    }\n\n    return this.crossVectors(this, v);\n  }\n\n  crossVectors(a, b) {\n    const ax = a.x,\n          ay = a.y,\n          az = a.z;\n    const bx = b.x,\n          by = b.y,\n          bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  }\n\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n    if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n  }\n\n  projectOnPlane(planeNormal) {\n    _vector$c.copy(this).projectOnVector(planeNormal);\n\n    return this.sub(_vector$c);\n  }\n\n  reflect(normal) {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n    return Math.acos(clamp$1(theta, -1, 1));\n  }\n\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  }\n\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n    return this;\n  }\n\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    return this;\n  }\n\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  }\n\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    return this;\n  }\n\n}\n\nVector3.prototype.isVector3 = true;\n\nconst _vector$c = /*@__PURE__*/new Vector3();\n\nconst _quaternion$4 = /*@__PURE__*/new Quaternion();\n\nclass Box3 {\n  constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n    this.min = min;\n    this.max = max;\n  }\n\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n\n  setFromArray(array) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n\n  setFromBufferAttribute(attribute) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n\n    for (let i = 0, l = attribute.count; i < l; i++) {\n      const x = attribute.getX(i);\n      const y = attribute.getY(i);\n      const z = attribute.getZ(i);\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n\n  setFromPoints(points) {\n    this.makeEmpty();\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n\n    return this;\n  }\n\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n\n  setFromObject(object) {\n    this.makeEmpty();\n    return this.expandByObject(object);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = +Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n\n  isEmpty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n\n  getCenter(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n\n  getSize(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n\n  expandByObject(object) {\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n\n    if (geometry !== undefined) {\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n\n      _box$3.copy(geometry.boundingBox);\n\n      _box$3.applyMatrix4(object.matrixWorld);\n\n      this.union(_box$3);\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i]);\n    }\n\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n  }\n\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n\n  getParameter(point, target) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n  }\n\n  intersectsBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n  }\n\n  intersectsSphere(sphere) {\n    // Find the point on the AABB closest to the sphere center.\n    this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.\n\n    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  intersectsPlane(plane) {\n    // We compute the minimum and maximum dot product values. If those values\n    // are on the same side (back or front) of the plane, then there is no intersection.\n    let min, max;\n\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    } // compute box center and extents\n\n\n    this.getCenter(_center);\n\n    _extents.subVectors(this.max, _center); // translate triangle to aabb origin\n\n\n    _v0$2.subVectors(triangle.a, _center);\n\n    _v1$7.subVectors(triangle.b, _center);\n\n    _v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle\n\n\n    _f0.subVectors(_v1$7, _v0$2);\n\n    _f1.subVectors(_v2$3, _v1$7);\n\n    _f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\n\n    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n      return false;\n    } // test 3 face normals from the aabb\n\n\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n      return false;\n    } // finally testing the face normal of the triangle\n    // use already existing triangle edge vectors here\n\n\n    _triangleNormal.crossVectors(_f0, _f1);\n\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n  }\n\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n\n  distanceToPoint(point) {\n    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n\n    return clampedPoint.sub(point).length();\n  }\n\n  getBoundingSphere(target) {\n    this.getCenter(target.center);\n    target.radius = this.getSize(_vector$b).length() * 0.5;\n    return target;\n  }\n\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\n    if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n\n  applyMatrix4(matrix) {\n    // transform of empty box is an empty box.\n    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\n    this.setFromPoints(_points);\n    return this;\n  }\n\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n\n}\n\nBox3.prototype.isBox3 = true;\nconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\n\nconst _vector$b = /*@__PURE__*/new Vector3();\n\nconst _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices\n\n\nconst _v0$2 = /*@__PURE__*/new Vector3();\n\nconst _v1$7 = /*@__PURE__*/new Vector3();\n\nconst _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors\n\n\nconst _f0 = /*@__PURE__*/new Vector3();\n\nconst _f1 = /*@__PURE__*/new Vector3();\n\nconst _f2 = /*@__PURE__*/new Vector3();\n\nconst _center = /*@__PURE__*/new Vector3();\n\nconst _extents = /*@__PURE__*/new Vector3();\n\nconst _triangleNormal = /*@__PURE__*/new Vector3();\n\nconst _testAxis = /*@__PURE__*/new Vector3();\n\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis\n\n\n    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis\n\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r\n\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is seperating and we can exit\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst _box$2 = /*@__PURE__*/new Box3();\n\nconst _v1$6 = /*@__PURE__*/new Vector3();\n\nconst _toFarthestPoint = /*@__PURE__*/new Vector3();\n\nconst _toPoint = /*@__PURE__*/new Vector3();\n\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box$2.setFromPoints(points).getCenter(center);\n    }\n\n    let maxRadiusSq = 0;\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n\n  isEmpty() {\n    return this.radius < 0;\n  }\n\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n    target.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return target;\n  }\n\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n\n  expandByPoint(point) {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n    _toPoint.subVectors(point, this.center);\n\n    const lengthSq = _toPoint.lengthSq();\n\n    if (lengthSq > this.radius * this.radius) {\n      const length = Math.sqrt(lengthSq);\n      const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,\n      // and the other half to position. This gives a tighter enclosure, instead of if\n      // the whole missing distance were just added to radius.\n\n      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n      this.radius += missingRadiusHalf;\n    }\n\n    return this;\n  }\n\n  union(sphere) {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n    // To enclose another sphere into this sphere, we only need to enclose two points:\n    // 1) Enclose the farthest point on the other sphere into this sphere.\n    // 2) Enclose the opposite point of the farthest point into this sphere.\n    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n\n    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n    return this;\n  }\n\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nconst _vector$a = /*@__PURE__*/new Vector3();\n\nconst _segCenter = /*@__PURE__*/new Vector3();\n\nconst _segDir = /*@__PURE__*/new Vector3();\n\nconst _diff = /*@__PURE__*/new Vector3();\n\nconst _edge1 = /*@__PURE__*/new Vector3();\n\nconst _edge2 = /*@__PURE__*/new Vector3();\n\nconst _normal$1 = /*@__PURE__*/new Vector3();\n\nclass Ray {\n  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  }\n\n  at(t, target) {\n    return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    return this;\n  }\n\n  recast(t) {\n    this.origin.copy(this.at(t, _vector$a));\n    return this;\n  }\n\n  closestPointToPoint(point, target) {\n    target.subVectors(point, this.origin);\n    const directionDistance = target.dot(this.direction);\n\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n\n    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n  }\n\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n\n  distanceSqToPoint(point) {\n    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n\n    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n    return _vector$a.distanceToSquared(point);\n  }\n\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n    // It returns the min distance between the ray and the segment\n    // defined by v0 and v1\n    // It can also set two optional targets :\n    // - The closest point on the ray\n    // - The closest point on the segment\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n\n    _segDir.copy(v1).sub(v0).normalize();\n\n    _diff.copy(this.origin).sub(_segCenter);\n\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n\n    const b0 = _diff.dot(this.direction);\n\n    const b1 = -_diff.dot(_segDir);\n\n    const c = _diff.lengthSq();\n\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n\n    if (det > 0) {\n      // The ray and segment are not parallel.\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            // region 0\n            // Minimum at interior points of ray and segment.\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            // region 1\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          // region 5\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          // region 4\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          // region 3\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          // region 2\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      // Ray and segment are parallel.\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n    }\n\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n    }\n\n    return sqrDist;\n  }\n\n  intersectSphere(sphere, target) {\n    _vector$a.subVectors(sphere.center, this.origin);\n\n    const tca = _vector$a.dot(this.direction);\n\n    const d2 = _vector$a.dot(_vector$a) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return null;\n    const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n    const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n    const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n    if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n    // in order to always return an intersect point that is in front of the ray.\n\n    if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n    return this.at(t0, target);\n  }\n\n  intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      } // Null is preferable to undefined since undefined means.... it is undefined\n\n\n      return null;\n    }\n\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  }\n\n  intersectPlane(plane, target) {\n    const t = this.distanceToPlane(plane);\n\n    if (t === null) {\n      return null;\n    }\n\n    return this.at(t, target);\n  }\n\n  intersectsPlane(plane) {\n    // check if the ray lies on the plane first\n    const distToPoint = plane.distanceToPoint(this.origin);\n\n    if (distToPoint === 0) {\n      return true;\n    }\n\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator * distToPoint < 0) {\n      return true;\n    } // ray origin is behind the plane (and is pointing behind it)\n\n\n    return false;\n  }\n\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / this.direction.x,\n          invdiry = 1 / this.direction.y,\n          invdirz = 1 / this.direction.z;\n    const origin = this.origin;\n\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n\n    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n    // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n    if (tymin > tmin || tmin !== tmin) tmin = tymin;\n    if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n\n    if (tmin > tzmax || tzmin > tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector$a) !== null;\n  }\n\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    // Compute the offset origin, edges, and normal.\n    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n    _edge1.subVectors(b, a);\n\n    _edge2.subVectors(c, a);\n\n    _normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n\n    let DdN = this.direction.dot(_normal$1);\n    let sign;\n\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign = 1;\n    } else if (DdN < 0) {\n      sign = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n\n    _diff.subVectors(this.origin, a);\n\n    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection\n\n    if (DdQxE2 < 0) {\n      return null;\n    }\n\n    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection\n\n    if (DdE1xQ < 0) {\n      return null;\n    } // b1+b2 > 1, no intersection\n\n\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    } // Line intersects triangle, check if ray does.\n\n\n    const QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection\n\n\n    if (QdN < 0) {\n      return null;\n    } // Ray intersects triangle.\n\n\n    return this.at(QdN / DdN, target);\n  }\n\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n    return this;\n  }\n\n  equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nclass Matrix4 {\n  constructor() {\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n    if (arguments.length > 0) {\n      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n    }\n  }\n\n  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n\n  identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  clone() {\n    return new Matrix4().fromArray(this.elements);\n  }\n\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n    return this;\n  }\n\n  copyPosition(m) {\n    const te = this.elements,\n          me = m.elements;\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    return this;\n  }\n\n  setFromMatrix3(m) {\n    const me = m.elements;\n    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n    return this;\n  }\n\n  makeBasis(xAxis, yAxis, zAxis) {\n    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  extractRotation(m) {\n    // this method does not support reflection matrices\n    const te = this.elements;\n    const me = m.elements;\n\n    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n\n    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n\n    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n\n  makeRotationFromEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n    }\n\n    const te = this.elements;\n    const x = euler.x,\n          y = euler.y,\n          z = euler.z;\n    const a = Math.cos(x),\n          b = Math.sin(x);\n    const c = Math.cos(y),\n          d = Math.sin(y);\n    const e = Math.cos(z),\n          f = Math.sin(z);\n\n    if (euler.order === 'XYZ') {\n      const ae = a * e,\n            af = a * f,\n            be = b * e,\n            bf = b * f;\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === 'YXZ') {\n      const ce = c * e,\n            cf = c * f,\n            de = d * e,\n            df = d * f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZXY') {\n      const ce = c * e,\n            cf = c * f,\n            de = d * e,\n            df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === 'ZYX') {\n      const ae = a * e,\n            af = a * f,\n            be = b * e,\n            bf = b * f;\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === 'YZX') {\n      const ac = a * c,\n            ad = a * d,\n            bc = b * c,\n            bd = b * d;\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === 'XZY') {\n      const ac = a * c,\n            ad = a * d,\n            bc = b * c,\n            bd = b * d;\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    } // bottom row\n\n\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0; // last column\n\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n\n  makeRotationFromQuaternion(q) {\n    return this.compose(_zero, q, _one);\n  }\n\n  lookAt(eye, target, up) {\n    const te = this.elements;\n\n    _z.subVectors(eye, target);\n\n    if (_z.lengthSq() === 0) {\n      // eye and target are in the same position\n      _z.z = 1;\n    }\n\n    _z.normalize();\n\n    _x.crossVectors(up, _z);\n\n    if (_x.lengthSq() === 0) {\n      // up and z are parallel\n      if (Math.abs(up.z) === 1) {\n        _z.x += 0.0001;\n      } else {\n        _z.z += 0.0001;\n      }\n\n      _z.normalize();\n\n      _x.crossVectors(up, _z);\n    }\n\n    _x.normalize();\n\n    _y.crossVectors(_z, _x);\n\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n    return this;\n  }\n\n  multiply(m, n) {\n    if (n !== undefined) {\n      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n      return this.multiplyMatrices(m, n);\n    }\n\n    return this.multiplyMatrices(this, m);\n  }\n\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0],\n          a12 = ae[4],\n          a13 = ae[8],\n          a14 = ae[12];\n    const a21 = ae[1],\n          a22 = ae[5],\n          a23 = ae[9],\n          a24 = ae[13];\n    const a31 = ae[2],\n          a32 = ae[6],\n          a33 = ae[10],\n          a34 = ae[14];\n    const a41 = ae[3],\n          a42 = ae[7],\n          a43 = ae[11],\n          a44 = ae[15];\n    const b11 = be[0],\n          b12 = be[4],\n          b13 = be[8],\n          b14 = be[12];\n    const b21 = be[1],\n          b22 = be[5],\n          b23 = be[9],\n          b24 = be[13];\n    const b31 = be[2],\n          b32 = be[6],\n          b33 = be[10],\n          b34 = be[14];\n    const b41 = be[3],\n          b42 = be[7],\n          b43 = be[11],\n          b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  }\n\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n    return this;\n  }\n\n  determinant() {\n    const te = this.elements;\n    const n11 = te[0],\n          n12 = te[4],\n          n13 = te[8],\n          n14 = te[12];\n    const n21 = te[1],\n          n22 = te[5],\n          n23 = te[9],\n          n24 = te[13];\n    const n31 = te[2],\n          n32 = te[6],\n          n33 = te[10],\n          n34 = te[14];\n    const n41 = te[3],\n          n42 = te[7],\n          n43 = te[11],\n          n44 = te[15]; //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n\n  transpose() {\n    const te = this.elements;\n    let tmp;\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n    return this;\n  }\n\n  setPosition(x, y, z) {\n    const te = this.elements;\n\n    if (x.isVector3) {\n      te[12] = x.x;\n      te[13] = x.y;\n      te[14] = x.z;\n    } else {\n      te[12] = x;\n      te[13] = y;\n      te[14] = z;\n    }\n\n    return this;\n  }\n\n  invert() {\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    const te = this.elements,\n          n11 = te[0],\n          n21 = te[1],\n          n31 = te[2],\n          n41 = te[3],\n          n12 = te[4],\n          n22 = te[5],\n          n32 = te[6],\n          n42 = te[7],\n          n13 = te[8],\n          n23 = te[9],\n          n33 = te[10],\n          n43 = te[11],\n          n14 = te[12],\n          n24 = te[13],\n          n34 = te[14],\n          n44 = te[15],\n          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n    return this;\n  }\n\n  scale(v) {\n    const te = this.elements;\n    const x = v.x,\n          y = v.y,\n          z = v.z;\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n    return this;\n  }\n\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n  }\n\n  makeTranslation(x, y, z) {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n    return this;\n  }\n\n  makeRotationX(theta) {\n    const c = Math.cos(theta),\n          s = Math.sin(theta);\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  makeRotationY(theta) {\n    const c = Math.cos(theta),\n          s = Math.sin(theta);\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  makeRotationZ(theta) {\n    const c = Math.cos(theta),\n          s = Math.sin(theta);\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  makeRotationAxis(axis, angle) {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t = 1 - c;\n    const x = axis.x,\n          y = axis.y,\n          z = axis.z;\n    const tx = t * x,\n          ty = t * y;\n    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  makeScale(x, y, z) {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n\n  compose(position, quaternion, scale) {\n    const te = this.elements;\n    const x = quaternion._x,\n          y = quaternion._y,\n          z = quaternion._z,\n          w = quaternion._w;\n    const x2 = x + x,\n          y2 = y + y,\n          z2 = z + z;\n    const xx = x * x2,\n          xy = x * y2,\n          xz = x * z2;\n    const yy = y * y2,\n          yz = y * z2,\n          zz = z * z2;\n    const wx = w * x2,\n          wy = w * y2,\n          wz = w * z2;\n    const sx = scale.x,\n          sy = scale.y,\n          sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return this;\n  }\n\n  decompose(position, quaternion, scale) {\n    const te = this.elements;\n\n    let sx = _v1$5.set(te[0], te[1], te[2]).length();\n\n    const sy = _v1$5.set(te[4], te[5], te[6]).length();\n\n    const sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale\n\n\n    const det = this.determinant();\n    if (det < 0) sx = -sx;\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14]; // scale the rotation part\n\n    _m1$2.copy(this);\n\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1$2.elements[0] *= invSX;\n    _m1$2.elements[1] *= invSX;\n    _m1$2.elements[2] *= invSX;\n    _m1$2.elements[4] *= invSY;\n    _m1$2.elements[5] *= invSY;\n    _m1$2.elements[6] *= invSY;\n    _m1$2.elements[8] *= invSZ;\n    _m1$2.elements[9] *= invSZ;\n    _m1$2.elements[10] *= invSZ;\n    quaternion.setFromRotationMatrix(_m1$2);\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n    return this;\n  }\n\n  makePerspective(left, right, top, bottom, near, far) {\n    if (far === undefined) {\n      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\n    }\n\n    const te = this.elements;\n    const x = 2 * near / (right - left);\n    const y = 2 * near / (top - bottom);\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    const c = -(far + near) / (far - near);\n    const d = -2 * far * near / (far - near);\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return this;\n  }\n\n  makeOrthographic(left, right, top, bottom, near, far) {\n    const te = this.elements;\n    const w = 1.0 / (right - left);\n    const h = 1.0 / (top - bottom);\n    const p = 1.0 / (far - near);\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    const z = (far + near) * p;\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 * p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n    return this;\n  }\n\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n\n    for (let i = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return array;\n  }\n\n}\n\nMatrix4.prototype.isMatrix4 = true;\n\nconst _v1$5 = /*@__PURE__*/new Vector3();\n\nconst _m1$2 = /*@__PURE__*/new Matrix4();\n\nconst _zero = /*@__PURE__*/new Vector3(0, 0, 0);\n\nconst _one = /*@__PURE__*/new Vector3(1, 1, 1);\n\nconst _x = /*@__PURE__*/new Vector3();\n\nconst _y = /*@__PURE__*/new Vector3();\n\nconst _z = /*@__PURE__*/new Vector3();\n\nconst _matrix$1 = /*@__PURE__*/new Matrix4();\n\nconst _quaternion$3 = /*@__PURE__*/new Quaternion();\n\nclass Euler {\n  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(value) {\n    this._x = value;\n\n    this._onChangeCallback();\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(value) {\n    this._y = value;\n\n    this._onChangeCallback();\n  }\n\n  get z() {\n    return this._z;\n  }\n\n  set z(value) {\n    this._z = value;\n\n    this._onChangeCallback();\n  }\n\n  get order() {\n    return this._order;\n  }\n\n  set order(value) {\n    this._order = value;\n\n    this._onChangeCallback();\n  }\n\n  set(x, y, z, order = this._order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n\n  copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m, order = this._order, update = true) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    const te = m.elements;\n    const m11 = te[0],\n          m12 = te[4],\n          m13 = te[8];\n    const m21 = te[1],\n          m22 = te[5],\n          m23 = te[9];\n    const m31 = te[2],\n          m32 = te[6],\n          m33 = te[10];\n\n    switch (order) {\n      case 'XYZ':\n        this._y = Math.asin(clamp$1(m13, -1, 1));\n\n        if (Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, m22);\n          this._z = 0;\n        }\n\n        break;\n\n      case 'YXZ':\n        this._x = Math.asin(-clamp$1(m23, -1, 1));\n\n        if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n\n        break;\n\n      case 'ZXY':\n        this._x = Math.asin(clamp$1(m32, -1, 1));\n\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n        }\n\n        break;\n\n      case 'ZYX':\n        this._y = Math.asin(-clamp$1(m31, -1, 1));\n\n        if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n\n        break;\n\n      case 'YZX':\n        this._z = Math.asin(clamp$1(m21, -1, 1));\n\n        if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n\n        break;\n\n      case 'XZY':\n        this._z = Math.asin(-clamp$1(m12, -1, 1));\n\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n\n        break;\n\n      default:\n        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n    }\n\n    this._order = order;\n    if (update === true) this._onChangeCallback();\n    return this;\n  }\n\n  setFromQuaternion(q, order, update) {\n    _matrix$1.makeRotationFromQuaternion(q);\n\n    return this.setFromRotationMatrix(_matrix$1, order, update);\n  }\n\n  setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, order);\n  }\n\n  reorder(newOrder) {\n    // WARNING: this discards revolution information -bhouston\n    _quaternion$3.setFromEuler(this);\n\n    return this.setFromQuaternion(_quaternion$3, newOrder);\n  }\n\n  equals(euler) {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  }\n\n  fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== undefined) this._order = array[3];\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n    return array;\n  }\n\n  toVector3(optionalResult) {\n    if (optionalResult) {\n      return optionalResult.set(this._x, this._y, this._z);\n    } else {\n      return new Vector3(this._x, this._y, this._z);\n    }\n  }\n\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n\n  _onChangeCallback() {}\n\n}\n\nEuler.prototype.isEuler = true;\nEuler.DefaultOrder = 'XYZ';\nEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\n\nclass Layers {\n  constructor() {\n    this.mask = 1 | 0;\n  }\n\n  set(channel) {\n    this.mask = 1 << channel | 0;\n  }\n\n  enable(channel) {\n    this.mask |= 1 << channel | 0;\n  }\n\n  enableAll() {\n    this.mask = 0xffffffff | 0;\n  }\n\n  toggle(channel) {\n    this.mask ^= 1 << channel | 0;\n  }\n\n  disable(channel) {\n    this.mask &= ~(1 << channel | 0);\n  }\n\n  disableAll() {\n    this.mask = 0;\n  }\n\n  test(layers) {\n    return (this.mask & layers.mask) !== 0;\n  }\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/new Vector3();\n\nconst _q1 = /*@__PURE__*/new Quaternion();\n\nconst _m1$1 = /*@__PURE__*/new Matrix4();\n\nconst _target = /*@__PURE__*/new Vector3();\n\nconst _position$3 = /*@__PURE__*/new Vector3();\n\nconst _scale$2 = /*@__PURE__*/new Vector3();\n\nconst _quaternion$2 = /*@__PURE__*/new Quaternion();\n\nconst _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);\n\nconst _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);\n\nconst _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);\n\nconst _addedEvent = {\n  type: 'added'\n};\nconst _removedEvent = {\n  type: 'removed'\n};\n\nclass Object3D extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: _object3DId++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.type = 'Object3D';\n    this.parent = null;\n    this.children = [];\n    this.up = Object3D.DefaultUp.clone();\n    const position = new Vector3();\n    const rotation = new Euler();\n    const quaternion = new Quaternion();\n    const scale = new Vector3(1, 1, 1);\n\n    function onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    }\n\n    function onQuaternionChange() {\n      rotation.setFromQuaternion(quaternion, undefined, false);\n    }\n\n    rotation._onChange(onRotationChange);\n\n    quaternion._onChange(onQuaternionChange);\n\n    Object.defineProperties(this, {\n      position: {\n        configurable: true,\n        enumerable: true,\n        value: position\n      },\n      rotation: {\n        configurable: true,\n        enumerable: true,\n        value: rotation\n      },\n      quaternion: {\n        configurable: true,\n        enumerable: true,\n        value: quaternion\n      },\n      scale: {\n        configurable: true,\n        enumerable: true,\n        value: scale\n      },\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      normalMatrix: {\n        value: new Matrix3()\n      }\n    });\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = false;\n    this.layers = new Layers();\n    this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = false;\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n    this.animations = [];\n    this.userData = {};\n  }\n\n  onBeforeRender() {}\n\n  onAfterRender() {}\n\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n\n  applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n    return this;\n  }\n\n  setRotationFromAxisAngle(axis, angle) {\n    // assumes axis is normalized\n    this.quaternion.setFromAxisAngle(axis, angle);\n  }\n\n  setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, true);\n  }\n\n  setRotationFromMatrix(m) {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    this.quaternion.setFromRotationMatrix(m);\n  }\n\n  setRotationFromQuaternion(q) {\n    // assumes q is normalized\n    this.quaternion.copy(q);\n  }\n\n  rotateOnAxis(axis, angle) {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.multiply(_q1);\n    return this;\n  }\n\n  rotateOnWorldAxis(axis, angle) {\n    // rotate object on axis in world space\n    // axis is assumed to be normalized\n    // method assumes no rotated parent\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.premultiply(_q1);\n    return this;\n  }\n\n  rotateX(angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n\n  rotateY(angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  }\n\n  rotateZ(angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  }\n\n  translateOnAxis(axis, distance) {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n    _v1$4.copy(axis).applyQuaternion(this.quaternion);\n\n    this.position.add(_v1$4.multiplyScalar(distance));\n    return this;\n  }\n\n  translateX(distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  }\n\n  translateY(distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  }\n\n  translateZ(distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  }\n\n  localToWorld(vector) {\n    return vector.applyMatrix4(this.matrixWorld);\n  }\n\n  worldToLocal(vector) {\n    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n  }\n\n  lookAt(x, y, z) {\n    // This method does not support objects having non-uniformly-scaled parent(s)\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n\n    const parent = this.parent;\n    this.updateWorldMatrix(true, false);\n\n    _position$3.setFromMatrixPosition(this.matrixWorld);\n\n    if (this.isCamera || this.isLight) {\n      _m1$1.lookAt(_position$3, _target, this.up);\n    } else {\n      _m1$1.lookAt(_target, _position$3, this.up);\n    }\n\n    this.quaternion.setFromRotationMatrix(_m1$1);\n\n    if (parent) {\n      _m1$1.extractRotation(parent.matrixWorld);\n\n      _q1.setFromRotationMatrix(_m1$1);\n\n      this.quaternion.premultiply(_q1.invert());\n    }\n  }\n\n  add(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    if (object === this) {\n      console.error('THREE.Object3D.add: object can\\'t be added as a child of itself.', object);\n      return this;\n    }\n\n    if (object && object.isObject3D) {\n      if (object.parent !== null) {\n        object.parent.remove(object);\n      }\n\n      object.parent = this;\n      this.children.push(object);\n      object.dispatchEvent(_addedEvent);\n    } else {\n      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\n    }\n\n    return this;\n  }\n\n  remove(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n\n      return this;\n    }\n\n    const index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n      object.dispatchEvent(_removedEvent);\n    }\n\n    return this;\n  }\n\n  removeFromParent() {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      parent.remove(this);\n    }\n\n    return this;\n  }\n\n  clear() {\n    for (let i = 0; i < this.children.length; i++) {\n      const object = this.children[i];\n      object.parent = null;\n      object.dispatchEvent(_removedEvent);\n    }\n\n    this.children.length = 0;\n    return this;\n  }\n\n  attach(object) {\n    // adds object as a child of this, while maintaining the object's world transform\n    this.updateWorldMatrix(true, false);\n\n    _m1$1.copy(this.matrixWorld).invert();\n\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n\n      _m1$1.multiply(object.parent.matrixWorld);\n    }\n\n    object.applyMatrix4(_m1$1);\n    this.add(object);\n    object.updateWorldMatrix(false, true);\n    return this;\n  }\n\n  getObjectById(id) {\n    return this.getObjectByProperty('id', id);\n  }\n\n  getObjectByName(name) {\n    return this.getObjectByProperty('name', name);\n  }\n\n  getObjectByProperty(name, value) {\n    if (this[name] === value) return this;\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n\n      if (object !== undefined) {\n        return object;\n      }\n    }\n\n    return undefined;\n  }\n\n  getWorldPosition(target) {\n    this.updateWorldMatrix(true, false);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n\n  getWorldQuaternion(target) {\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, target, _scale$2);\n    return target;\n  }\n\n  getWorldScale(target) {\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n    return target;\n  }\n\n  getWorldDirection(target) {\n    this.updateWorldMatrix(true, false);\n    const e = this.matrixWorld.elements;\n    return target.set(e[8], e[9], e[10]).normalize();\n  }\n\n  raycast() {}\n\n  traverse(callback) {\n    callback(this);\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  }\n\n  traverseVisible(callback) {\n    if (this.visible === false) return;\n    callback(this);\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  }\n\n  traverseAncestors(callback) {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      callback(parent);\n      parent.traverseAncestors(callback);\n    }\n  }\n\n  updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  }\n\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    } // update children\n\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].updateMatrixWorld(force);\n    }\n  }\n\n  updateWorldMatrix(updateParents, updateChildren) {\n    const parent = this.parent;\n\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.parent === null) {\n      this.matrixWorld.copy(this.matrix);\n    } else {\n      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    } // update children\n\n\n    if (updateChildren === true) {\n      const children = this.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateWorldMatrix(false, true);\n      }\n    }\n  }\n\n  toJSON(meta) {\n    // meta is a string when called from JSON.stringify\n    const isRootObject = meta === undefined || typeof meta === 'string';\n    const output = {}; // meta is a hash used to collect geometries, materials.\n    // not providing it implies that this is the root object\n    // being serialized.\n\n    if (isRootObject) {\n      // initialize meta obj\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {},\n        skeletons: {},\n        animations: {}\n      };\n      output.metadata = {\n        version: 4.5,\n        type: 'Object',\n        generator: 'Object3D.toJSON'\n      };\n    } // standard Object3D serialization\n\n\n    const object = {};\n    object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name !== '') object.name = this.name;\n    if (this.castShadow === true) object.castShadow = true;\n    if (this.receiveShadow === true) object.receiveShadow = true;\n    if (this.visible === false) object.visible = false;\n    if (this.frustumCulled === false) object.frustumCulled = false;\n    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties\n\n    if (this.isInstancedMesh) {\n      object.type = 'InstancedMesh';\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n    } //\n\n\n    function serialize(library, element) {\n      if (library[element.uuid] === undefined) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n\n      return element.uuid;\n    }\n\n    if (this.isScene) {\n      if (this.background) {\n        if (this.background.isColor) {\n          object.background = this.background.toJSON();\n        } else if (this.background.isTexture) {\n          object.background = this.background.toJSON(meta).uuid;\n        }\n      }\n\n      if (this.environment && this.environment.isTexture) {\n        object.environment = this.environment.toJSON(meta).uuid;\n      }\n    } else if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n      const parameters = this.geometry.parameters;\n\n      if (parameters !== undefined && parameters.shapes !== undefined) {\n        const shapes = parameters.shapes;\n\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n\n    if (this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      object.bindMatrix = this.bindMatrix.toArray();\n\n      if (this.skeleton !== undefined) {\n        serialize(meta.skeletons, this.skeleton);\n        object.skeleton = this.skeleton.uuid;\n      }\n    }\n\n    if (this.material !== undefined) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    } //\n\n\n    if (this.children.length > 0) {\n      object.children = [];\n\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    } //\n\n\n    if (this.animations.length > 0) {\n      object.animations = [];\n\n      for (let i = 0; i < this.animations.length; i++) {\n        const animation = this.animations[i];\n        object.animations.push(serialize(meta.animations, animation));\n      }\n    }\n\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n      const skeletons = extractFromCache(meta.skeletons);\n      const animations = extractFromCache(meta.animations);\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n      if (shapes.length > 0) output.shapes = shapes;\n      if (skeletons.length > 0) output.skeletons = skeletons;\n      if (animations.length > 0) output.animations = animations;\n    }\n\n    output.object = object;\n    return output; // extract data from the cache hash\n    // remove metadata on each item\n    // and return as array\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n  }\n\n  clone(recursive) {\n    return new this.constructor().copy(this, recursive);\n  }\n\n  copy(source, recursive = true) {\n    this.name = source.name;\n    this.up.copy(source.up);\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n\n    return this;\n  }\n\n}\n\nObject3D.DefaultUp = new Vector3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\nObject3D.prototype.isObject3D = true;\n\nconst _v0$1 = /*@__PURE__*/new Vector3();\n\nconst _v1$3 = /*@__PURE__*/new Vector3();\n\nconst _v2$2 = /*@__PURE__*/new Vector3();\n\nconst _v3$1 = /*@__PURE__*/new Vector3();\n\nconst _vab = /*@__PURE__*/new Vector3();\n\nconst _vac = /*@__PURE__*/new Vector3();\n\nconst _vbc = /*@__PURE__*/new Vector3();\n\nconst _vap = /*@__PURE__*/new Vector3();\n\nconst _vbp = /*@__PURE__*/new Vector3();\n\nconst _vcp = /*@__PURE__*/new Vector3();\n\nclass Triangle {\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  static getNormal(a, b, c, target) {\n    target.subVectors(c, b);\n\n    _v0$1.subVectors(a, b);\n\n    target.cross(_v0$1);\n    const targetLengthSq = target.lengthSq();\n\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n\n    return target.set(0, 0, 0);\n  } // static/instance method to calculate barycentric coordinates\n  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\n  static getBarycoord(point, a, b, c, target) {\n    _v0$1.subVectors(c, a);\n\n    _v1$3.subVectors(b, a);\n\n    _v2$2.subVectors(point, a);\n\n    const dot00 = _v0$1.dot(_v0$1);\n\n    const dot01 = _v0$1.dot(_v1$3);\n\n    const dot02 = _v0$1.dot(_v2$2);\n\n    const dot11 = _v1$3.dot(_v1$3);\n\n    const dot12 = _v1$3.dot(_v2$2);\n\n    const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle\n\n    if (denom === 0) {\n      // arbitrary location outside of triangle?\n      // not sure if this is the best idea, maybe should be returning undefined\n      return target.set(-2, -1, -1);\n    }\n\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n    return target.set(1 - u - v, v, u);\n  }\n\n  static containsPoint(point, a, b, c) {\n    this.getBarycoord(point, a, b, c, _v3$1);\n    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n  }\n\n  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n    this.getBarycoord(point, p1, p2, p3, _v3$1);\n    target.set(0, 0);\n    target.addScaledVector(uv1, _v3$1.x);\n    target.addScaledVector(uv2, _v3$1.y);\n    target.addScaledVector(uv3, _v3$1.z);\n    return target;\n  }\n\n  static isFrontFacing(a, b, c, direction) {\n    _v0$1.subVectors(c, b);\n\n    _v1$3.subVectors(a, b); // strictly front facing\n\n\n    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n  }\n\n  set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  }\n\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n    return this;\n  }\n\n  getArea() {\n    _v0$1.subVectors(this.c, this.b);\n\n    _v1$3.subVectors(this.a, this.b);\n\n    return _v0$1.cross(_v1$3).length() * 0.5;\n  }\n\n  getMidpoint(target) {\n    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  }\n\n  getNormal(target) {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n\n  getPlane(target) {\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n\n  getBarycoord(point, target) {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n\n  getUV(point, uv1, uv2, uv3, target) {\n    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n  }\n\n  containsPoint(point) {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n\n  isFrontFacing(direction) {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n\n  intersectsBox(box) {\n    return box.intersectsTriangle(this);\n  }\n\n  closestPointToPoint(p, target) {\n    const a = this.a,\n          b = this.b,\n          c = this.c;\n    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n    // under the accompanying license; see chapter 5.1.5 for detailed explanation.\n    // basically, we're distinguishing which of the voronoi regions of the triangle\n    // the point lies in with the minimum amount of redundant computation.\n\n    _vab.subVectors(b, a);\n\n    _vac.subVectors(c, a);\n\n    _vap.subVectors(p, a);\n\n    const d1 = _vab.dot(_vap);\n\n    const d2 = _vac.dot(_vap);\n\n    if (d1 <= 0 && d2 <= 0) {\n      // vertex region of A; barycentric coords (1, 0, 0)\n      return target.copy(a);\n    }\n\n    _vbp.subVectors(p, b);\n\n    const d3 = _vab.dot(_vbp);\n\n    const d4 = _vac.dot(_vbp);\n\n    if (d3 >= 0 && d4 <= d3) {\n      // vertex region of B; barycentric coords (0, 1, 0)\n      return target.copy(b);\n    }\n\n    const vc = d1 * d4 - d3 * d2;\n\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)\n\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n\n    _vcp.subVectors(p, c);\n\n    const d5 = _vab.dot(_vcp);\n\n    const d6 = _vac.dot(_vcp);\n\n    if (d6 >= 0 && d5 <= d6) {\n      // vertex region of C; barycentric coords (0, 0, 1)\n      return target.copy(c);\n    }\n\n    const vb = d5 * d2 - d1 * d6;\n\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)\n\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n\n    const va = d3 * d6 - d5 * d4;\n\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)\n\n      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n    } // face region\n\n\n    const denom = 1 / (va + vb + vc); // u = va * denom\n\n    v = vb * denom;\n    w = vc * denom;\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n\n  equals(triangle) {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n\n}\n\nlet materialId = 0;\n\nclass Material$1 extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: materialId++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.type = 'Material';\n    this.fog = true;\n    this.blending = NormalBlending;\n    this.side = FrontSide;\n    this.vertexColors = false;\n    this.opacity = 1;\n    this.transparent = false;\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n    this.depthFunc = LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n    this.stencilWriteMask = 0xff;\n    this.stencilFunc = AlwaysStencilFunc;\n    this.stencilRef = 0;\n    this.stencilFuncMask = 0xff;\n    this.stencilFail = KeepStencilOp;\n    this.stencilZFail = KeepStencilOp;\n    this.stencilZPass = KeepStencilOp;\n    this.stencilWrite = false;\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n    this.shadowSide = null;\n    this.colorWrite = true;\n    this.precision = null; // override the renderer's default precision for this material\n\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n    this.dithering = false;\n    this.alphaTest = 0;\n    this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n    this.visible = true;\n    this.toneMapped = true;\n    this.userData = {};\n    this.version = 0;\n  }\n\n  onBuild()\n  /* shaderobject, renderer */\n  {}\n\n  onBeforeCompile()\n  /* shaderobject, renderer */\n  {}\n\n  customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n\n  setValues(values) {\n    if (values === undefined) return;\n\n    for (const key in values) {\n      const newValue = values[key];\n\n      if (newValue === undefined) {\n        console.warn('THREE.Material: \\'' + key + '\\' parameter is undefined.');\n        continue;\n      } // for backward compatability if shading is set in the constructor\n\n\n      if (key === 'shading') {\n        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n        this.flatShading = newValue === FlatShading ? true : false;\n        continue;\n      }\n\n      const currentValue = this[key];\n\n      if (currentValue === undefined) {\n        console.warn('THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.');\n        continue;\n      }\n\n      if (currentValue && currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n        currentValue.copy(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {}\n      };\n    }\n\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Material',\n        generator: 'Material.toJSON'\n      }\n    }; // standard Material serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (this.color && this.color.isColor) data.color = this.color.getHex();\n    if (this.roughness !== undefined) data.roughness = this.roughness;\n    if (this.metalness !== undefined) data.metalness = this.metalness;\n    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();\n    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n    if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;\n    if (this.specularTint && this.specularTint.isColor) data.specularTint = this.specularTint.getHex();\n    if (this.shininess !== undefined) data.shininess = this.shininess;\n    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n\n    if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n    }\n\n    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n    }\n\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n    }\n\n    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n    if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = this.lightMapIntensity;\n    }\n\n    if (this.aoMap && this.aoMap.isTexture) {\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      data.aoMapIntensity = this.aoMapIntensity;\n    }\n\n    if (this.bumpMap && this.bumpMap.isTexture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n\n    if (this.normalMap && this.normalMap.isTexture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType = this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n    }\n\n    if (this.displacementMap && this.displacementMap.isTexture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n\n    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularTintMap && this.specularTintMap.isTexture) data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;\n\n    if (this.envMap && this.envMap.isTexture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n      if (this.combine !== undefined) data.combine = this.combine;\n    }\n\n    if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n    if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n\n    if (this.gradientMap && this.gradientMap.isTexture) {\n      data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n    }\n\n    if (this.transmission !== undefined) data.transmission = this.transmission;\n    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== undefined) data.thickness = this.thickness;\n    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;\n    if (this.attenuationTint !== undefined) data.attenuationTint = this.attenuationTint.getHex();\n    if (this.size !== undefined) data.size = this.size;\n    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== NormalBlending) data.blending = this.blending;\n    if (this.side !== FrontSide) data.side = this.side;\n    if (this.vertexColors) data.vertexColors = true;\n    if (this.opacity < 1) data.opacity = this.opacity;\n    if (this.transparent === true) data.transparent = this.transparent;\n    data.depthFunc = this.depthFunc;\n    data.depthTest = this.depthTest;\n    data.depthWrite = this.depthWrite;\n    data.colorWrite = this.colorWrite;\n    data.stencilWrite = this.stencilWrite;\n    data.stencilWriteMask = this.stencilWriteMask;\n    data.stencilFunc = this.stencilFunc;\n    data.stencilRef = this.stencilRef;\n    data.stencilFuncMask = this.stencilFuncMask;\n    data.stencilFail = this.stencilFail;\n    data.stencilZFail = this.stencilZFail;\n    data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)\n\n    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;\n    if (this.polygonOffset === true) data.polygonOffset = true;\n    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if (this.dashSize !== undefined) data.dashSize = this.dashSize;\n    if (this.gapSize !== undefined) data.gapSize = this.gapSize;\n    if (this.scale !== undefined) data.scale = this.scale;\n    if (this.dithering === true) data.dithering = true;\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;\n    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n    if (this.wireframe === true) data.wireframe = this.wireframe;\n    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n    if (this.flatShading === true) data.flatShading = this.flatShading;\n    if (this.visible === false) data.visible = false;\n    if (this.toneMapped === false) data.toneMapped = false;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n    }\n\n    return data;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.fog = source.fog;\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes = null;\n\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    this.colorWrite = source.colorWrite;\n    this.precision = source.precision;\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n    this.visible = source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n}\n\nMaterial$1.prototype.isMaterial = true;\nconst _colorKeywords = {\n  'aliceblue': 0xF0F8FF,\n  'antiquewhite': 0xFAEBD7,\n  'aqua': 0x00FFFF,\n  'aquamarine': 0x7FFFD4,\n  'azure': 0xF0FFFF,\n  'beige': 0xF5F5DC,\n  'bisque': 0xFFE4C4,\n  'black': 0x000000,\n  'blanchedalmond': 0xFFEBCD,\n  'blue': 0x0000FF,\n  'blueviolet': 0x8A2BE2,\n  'brown': 0xA52A2A,\n  'burlywood': 0xDEB887,\n  'cadetblue': 0x5F9EA0,\n  'chartreuse': 0x7FFF00,\n  'chocolate': 0xD2691E,\n  'coral': 0xFF7F50,\n  'cornflowerblue': 0x6495ED,\n  'cornsilk': 0xFFF8DC,\n  'crimson': 0xDC143C,\n  'cyan': 0x00FFFF,\n  'darkblue': 0x00008B,\n  'darkcyan': 0x008B8B,\n  'darkgoldenrod': 0xB8860B,\n  'darkgray': 0xA9A9A9,\n  'darkgreen': 0x006400,\n  'darkgrey': 0xA9A9A9,\n  'darkkhaki': 0xBDB76B,\n  'darkmagenta': 0x8B008B,\n  'darkolivegreen': 0x556B2F,\n  'darkorange': 0xFF8C00,\n  'darkorchid': 0x9932CC,\n  'darkred': 0x8B0000,\n  'darksalmon': 0xE9967A,\n  'darkseagreen': 0x8FBC8F,\n  'darkslateblue': 0x483D8B,\n  'darkslategray': 0x2F4F4F,\n  'darkslategrey': 0x2F4F4F,\n  'darkturquoise': 0x00CED1,\n  'darkviolet': 0x9400D3,\n  'deeppink': 0xFF1493,\n  'deepskyblue': 0x00BFFF,\n  'dimgray': 0x696969,\n  'dimgrey': 0x696969,\n  'dodgerblue': 0x1E90FF,\n  'firebrick': 0xB22222,\n  'floralwhite': 0xFFFAF0,\n  'forestgreen': 0x228B22,\n  'fuchsia': 0xFF00FF,\n  'gainsboro': 0xDCDCDC,\n  'ghostwhite': 0xF8F8FF,\n  'gold': 0xFFD700,\n  'goldenrod': 0xDAA520,\n  'gray': 0x808080,\n  'green': 0x008000,\n  'greenyellow': 0xADFF2F,\n  'grey': 0x808080,\n  'honeydew': 0xF0FFF0,\n  'hotpink': 0xFF69B4,\n  'indianred': 0xCD5C5C,\n  'indigo': 0x4B0082,\n  'ivory': 0xFFFFF0,\n  'khaki': 0xF0E68C,\n  'lavender': 0xE6E6FA,\n  'lavenderblush': 0xFFF0F5,\n  'lawngreen': 0x7CFC00,\n  'lemonchiffon': 0xFFFACD,\n  'lightblue': 0xADD8E6,\n  'lightcoral': 0xF08080,\n  'lightcyan': 0xE0FFFF,\n  'lightgoldenrodyellow': 0xFAFAD2,\n  'lightgray': 0xD3D3D3,\n  'lightgreen': 0x90EE90,\n  'lightgrey': 0xD3D3D3,\n  'lightpink': 0xFFB6C1,\n  'lightsalmon': 0xFFA07A,\n  'lightseagreen': 0x20B2AA,\n  'lightskyblue': 0x87CEFA,\n  'lightslategray': 0x778899,\n  'lightslategrey': 0x778899,\n  'lightsteelblue': 0xB0C4DE,\n  'lightyellow': 0xFFFFE0,\n  'lime': 0x00FF00,\n  'limegreen': 0x32CD32,\n  'linen': 0xFAF0E6,\n  'magenta': 0xFF00FF,\n  'maroon': 0x800000,\n  'mediumaquamarine': 0x66CDAA,\n  'mediumblue': 0x0000CD,\n  'mediumorchid': 0xBA55D3,\n  'mediumpurple': 0x9370DB,\n  'mediumseagreen': 0x3CB371,\n  'mediumslateblue': 0x7B68EE,\n  'mediumspringgreen': 0x00FA9A,\n  'mediumturquoise': 0x48D1CC,\n  'mediumvioletred': 0xC71585,\n  'midnightblue': 0x191970,\n  'mintcream': 0xF5FFFA,\n  'mistyrose': 0xFFE4E1,\n  'moccasin': 0xFFE4B5,\n  'navajowhite': 0xFFDEAD,\n  'navy': 0x000080,\n  'oldlace': 0xFDF5E6,\n  'olive': 0x808000,\n  'olivedrab': 0x6B8E23,\n  'orange': 0xFFA500,\n  'orangered': 0xFF4500,\n  'orchid': 0xDA70D6,\n  'palegoldenrod': 0xEEE8AA,\n  'palegreen': 0x98FB98,\n  'paleturquoise': 0xAFEEEE,\n  'palevioletred': 0xDB7093,\n  'papayawhip': 0xFFEFD5,\n  'peachpuff': 0xFFDAB9,\n  'peru': 0xCD853F,\n  'pink': 0xFFC0CB,\n  'plum': 0xDDA0DD,\n  'powderblue': 0xB0E0E6,\n  'purple': 0x800080,\n  'rebeccapurple': 0x663399,\n  'red': 0xFF0000,\n  'rosybrown': 0xBC8F8F,\n  'royalblue': 0x4169E1,\n  'saddlebrown': 0x8B4513,\n  'salmon': 0xFA8072,\n  'sandybrown': 0xF4A460,\n  'seagreen': 0x2E8B57,\n  'seashell': 0xFFF5EE,\n  'sienna': 0xA0522D,\n  'silver': 0xC0C0C0,\n  'skyblue': 0x87CEEB,\n  'slateblue': 0x6A5ACD,\n  'slategray': 0x708090,\n  'slategrey': 0x708090,\n  'snow': 0xFFFAFA,\n  'springgreen': 0x00FF7F,\n  'steelblue': 0x4682B4,\n  'tan': 0xD2B48C,\n  'teal': 0x008080,\n  'thistle': 0xD8BFD8,\n  'tomato': 0xFF6347,\n  'turquoise': 0x40E0D0,\n  'violet': 0xEE82EE,\n  'wheat': 0xF5DEB3,\n  'white': 0xFFFFFF,\n  'whitesmoke': 0xF5F5F5,\n  'yellow': 0xFFFF00,\n  'yellowgreen': 0x9ACD32\n};\nconst _hslA = {\n  h: 0,\n  s: 0,\n  l: 0\n};\nconst _hslB = {\n  h: 0,\n  s: 0,\n  l: 0\n};\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n  return p;\n}\n\nfunction SRGBToLinear(c) {\n  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\n\nfunction LinearToSRGB(c) {\n  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n}\n\nclass Color {\n  constructor(r, g, b) {\n    if (g === undefined && b === undefined) {\n      // r is THREE.Color, hex or string\n      return this.set(r);\n    }\n\n    return this.setRGB(r, g, b);\n  }\n\n  set(value) {\n    if (value && value.isColor) {\n      this.copy(value);\n    } else if (typeof value === 'number') {\n      this.setHex(value);\n    } else if (typeof value === 'string') {\n      this.setStyle(value);\n    }\n\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.r = scalar;\n    this.g = scalar;\n    this.b = scalar;\n    return this;\n  }\n\n  setHex(hex) {\n    hex = Math.floor(hex);\n    this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    this.b = (hex & 255) / 255;\n    return this;\n  }\n\n  setRGB(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  }\n\n  setHSL(h, s, l) {\n    // h,s,l ranges are in 0.0 - 1.0\n    h = euclideanModulo(h, 1);\n    s = clamp$1(s, 0, 1);\n    l = clamp$1(l, 0, 1);\n\n    if (s === 0) {\n      this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n      this.r = hue2rgb(q, p, h + 1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 / 3);\n    }\n\n    return this;\n  }\n\n  setStyle(style) {\n    function handleAlpha(string) {\n      if (string === undefined) return;\n\n      if (parseFloat(string) < 1) {\n        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\n      }\n    }\n\n    let m;\n\n    if (m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style)) {\n      // rgb / hsl\n      let color;\n      const name = m[1];\n      const components = m[2];\n\n      switch (name) {\n        case 'rgb':\n        case 'rgba':\n          if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            // rgb(255,0,0) rgba(255,0,0,0.5)\n            this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n            this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n            this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n            handleAlpha(color[4]);\n            return this;\n          }\n\n          if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n            this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n            this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n            this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n            handleAlpha(color[4]);\n            return this;\n          }\n\n          break;\n\n        case 'hsl':\n        case 'hsla':\n          if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n            const h = parseFloat(color[1]) / 360;\n            const s = parseInt(color[2], 10) / 100;\n            const l = parseInt(color[3], 10) / 100;\n            handleAlpha(color[4]);\n            return this.setHSL(h, s, l);\n          }\n\n          break;\n      }\n    } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n      // hex color\n      const hex = m[1];\n      const size = hex.length;\n\n      if (size === 3) {\n        // #ff0\n        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n        return this;\n      } else if (size === 6) {\n        // #ff0000\n        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n        return this;\n      }\n    }\n\n    if (style && style.length > 0) {\n      return this.setColorName(style);\n    }\n\n    return this;\n  }\n\n  setColorName(style) {\n    // color keywords\n    const hex = _colorKeywords[style.toLowerCase()];\n\n    if (hex !== undefined) {\n      // red\n      this.setHex(hex);\n    } else {\n      // unknown color\n      console.warn('THREE.Color: Unknown color ' + style);\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  }\n\n  copy(color) {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n    return this;\n  }\n\n  copyGammaToLinear(color, gammaFactor = 2.0) {\n    this.r = Math.pow(color.r, gammaFactor);\n    this.g = Math.pow(color.g, gammaFactor);\n    this.b = Math.pow(color.b, gammaFactor);\n    return this;\n  }\n\n  copyLinearToGamma(color, gammaFactor = 2.0) {\n    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n    this.r = Math.pow(color.r, safeInverse);\n    this.g = Math.pow(color.g, safeInverse);\n    this.b = Math.pow(color.b, safeInverse);\n    return this;\n  }\n\n  convertGammaToLinear(gammaFactor) {\n    this.copyGammaToLinear(this, gammaFactor);\n    return this;\n  }\n\n  convertLinearToGamma(gammaFactor) {\n    this.copyLinearToGamma(this, gammaFactor);\n    return this;\n  }\n\n  copySRGBToLinear(color) {\n    this.r = SRGBToLinear(color.r);\n    this.g = SRGBToLinear(color.g);\n    this.b = SRGBToLinear(color.b);\n    return this;\n  }\n\n  copyLinearToSRGB(color) {\n    this.r = LinearToSRGB(color.r);\n    this.g = LinearToSRGB(color.g);\n    this.b = LinearToSRGB(color.b);\n    return this;\n  }\n\n  convertSRGBToLinear() {\n    this.copySRGBToLinear(this);\n    return this;\n  }\n\n  convertLinearToSRGB() {\n    this.copyLinearToSRGB(this);\n    return this;\n  }\n\n  getHex() {\n    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n  }\n\n  getHexString() {\n    return ('000000' + this.getHex().toString(16)).slice(-6);\n  }\n\n  getHSL(target) {\n    // h,s,l ranges are in 0.0 - 1.0\n    const r = this.r,\n          g = this.g,\n          b = this.b;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let hue, saturation;\n    const lightness = (min + max) / 2.0;\n\n    if (min === max) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = max - min;\n      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n      switch (max) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n\n      hue /= 6;\n    }\n\n    target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n    return target;\n  }\n\n  getStyle() {\n    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\n  }\n\n  offsetHSL(h, s, l) {\n    this.getHSL(_hslA);\n    _hslA.h += h;\n    _hslA.s += s;\n    _hslA.l += l;\n    this.setHSL(_hslA.h, _hslA.s, _hslA.l);\n    return this;\n  }\n\n  add(color) {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n    return this;\n  }\n\n  addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  }\n\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n    return this;\n  }\n\n  sub(color) {\n    this.r = Math.max(0, this.r - color.r);\n    this.g = Math.max(0, this.g - color.g);\n    this.b = Math.max(0, this.b - color.b);\n    return this;\n  }\n\n  multiply(color) {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n    return this;\n  }\n\n  multiplyScalar(s) {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n    return this;\n  }\n\n  lerp(color, alpha) {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n    return this;\n  }\n\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + (color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) * alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n    return this;\n  }\n\n  lerpHSL(color, alpha) {\n    this.getHSL(_hslA);\n    color.getHSL(_hslB);\n    const h = lerp(_hslA.h, _hslB.h, alpha);\n    const s = lerp(_hslA.s, _hslB.s, alpha);\n    const l = lerp(_hslA.l, _hslB.l, alpha);\n    this.setHSL(h, s, l);\n    return this;\n  }\n\n  equals(c) {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  }\n\n  fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index) {\n    this.r = attribute.getX(index);\n    this.g = attribute.getY(index);\n    this.b = attribute.getZ(index);\n\n    if (attribute.normalized === true) {\n      // assuming Uint8Array\n      this.r /= 255;\n      this.g /= 255;\n      this.b /= 255;\n    }\n\n    return this;\n  }\n\n  toJSON() {\n    return this.getHex();\n  }\n\n}\n\nColor.NAMES = _colorKeywords;\nColor.prototype.isColor = true;\nColor.prototype.r = 1;\nColor.prototype.g = 1;\nColor.prototype.b = 1;\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n * }\n */\n\nclass MeshBasicMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'MeshBasicMaterial';\n    this.color = new Color(0xffffff); // emissive\n\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    return this;\n  }\n\n}\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\nconst _vector$9 = /*@__PURE__*/new Vector3();\n\nconst _vector2$1 = /*@__PURE__*/new Vector2();\n\nclass BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    if (Array.isArray(array)) {\n      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n    }\n\n    this.name = '';\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== undefined ? array.length / itemSize : 0;\n    this.normalized = normalized === true;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {\n      offset: 0,\n      count: -1\n    };\n    this.version = 0;\n  }\n\n  onUploadCallback() {}\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.array = new source.array.constructor(source.array);\n    this.itemSize = source.itemSize;\n    this.count = source.count;\n    this.normalized = source.normalized;\n    this.usage = source.usage;\n    return this;\n  }\n\n  copyAt(index1, attribute, index2) {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  }\n\n  copyArray(array) {\n    this.array.set(array);\n    return this;\n  }\n\n  copyColorsArray(colors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = colors.length; i < l; i++) {\n      let color = colors[i];\n\n      if (color === undefined) {\n        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\n        color = new Color();\n      }\n\n      array[offset++] = color.r;\n      array[offset++] = color.g;\n      array[offset++] = color.b;\n    }\n\n    return this;\n  }\n\n  copyVector2sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\n        vector = new Vector2();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n    }\n\n    return this;\n  }\n\n  copyVector3sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\n        vector = new Vector3();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n    }\n\n    return this;\n  }\n\n  copyVector4sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n\n      if (vector === undefined) {\n        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\n        vector = new Vector4();\n      }\n\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n      array[offset++] = vector.w;\n    }\n\n    return this;\n  }\n\n  applyMatrix3(m) {\n    if (this.itemSize === 2) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector2$1.fromBufferAttribute(this, i);\n\n        _vector2$1.applyMatrix3(m);\n\n        this.setXY(i, _vector2$1.x, _vector2$1.y);\n      }\n    } else if (this.itemSize === 3) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector$9.fromBufferAttribute(this, i);\n\n        _vector$9.applyMatrix3(m);\n\n        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n    }\n\n    return this;\n  }\n\n  applyMatrix4(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n\n      _vector$9.applyMatrix4(m);\n\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n\n      _vector$9.applyNormalMatrix(m);\n\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n\n    return this;\n  }\n\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n\n      _vector$9.transformDirection(m);\n\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n\n    return this;\n  }\n\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n\n  getX(index) {\n    return this.array[index * this.itemSize];\n  }\n\n  setX(index, x) {\n    this.array[index * this.itemSize] = x;\n    return this;\n  }\n\n  getY(index) {\n    return this.array[index * this.itemSize + 1];\n  }\n\n  setY(index, y) {\n    this.array[index * this.itemSize + 1] = y;\n    return this;\n  }\n\n  getZ(index) {\n    return this.array[index * this.itemSize + 2];\n  }\n\n  setZ(index, z) {\n    this.array[index * this.itemSize + 2] = z;\n    return this;\n  }\n\n  getW(index) {\n    return this.array[index * this.itemSize + 3];\n  }\n\n  setW(index, w) {\n    this.array[index * this.itemSize + 3] = w;\n    return this;\n  }\n\n  setXY(index, x, y) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    return this;\n  }\n\n  setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    return this;\n  }\n\n  setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n    return this;\n  }\n\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.array, this.itemSize).copy(this);\n  }\n\n  toJSON() {\n    const data = {\n      itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      array: Array.prototype.slice.call(this.array),\n      normalized: this.normalized\n    };\n    if (this.name !== '') data.name = this.name;\n    if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;\n    return data;\n  }\n\n}\n\nBufferAttribute.prototype.isBufferAttribute = true;\n\nclass Uint16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint32Array(array), itemSize, normalized);\n  }\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n\n}\n\nFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\nclass Float32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Float32Array(array), itemSize, normalized);\n  }\n\n}\n\nfunction arrayMax(array) {\n  if (array.length === 0) return -Infinity;\n  let max = array[0];\n\n  for (let i = 1, l = array.length; i < l; ++i) {\n    if (array[i] > max) max = array[i];\n  }\n\n  return max;\n}\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/new Matrix4();\n\nconst _obj = /*@__PURE__*/new Object3D();\n\nconst _offset = /*@__PURE__*/new Vector3();\n\nconst _box$1 = /*@__PURE__*/new Box3();\n\nconst _boxMorphTargets = /*@__PURE__*/new Box3();\n\nconst _vector$8 = /*@__PURE__*/new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: _id++\n    });\n    this.uuid = generateUUID();\n    this.name = '';\n    this.type = 'BufferGeometry';\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = {\n      start: 0,\n      count: Infinity\n    };\n    this.userData = {};\n  }\n\n  getIndex() {\n    return this.index;\n  }\n\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n\n    return this;\n  }\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n\n  hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  }\n\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n    });\n  }\n\n  clearGroups() {\n    this.groups = [];\n  }\n\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n\n    const normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n\n    const tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  applyQuaternion(q) {\n    _m1.makeRotationFromQuaternion(q);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  setFromPoints(points) {\n    const position = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n\n          _box$1.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(this.boundingBox.min, _box$1.min);\n\n            this.boundingBox.expandByPoint(_vector$8);\n\n            _vector$8.addVectors(this.boundingBox.max, _box$1.max);\n\n            this.boundingBox.expandByPoint(_vector$8);\n          } else {\n            this.boundingBox.expandByPoint(_box$1.min);\n            this.boundingBox.expandByPoint(_box$1.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n\n    if (position) {\n      // first, find the center of the bounding sphere\n      const center = this.boundingSphere.center;\n\n      _box$1.setFromBufferAttribute(position); // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n\n            _box$1.expandByPoint(_vector$8);\n\n            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n\n            _box$1.expandByPoint(_vector$8);\n          } else {\n            _box$1.expandByPoint(_boxMorphTargets.min);\n\n            _box$1.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector$8.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n      } // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector$8.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n\n              _vector$8.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  computeFaceNormals() {// backwards compatibility\n  }\n\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const normals = attributes.normal.array;\n    const uvs = attributes.uv.array;\n    const nVertices = positions.length / 3;\n\n    if (attributes.tangent === undefined) {\n      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n\n    const tangents = attributes.tangent.array;\n    const tan1 = [],\n          tan2 = [];\n\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    const vA = new Vector3(),\n          vB = new Vector3(),\n          vC = new Vector3(),\n          uvA = new Vector2(),\n          uvB = new Vector2(),\n          uvC = new Vector2(),\n          sdir = new Vector3(),\n          tdir = new Vector3();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    let groups = this.groups;\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    const tmp = new Vector3(),\n          tmp2 = new Vector3();\n    const n = new Vector3(),\n          n2 = new Vector3();\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      const t = tan1[v]; // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  }\n\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n\n      const pA = new Vector3(),\n            pB = new Vector3(),\n            pC = new Vector3();\n      const nA = new Vector3(),\n            nB = new Vector3(),\n            nC = new Vector3();\n      const cb = new Vector3(),\n            ab = new Vector3(); // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n\n  merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      const attribute1 = attributes[key];\n      const attributeArray1 = attribute1.array;\n      const attribute2 = geometry.attributes[key];\n      const attributeArray2 = attribute2.array;\n      const attributeOffset = attribute2.itemSize * offset;\n      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      for (let i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  }\n\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector$8.fromBufferAttribute(normals, i);\n\n      _vector$8.normalize();\n\n      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n    }\n  }\n\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n          index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices[i] * itemSize;\n        }\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize, normalized);\n    } //\n\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n      return this;\n    }\n\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes; // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    } // morph attributes\n\n\n    const morphAttributes = this.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes[name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n    const groups = this.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    } // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n    data.data = {\n      attributes: {}\n    };\n    const index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    const groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    const boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  }\n\n  clone() {\n    /*\n     // Handle primitives\n    \t const parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t const values = [];\n    \t for ( const key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t const geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new BufferGeometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // used for storing cloned, shared data\n\n    const data = {}; // name\n\n    this.name = source.name; // index\n\n    const index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    } // attributes\n\n\n    const attributes = source.attributes;\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    } // morph attributes\n\n\n    const morphAttributes = source.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n\n      this.morphAttributes[name] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n    const groups = source.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // draw range\n\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count; // user data\n\n    this.userData = source.userData;\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nBufferGeometry.prototype.isBufferGeometry = true;\n\nconst _inverseMatrix$2 = /*@__PURE__*/new Matrix4();\n\nconst _ray$2 = /*@__PURE__*/new Ray();\n\nconst _sphere$3 = /*@__PURE__*/new Sphere();\n\nconst _vA$1 = /*@__PURE__*/new Vector3();\n\nconst _vB$1 = /*@__PURE__*/new Vector3();\n\nconst _vC$1 = /*@__PURE__*/new Vector3();\n\nconst _tempA = /*@__PURE__*/new Vector3();\n\nconst _tempB = /*@__PURE__*/new Vector3();\n\nconst _tempC = /*@__PURE__*/new Vector3();\n\nconst _morphA = /*@__PURE__*/new Vector3();\n\nconst _morphB = /*@__PURE__*/new Vector3();\n\nconst _morphC = /*@__PURE__*/new Vector3();\n\nconst _uvA$1 = /*@__PURE__*/new Vector2();\n\nconst _uvB$1 = /*@__PURE__*/new Vector2();\n\nconst _uvC$1 = /*@__PURE__*/new Vector2();\n\nconst _intersectionPoint = /*@__PURE__*/new Vector3();\n\nconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\nclass Mesh extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n    super();\n    this.type = 'Mesh';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere$3.copy(geometry.boundingSphere);\n\n    _sphere$3.applyMatrix4(matrixWorld);\n\n    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //\n\n    _inverseMatrix$2.copy(matrixWorld).invert();\n\n    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing\n\n\n    if (geometry.boundingBox !== null) {\n      if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;\n    }\n\n    let intersection;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      const uv = geometry.attributes.uv;\n      const uv2 = geometry.attributes.uv2;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n\n      if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = index.getX(i);\n            const b = index.getX(i + 1);\n            const c = index.getX(i + 2);\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== undefined) {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = i;\n            const b = i + 1;\n            const c = i + 2;\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n}\n\nMesh.prototype.isMesh = true;\n\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\n\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA$1.fromBufferAttribute(position, a);\n\n  _vB$1.fromBufferAttribute(position, b);\n\n  _vC$1.fromBufferAttribute(position, c);\n\n  const morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n\n    _morphB.set(0, 0, 0);\n\n    _morphC.set(0, 0, 0);\n\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n\n      _tempB.fromBufferAttribute(morphAttribute, b);\n\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n\n        _morphB.addScaledVector(_tempB, influence);\n\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n\n        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n\n        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n      }\n    }\n\n    _vA$1.add(_morphA);\n\n    _vB$1.add(_morphB);\n\n    _vC$1.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA$1);\n    object.boneTransform(b, _vB$1);\n    object.boneTransform(c, _vC$1);\n  }\n\n  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n\n  if (intersection) {\n    if (uv) {\n      _uvA$1.fromBufferAttribute(uv, a);\n\n      _uvB$1.fromBufferAttribute(uv, b);\n\n      _uvC$1.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA$1.fromBufferAttribute(uv2, a);\n\n      _uvB$1.fromBufferAttribute(uv2, b);\n\n      _uvC$1.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n    }\n\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nclass BoxGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    super();\n    this.type = 'BoxGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    const scope = this; // segments\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    let numberOfVertices = 0;\n    let groupStart = 0; // build each side of the box geometry\n\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      const segmentWidth = width / gridX;\n      const segmentHeight = height / gridY;\n      const widthHalf = width / 2;\n      const heightHalf = height / 2;\n      const depthHalf = depth / 2;\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new Vector3(); // generate vertices, normals and uvs\n\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf; // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z); // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY); // counters\n\n          vertexCounter += 1;\n        }\n      } // indices\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // increase counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n      groupStart += groupCount; // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n\n  static fromJSON(data) {\n    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  }\n\n}\n/**\n * Uniform Utilities\n */\n\n\nfunction cloneUniforms(src) {\n  const dst = {};\n\n  for (const u in src) {\n    dst[u] = {};\n\n    for (const p in src[u]) {\n      const property = src[u][p];\n\n      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n        dst[u][p] = property.clone();\n      } else if (Array.isArray(property)) {\n        dst[u][p] = property.slice();\n      } else {\n        dst[u][p] = property;\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction mergeUniforms(uniforms) {\n  const merged = {};\n\n  for (let u = 0; u < uniforms.length; u++) {\n    const tmp = cloneUniforms(uniforms[u]);\n\n    for (const p in tmp) {\n      merged[p] = tmp[p];\n    }\n  }\n\n  return merged;\n} // Legacy\n\n\nconst UniformsUtils = {\n  clone: cloneUniforms,\n  merge: mergeUniforms\n};\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>\n * }\n */\n\nclass ShaderMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'ShaderMaterial';\n    this.defines = {};\n    this.uniforms = {};\n    this.vertexShader = default_vertex;\n    this.fragmentShader = default_fragment;\n    this.linewidth = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false; // set to use scene fog\n\n    this.lights = false; // set to use scene lights\n\n    this.clipping = false; // set to use user-defined clipping planes\n\n    this.extensions = {\n      derivatives: false,\n      // set to use derivatives\n      fragDepth: false,\n      // set to use fragment depth values\n      drawBuffers: false,\n      // set to use draw buffers\n      shaderTextureLOD: false // set to use shader texture LOD\n\n    }; // When rendered geometry doesn't include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n    this.defaultAttributeValues = {\n      'color': [1, 1, 1],\n      'uv': [0, 0],\n      'uv2': [0, 0]\n    };\n    this.index0AttributeName = undefined;\n    this.uniformsNeedUpdate = false;\n    this.glslVersion = null;\n\n    if (parameters !== undefined) {\n      if (parameters.attributes !== undefined) {\n        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n      }\n\n      this.setValues(parameters);\n    }\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    this.uniforms = cloneUniforms(source.uniforms);\n    this.defines = Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n    this.extensions = Object.assign({}, source.extensions);\n    this.glslVersion = source.glslVersion;\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n\n    for (const name in this.uniforms) {\n      const uniform = this.uniforms[name];\n      const value = uniform.value;\n\n      if (value && value.isTexture) {\n        data.uniforms[name] = {\n          type: 't',\n          value: value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) {\n        data.uniforms[name] = {\n          type: 'c',\n          value: value.getHex()\n        };\n      } else if (value && value.isVector2) {\n        data.uniforms[name] = {\n          type: 'v2',\n          value: value.toArray()\n        };\n      } else if (value && value.isVector3) {\n        data.uniforms[name] = {\n          type: 'v3',\n          value: value.toArray()\n        };\n      } else if (value && value.isVector4) {\n        data.uniforms[name] = {\n          type: 'v4',\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n        data.uniforms[name] = {\n          type: 'm3',\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n        data.uniforms[name] = {\n          type: 'm4',\n          value: value.toArray()\n        };\n      } else {\n        data.uniforms[name] = {\n          value: value\n        }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n      }\n    }\n\n    if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n    const extensions = {};\n\n    for (const key in this.extensions) {\n      if (this.extensions[key] === true) extensions[key] = true;\n    }\n\n    if (Object.keys(extensions).length > 0) data.extensions = extensions;\n    return data;\n  }\n\n}\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nclass Camera extends Object3D {\n  constructor() {\n    super();\n    this.type = 'Camera';\n    this.matrixWorldInverse = new Matrix4();\n    this.projectionMatrix = new Matrix4();\n    this.projectionMatrixInverse = new Matrix4();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    this.projectionMatrix.copy(source.projectionMatrix);\n    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n    return this;\n  }\n\n  getWorldDirection(target) {\n    this.updateWorldMatrix(true, false);\n    const e = this.matrixWorld.elements;\n    return target.set(-e[8], -e[9], -e[10]).normalize();\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n\n  updateWorldMatrix(updateParents, updateChildren) {\n    super.updateWorldMatrix(updateParents, updateChildren);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nCamera.prototype.isCamera = true;\n\nclass PerspectiveCamera extends Camera {\n  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n    super();\n    this.type = 'PerspectiveCamera';\n    this.fov = fov;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect;\n    this.view = null;\n    this.filmGauge = 35; // width of the film (default in millimeters)\n\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n\n\n  setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n\n\n  getFocalLength() {\n    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n\n  getEffectiveFOV() {\n    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n\n  getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n\n  getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n\n\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n            fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\nconst fov = 90,\n      aspect = 1;\n\nclass CubeCamera extends Object3D {\n  constructor(near, far, renderTarget) {\n    super();\n    this.type = 'CubeCamera';\n\n    if (renderTarget.isWebGLCubeRenderTarget !== true) {\n      console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');\n      return;\n    }\n\n    this.renderTarget = renderTarget;\n    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.layers = this.layers;\n    cameraPX.up.set(0, -1, 0);\n    cameraPX.lookAt(new Vector3(1, 0, 0));\n    this.add(cameraPX);\n    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.layers = this.layers;\n    cameraNX.up.set(0, -1, 0);\n    cameraNX.lookAt(new Vector3(-1, 0, 0));\n    this.add(cameraNX);\n    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.layers = this.layers;\n    cameraPY.up.set(0, 0, 1);\n    cameraPY.lookAt(new Vector3(0, 1, 0));\n    this.add(cameraPY);\n    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = this.layers;\n    cameraNY.up.set(0, 0, -1);\n    cameraNY.lookAt(new Vector3(0, -1, 0));\n    this.add(cameraNY);\n    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = this.layers;\n    cameraPZ.up.set(0, -1, 0);\n    cameraPZ.lookAt(new Vector3(0, 0, 1));\n    this.add(cameraPZ);\n    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = this.layers;\n    cameraNZ.up.set(0, -1, 0);\n    cameraNZ.lookAt(new Vector3(0, 0, -1));\n    this.add(cameraNZ);\n  }\n\n  update(renderer, scene) {\n    if (this.parent === null) this.updateMatrixWorld();\n    const renderTarget = this.renderTarget;\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n    const currentXrEnabled = renderer.xr.enabled;\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.xr.enabled = false;\n    const generateMipmaps = renderTarget.texture.generateMipmaps;\n    renderTarget.texture.generateMipmaps = false;\n    renderer.setRenderTarget(renderTarget, 0);\n    renderer.render(scene, cameraPX);\n    renderer.setRenderTarget(renderTarget, 1);\n    renderer.render(scene, cameraNX);\n    renderer.setRenderTarget(renderTarget, 2);\n    renderer.render(scene, cameraPY);\n    renderer.setRenderTarget(renderTarget, 3);\n    renderer.render(scene, cameraNY);\n    renderer.setRenderTarget(renderTarget, 4);\n    renderer.render(scene, cameraPZ);\n    renderTarget.texture.generateMipmaps = generateMipmaps;\n    renderer.setRenderTarget(renderTarget, 5);\n    renderer.render(scene, cameraNZ);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.xr.enabled = currentXrEnabled;\n  }\n\n}\n\nclass CubeTexture extends Texture$1 {\n  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n    images = images !== undefined ? images : [];\n    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n    format = format !== undefined ? format : RGBFormat;\n    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    this.flipY = false;\n  }\n\n  get images() {\n    return this.image;\n  }\n\n  set images(value) {\n    this.image = value;\n  }\n\n}\n\nCubeTexture.prototype.isCubeTexture = true;\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor(size, options, dummy) {\n    if (Number.isInteger(options)) {\n      console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');\n      options = dummy;\n    }\n\n    super(size, size, options);\n    options = options || {}; // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n    this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n    this.texture._needsFlipEnvMap = false;\n  }\n\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.format = RGBAFormat; // see #18859\n\n    this.texture.encoding = texture.encoding;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader = {\n      uniforms: {\n        tEquirect: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n    };\n    const geometry = new BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: 'CubemapFromEquirect',\n      uniforms: cloneUniforms(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n\n}\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nconst _vector1 = /*@__PURE__*/new Vector3();\n\nconst _vector2 = /*@__PURE__*/new Vector3();\n\nconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\nclass Plane {\n  constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n    // normal is assumed to be normalized\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point, target) {\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      } // Unsure if this is the correct method to handle this case.\n\n\n      return null;\n    }\n\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return null;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nPlane.prototype.isPlane = true;\n\nconst _sphere$2 = /*@__PURE__*/new Sphere();\n\nconst _vector$7 = /*@__PURE__*/new Vector3();\n\nclass Frustum {\n  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n\n  set(p0, p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  }\n\n  copy(frustum) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n\n    return this;\n  }\n\n  setFromProjectionMatrix(m) {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0],\n          me1 = me[1],\n          me2 = me[2],\n          me3 = me[3];\n    const me4 = me[4],\n          me5 = me[5],\n          me6 = me[6],\n          me7 = me[7];\n    const me8 = me[8],\n          me9 = me[9],\n          me10 = me[10],\n          me11 = me[11];\n    const me12 = me[12],\n          me13 = me[13],\n          me14 = me[14],\n          me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n    return this;\n  }\n\n  intersectsObject(object) {\n    const geometry = object.geometry;\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n    return this.intersectsSphere(_sphere$2);\n  }\n\n  intersectsSprite(sprite) {\n    _sphere$2.center.set(0, 0, 0);\n\n    _sphere$2.radius = 0.7071067811865476;\n\n    _sphere$2.applyMatrix4(sprite.matrixWorld);\n\n    return this.intersectsSphere(_sphere$2);\n  }\n\n  intersectsSphere(sphere) {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  intersectsBox(box) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i]; // corner at max distance\n\n      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n      if (plane.distanceToPoint(_vector$7) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  containsPoint(point) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nfunction WebGLAnimation() {\n  let context = null;\n  let isAnimating = false;\n  let animationLoop = null;\n  let requestId = null;\n\n  function onAnimationFrame(time, frame) {\n    animationLoop(time, frame);\n    requestId = context.requestAnimationFrame(onAnimationFrame);\n  }\n\n  return {\n    start: function () {\n      if (isAnimating === true) return;\n      if (animationLoop === null) return;\n      requestId = context.requestAnimationFrame(onAnimationFrame);\n      isAnimating = true;\n    },\n    stop: function () {\n      context.cancelAnimationFrame(requestId);\n      isAnimating = false;\n    },\n    setAnimationLoop: function (callback) {\n      animationLoop = callback;\n    },\n    setContext: function (value) {\n      context = value;\n    }\n  };\n}\n\nfunction WebGLAttributes(gl, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const buffers = new WeakMap();\n\n  function createBuffer(attribute, bufferType) {\n    const array = attribute.array;\n    const usage = attribute.usage;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(bufferType, buffer);\n    gl.bufferData(bufferType, array, usage);\n    attribute.onUploadCallback();\n    let type = 5126;\n\n    if (array instanceof Float32Array) {\n      type = 5126;\n    } else if (array instanceof Float64Array) {\n      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        if (isWebGL2) {\n          type = 5131;\n        } else {\n          console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');\n        }\n      } else {\n        type = 5123;\n      }\n    } else if (array instanceof Int16Array) {\n      type = 5122;\n    } else if (array instanceof Uint32Array) {\n      type = 5125;\n    } else if (array instanceof Int32Array) {\n      type = 5124;\n    } else if (array instanceof Int8Array) {\n      type = 5120;\n    } else if (array instanceof Uint8Array) {\n      type = 5121;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = 5121;\n    }\n\n    return {\n      buffer: buffer,\n      type: type,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version\n    };\n  }\n\n  function updateBuffer(buffer, attribute, bufferType) {\n    const array = attribute.array;\n    const updateRange = attribute.updateRange;\n    gl.bindBuffer(bufferType, buffer);\n\n    if (updateRange.count === -1) {\n      // Not using update ranges\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      if (isWebGL2) {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n      } else {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n      }\n\n      updateRange.count = -1; // reset range\n    }\n  } //\n\n\n  function get(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return buffers.get(attribute);\n  }\n\n  function remove(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    const data = buffers.get(attribute);\n\n    if (data) {\n      gl.deleteBuffer(data.buffer);\n      buffers.delete(attribute);\n    }\n  }\n\n  function update(attribute, bufferType) {\n    if (attribute.isGLBufferAttribute) {\n      const cached = buffers.get(attribute);\n\n      if (!cached || cached.version < attribute.version) {\n        buffers.set(attribute, {\n          buffer: attribute.buffer,\n          type: attribute.type,\n          bytesPerElement: attribute.elementSize,\n          version: attribute.version\n        });\n      }\n\n      return;\n    }\n\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    const data = buffers.get(attribute);\n\n    if (data === undefined) {\n      buffers.set(attribute, createBuffer(attribute, bufferType));\n    } else if (data.version < attribute.version) {\n      updateBuffer(data.buffer, attribute, bufferType);\n      data.version = attribute.version;\n    }\n  }\n\n  return {\n    get: get,\n    remove: remove,\n    update: update\n  };\n}\n\nclass PlaneGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n    super();\n    this.type = 'PlaneGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n    const width_half = width / 2;\n    const height_half = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segment_width = width / gridX;\n    const segment_height = height / gridY; //\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segment_height - height_half;\n\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  static fromJSON(data) {\n    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n  }\n\n}\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn ( f90 - f0 ) * fresnel + f0;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\\tfloat invAlpha = 1.0 / roughness;\\n\\tfloat cos2h = NoH * NoH;\\n\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 H = normalize( V + L );\\n\\tfloat dotNH = saturate( dot( N, H ) );\\n\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\";\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = - mvPosition.z;\\n#endif\";\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\";\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\";\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\\t#ifdef SPECULAR\\n\\t\\tvec3 specularIntensityFactor = vec3( specularIntensity );\\n\\t\\tvec3 specularTintFactor = specularTint;\\n\\t\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULARTINTMAP\\n\\t\\t\\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\\n\\t\\t#endif\\n\\t\\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\\n\\t#else\\n\\t\\tvec3 specularIntensityFactor = vec3( 1.0 );\\n\\t\\tvec3 specularTintFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularColorF90 = vec3( 1.0 );\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularColorF90 = vec3( 1.0 );\\n#endif\\n#ifdef CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheen;\\n#endif\";\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularRoughness;\\n\\tvec3 specularColor;\\n\\tvec3 specularColorF90;\\n#ifdef CLEARCOAT\\n\\tfloat clearcoat;\\n\\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tccIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\\t\\t\\tmaterial.specularRoughness,\\n\\t\\t\\tdirectLight.direction,\\n\\t\\t\\tgeometry,\\n\\t\\t\\tmaterial.sheenColor\\n\\t\\t);\\n\\t#else\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\\n\\t#endif\\n\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t\\tfloat ccDotNL = ccDotNV;\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\\t#ifdef CLEARCOAT\\n\\t\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\\t#endif\\n#endif\";\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\nvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\nvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\";\nvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\";\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\";\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\";\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\tfloat transmissionFactor = transmission;\\n\\tfloat thicknessFactor = thickness;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\\n\\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\\n\\t\\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationTint, attenuationDistance );\\n\\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\\n#endif\";\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec4 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\\n\\t\\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\\n\\t\\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\\n\\t\\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\\n\\t\\treturn normalize(refractionVector) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness(float roughness, float ior) {\\n\\t\\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\\n\\t}\\n\\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\\n\\t\\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\\n\\t\\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\\n\\t}\\n\\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tif (attenuationDistance == 0.0) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\\n\\t\\tvec3 attenuationColor, float attenuationDistance) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\\n\\t\\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\\n\\t}\\n#endif\";\nvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\";\nvar uv_pars_vertex = \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\";\nvar uv_vertex = \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\";\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\nvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t\\t#endif\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\nvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\nvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define REFLECTIVITY\\n\\t#define CLEARCOAT\\n\\t#define SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationTint;\\n#endif\\n#ifdef REFLECTIVITY\\n\\tuniform float reflectivity;\\n#endif\\n#ifdef SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularTint;\\n\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULARTINTMAP\\n\\t\\tuniform sampler2D specularTintMap;\\n\\t#endif\\n#endif\\n#ifdef CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <transmission_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\nvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec4 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition;\\n#endif\\n}\";\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\nvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\nconst ShaderChunk = {\n  alphamap_fragment: alphamap_fragment,\n  alphamap_pars_fragment: alphamap_pars_fragment,\n  alphatest_fragment: alphatest_fragment,\n  aomap_fragment: aomap_fragment,\n  aomap_pars_fragment: aomap_pars_fragment,\n  begin_vertex: begin_vertex,\n  beginnormal_vertex: beginnormal_vertex,\n  bsdfs: bsdfs,\n  bumpmap_pars_fragment: bumpmap_pars_fragment,\n  clipping_planes_fragment: clipping_planes_fragment,\n  clipping_planes_pars_fragment: clipping_planes_pars_fragment,\n  clipping_planes_pars_vertex: clipping_planes_pars_vertex,\n  clipping_planes_vertex: clipping_planes_vertex,\n  color_fragment: color_fragment,\n  color_pars_fragment: color_pars_fragment,\n  color_pars_vertex: color_pars_vertex,\n  color_vertex: color_vertex,\n  common: common,\n  cube_uv_reflection_fragment: cube_uv_reflection_fragment,\n  defaultnormal_vertex: defaultnormal_vertex,\n  displacementmap_pars_vertex: displacementmap_pars_vertex,\n  displacementmap_vertex: displacementmap_vertex,\n  emissivemap_fragment: emissivemap_fragment,\n  emissivemap_pars_fragment: emissivemap_pars_fragment,\n  encodings_fragment: encodings_fragment,\n  encodings_pars_fragment: encodings_pars_fragment,\n  envmap_fragment: envmap_fragment,\n  envmap_common_pars_fragment: envmap_common_pars_fragment,\n  envmap_pars_fragment: envmap_pars_fragment,\n  envmap_pars_vertex: envmap_pars_vertex,\n  envmap_physical_pars_fragment: envmap_physical_pars_fragment,\n  envmap_vertex: envmap_vertex,\n  fog_vertex: fog_vertex,\n  fog_pars_vertex: fog_pars_vertex,\n  fog_fragment: fog_fragment,\n  fog_pars_fragment: fog_pars_fragment,\n  gradientmap_pars_fragment: gradientmap_pars_fragment,\n  lightmap_fragment: lightmap_fragment,\n  lightmap_pars_fragment: lightmap_pars_fragment,\n  lights_lambert_vertex: lights_lambert_vertex,\n  lights_pars_begin: lights_pars_begin,\n  lights_toon_fragment: lights_toon_fragment,\n  lights_toon_pars_fragment: lights_toon_pars_fragment,\n  lights_phong_fragment: lights_phong_fragment,\n  lights_phong_pars_fragment: lights_phong_pars_fragment,\n  lights_physical_fragment: lights_physical_fragment,\n  lights_physical_pars_fragment: lights_physical_pars_fragment,\n  lights_fragment_begin: lights_fragment_begin,\n  lights_fragment_maps: lights_fragment_maps,\n  lights_fragment_end: lights_fragment_end,\n  logdepthbuf_fragment: logdepthbuf_fragment,\n  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n  logdepthbuf_vertex: logdepthbuf_vertex,\n  map_fragment: map_fragment,\n  map_pars_fragment: map_pars_fragment,\n  map_particle_fragment: map_particle_fragment,\n  map_particle_pars_fragment: map_particle_pars_fragment,\n  metalnessmap_fragment: metalnessmap_fragment,\n  metalnessmap_pars_fragment: metalnessmap_pars_fragment,\n  morphnormal_vertex: morphnormal_vertex,\n  morphtarget_pars_vertex: morphtarget_pars_vertex,\n  morphtarget_vertex: morphtarget_vertex,\n  normal_fragment_begin: normal_fragment_begin,\n  normal_fragment_maps: normal_fragment_maps,\n  normalmap_pars_fragment: normalmap_pars_fragment,\n  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n  clearcoat_pars_fragment: clearcoat_pars_fragment,\n  packing: packing,\n  premultiplied_alpha_fragment: premultiplied_alpha_fragment,\n  project_vertex: project_vertex,\n  dithering_fragment: dithering_fragment,\n  dithering_pars_fragment: dithering_pars_fragment,\n  roughnessmap_fragment: roughnessmap_fragment,\n  roughnessmap_pars_fragment: roughnessmap_pars_fragment,\n  shadowmap_pars_fragment: shadowmap_pars_fragment,\n  shadowmap_pars_vertex: shadowmap_pars_vertex,\n  shadowmap_vertex: shadowmap_vertex,\n  shadowmask_pars_fragment: shadowmask_pars_fragment,\n  skinbase_vertex: skinbase_vertex,\n  skinning_pars_vertex: skinning_pars_vertex,\n  skinning_vertex: skinning_vertex,\n  skinnormal_vertex: skinnormal_vertex,\n  specularmap_fragment: specularmap_fragment,\n  specularmap_pars_fragment: specularmap_pars_fragment,\n  tonemapping_fragment: tonemapping_fragment,\n  tonemapping_pars_fragment: tonemapping_pars_fragment,\n  transmission_fragment: transmission_fragment,\n  transmission_pars_fragment: transmission_pars_fragment,\n  uv_pars_fragment: uv_pars_fragment,\n  uv_pars_vertex: uv_pars_vertex,\n  uv_vertex: uv_vertex,\n  uv2_pars_fragment: uv2_pars_fragment,\n  uv2_pars_vertex: uv2_pars_vertex,\n  uv2_vertex: uv2_vertex,\n  worldpos_vertex: worldpos_vertex,\n  background_frag: background_frag,\n  background_vert: background_vert,\n  cube_frag: cube_frag,\n  cube_vert: cube_vert,\n  depth_frag: depth_frag,\n  depth_vert: depth_vert,\n  distanceRGBA_frag: distanceRGBA_frag,\n  distanceRGBA_vert: distanceRGBA_vert,\n  equirect_frag: equirect_frag,\n  equirect_vert: equirect_vert,\n  linedashed_frag: linedashed_frag,\n  linedashed_vert: linedashed_vert,\n  meshbasic_frag: meshbasic_frag,\n  meshbasic_vert: meshbasic_vert,\n  meshlambert_frag: meshlambert_frag,\n  meshlambert_vert: meshlambert_vert,\n  meshmatcap_frag: meshmatcap_frag,\n  meshmatcap_vert: meshmatcap_vert,\n  meshtoon_frag: meshtoon_frag,\n  meshtoon_vert: meshtoon_vert,\n  meshphong_frag: meshphong_frag,\n  meshphong_vert: meshphong_vert,\n  meshphysical_frag: meshphysical_frag,\n  meshphysical_vert: meshphysical_vert,\n  normal_frag: normal_frag,\n  normal_vert: normal_vert,\n  points_frag: points_frag,\n  points_vert: points_vert,\n  shadow_frag: shadow_frag,\n  shadow_vert: shadow_vert,\n  sprite_frag: sprite_frag,\n  sprite_vert: sprite_vert\n};\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n  common: {\n    diffuse: {\n      value: new Color(0xffffff)\n    },\n    opacity: {\n      value: 1.0\n    },\n    map: {\n      value: null\n    },\n    uvTransform: {\n      value: new Matrix3()\n    },\n    uv2Transform: {\n      value: new Matrix3()\n    },\n    alphaMap: {\n      value: null\n    }\n  },\n  specularmap: {\n    specularMap: {\n      value: null\n    }\n  },\n  envmap: {\n    envMap: {\n      value: null\n    },\n    flipEnvMap: {\n      value: -1\n    },\n    reflectivity: {\n      value: 1.0\n    },\n    refractionRatio: {\n      value: 0.98\n    },\n    maxMipLevel: {\n      value: 0\n    }\n  },\n  aomap: {\n    aoMap: {\n      value: null\n    },\n    aoMapIntensity: {\n      value: 1\n    }\n  },\n  lightmap: {\n    lightMap: {\n      value: null\n    },\n    lightMapIntensity: {\n      value: 1\n    }\n  },\n  emissivemap: {\n    emissiveMap: {\n      value: null\n    }\n  },\n  bumpmap: {\n    bumpMap: {\n      value: null\n    },\n    bumpScale: {\n      value: 1\n    }\n  },\n  normalmap: {\n    normalMap: {\n      value: null\n    },\n    normalScale: {\n      value: new Vector2(1, 1)\n    }\n  },\n  displacementmap: {\n    displacementMap: {\n      value: null\n    },\n    displacementScale: {\n      value: 1\n    },\n    displacementBias: {\n      value: 0\n    }\n  },\n  roughnessmap: {\n    roughnessMap: {\n      value: null\n    }\n  },\n  metalnessmap: {\n    metalnessMap: {\n      value: null\n    }\n  },\n  gradientmap: {\n    gradientMap: {\n      value: null\n    }\n  },\n  fog: {\n    fogDensity: {\n      value: 0.00025\n    },\n    fogNear: {\n      value: 1\n    },\n    fogFar: {\n      value: 2000\n    },\n    fogColor: {\n      value: new Color(0xffffff)\n    }\n  },\n  lights: {\n    ambientLightColor: {\n      value: []\n    },\n    lightProbe: {\n      value: []\n    },\n    directionalLights: {\n      value: [],\n      properties: {\n        direction: {},\n        color: {}\n      }\n    },\n    directionalLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      }\n    },\n    directionalShadowMap: {\n      value: []\n    },\n    directionalShadowMatrix: {\n      value: []\n    },\n    spotLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        direction: {},\n        distance: {},\n        coneCos: {},\n        penumbraCos: {},\n        decay: {}\n      }\n    },\n    spotLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      }\n    },\n    spotShadowMap: {\n      value: []\n    },\n    spotShadowMatrix: {\n      value: []\n    },\n    pointLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        decay: {},\n        distance: {}\n      }\n    },\n    pointLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {},\n        shadowCameraNear: {},\n        shadowCameraFar: {}\n      }\n    },\n    pointShadowMap: {\n      value: []\n    },\n    pointShadowMatrix: {\n      value: []\n    },\n    hemisphereLights: {\n      value: [],\n      properties: {\n        direction: {},\n        skyColor: {},\n        groundColor: {}\n      }\n    },\n    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n    rectAreaLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        width: {},\n        height: {}\n      }\n    },\n    ltc_1: {\n      value: null\n    },\n    ltc_2: {\n      value: null\n    }\n  },\n  points: {\n    diffuse: {\n      value: new Color(0xffffff)\n    },\n    opacity: {\n      value: 1.0\n    },\n    size: {\n      value: 1.0\n    },\n    scale: {\n      value: 1.0\n    },\n    map: {\n      value: null\n    },\n    alphaMap: {\n      value: null\n    },\n    uvTransform: {\n      value: new Matrix3()\n    }\n  },\n  sprite: {\n    diffuse: {\n      value: new Color(0xffffff)\n    },\n    opacity: {\n      value: 1.0\n    },\n    center: {\n      value: new Vector2(0.5, 0.5)\n    },\n    rotation: {\n      value: 0.0\n    },\n    map: {\n      value: null\n    },\n    alphaMap: {\n      value: null\n    },\n    uvTransform: {\n      value: new Matrix3()\n    }\n  }\n};\nconst ShaderLib = {\n  basic: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),\n    vertexShader: ShaderChunk.meshbasic_vert,\n    fragmentShader: ShaderChunk.meshbasic_frag\n  },\n  lambert: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      }\n    }]),\n    vertexShader: ShaderChunk.meshlambert_vert,\n    fragmentShader: ShaderChunk.meshlambert_frag\n  },\n  phong: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      },\n      specular: {\n        value: new Color(0x111111)\n      },\n      shininess: {\n        value: 30\n      }\n    }]),\n    vertexShader: ShaderChunk.meshphong_vert,\n    fragmentShader: ShaderChunk.meshphong_frag\n  },\n  standard: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      },\n      roughness: {\n        value: 1.0\n      },\n      metalness: {\n        value: 0.0\n      },\n      envMapIntensity: {\n        value: 1\n      } // temporary\n\n    }]),\n    vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: ShaderChunk.meshphysical_frag\n  },\n  toon: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      }\n    }]),\n    vertexShader: ShaderChunk.meshtoon_vert,\n    fragmentShader: ShaderChunk.meshtoon_frag\n  },\n  matcap: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {\n      matcap: {\n        value: null\n      }\n    }]),\n    vertexShader: ShaderChunk.meshmatcap_vert,\n    fragmentShader: ShaderChunk.meshmatcap_frag\n  },\n  points: {\n    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),\n    vertexShader: ShaderChunk.points_vert,\n    fragmentShader: ShaderChunk.points_frag\n  },\n  dashed: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {\n      scale: {\n        value: 1\n      },\n      dashSize: {\n        value: 1\n      },\n      totalSize: {\n        value: 2\n      }\n    }]),\n    vertexShader: ShaderChunk.linedashed_vert,\n    fragmentShader: ShaderChunk.linedashed_frag\n  },\n  depth: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),\n    vertexShader: ShaderChunk.depth_vert,\n    fragmentShader: ShaderChunk.depth_frag\n  },\n  normal: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {\n      opacity: {\n        value: 1.0\n      }\n    }]),\n    vertexShader: ShaderChunk.normal_vert,\n    fragmentShader: ShaderChunk.normal_frag\n  },\n  sprite: {\n    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),\n    vertexShader: ShaderChunk.sprite_vert,\n    fragmentShader: ShaderChunk.sprite_frag\n  },\n  background: {\n    uniforms: {\n      uvTransform: {\n        value: new Matrix3()\n      },\n      t2D: {\n        value: null\n      }\n    },\n    vertexShader: ShaderChunk.background_vert,\n    fragmentShader: ShaderChunk.background_frag\n  },\n\n  /* -------------------------------------------------------------------------\n  //\tCube map shader\n   ------------------------------------------------------------------------- */\n  cube: {\n    uniforms: mergeUniforms([UniformsLib.envmap, {\n      opacity: {\n        value: 1.0\n      }\n    }]),\n    vertexShader: ShaderChunk.cube_vert,\n    fragmentShader: ShaderChunk.cube_frag\n  },\n  equirect: {\n    uniforms: {\n      tEquirect: {\n        value: null\n      }\n    },\n    vertexShader: ShaderChunk.equirect_vert,\n    fragmentShader: ShaderChunk.equirect_frag\n  },\n  distanceRGBA: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {\n      referencePosition: {\n        value: new Vector3()\n      },\n      nearDistance: {\n        value: 1\n      },\n      farDistance: {\n        value: 1000\n      }\n    }]),\n    vertexShader: ShaderChunk.distanceRGBA_vert,\n    fragmentShader: ShaderChunk.distanceRGBA_frag\n  },\n  shadow: {\n    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {\n      color: {\n        value: new Color(0x00000)\n      },\n      opacity: {\n        value: 1.0\n      }\n    }]),\n    vertexShader: ShaderChunk.shadow_vert,\n    fragmentShader: ShaderChunk.shadow_frag\n  }\n};\nShaderLib.physical = {\n  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {\n    clearcoat: {\n      value: 0\n    },\n    clearcoatMap: {\n      value: null\n    },\n    clearcoatRoughness: {\n      value: 0\n    },\n    clearcoatRoughnessMap: {\n      value: null\n    },\n    clearcoatNormalScale: {\n      value: new Vector2(1, 1)\n    },\n    clearcoatNormalMap: {\n      value: null\n    },\n    sheen: {\n      value: new Color(0x000000)\n    },\n    transmission: {\n      value: 0\n    },\n    transmissionMap: {\n      value: null\n    },\n    transmissionSamplerSize: {\n      value: new Vector2()\n    },\n    transmissionSamplerMap: {\n      value: null\n    },\n    thickness: {\n      value: 0\n    },\n    thicknessMap: {\n      value: null\n    },\n    attenuationDistance: {\n      value: 0\n    },\n    attenuationTint: {\n      value: new Color(0x000000)\n    },\n    specularIntensity: {\n      value: 0\n    },\n    specularIntensityMap: {\n      value: null\n    },\n    specularTint: {\n      value: new Color(1, 1, 1)\n    },\n    specularTintMap: {\n      value: null\n    }\n  }]),\n  vertexShader: ShaderChunk.meshphysical_vert,\n  fragmentShader: ShaderChunk.meshphysical_frag\n};\n\nfunction WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {\n  const clearColor = new Color(0x000000);\n  let clearAlpha = 0;\n  let planeMesh;\n  let boxMesh;\n  let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let currentTonemapping = null;\n\n  function render(renderList, scene) {\n    let forceClear = false;\n    let background = scene.isScene === true ? scene.background : null;\n\n    if (background && background.isTexture) {\n      background = cubemaps.get(background);\n    } // Ignore background in AR\n    // TODO: Reconsider this.\n\n\n    const xr = renderer.xr;\n    const session = xr.getSession && xr.getSession();\n\n    if (session && session.environmentBlendMode === 'additive') {\n      background = null;\n    }\n\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n\n    if (renderer.autoClear || forceClear) {\n      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    }\n\n    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === undefined) {\n        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n          name: 'BackgroundCubeMaterial',\n          uniforms: cloneUniforms(ShaderLib.cube.uniforms),\n          vertexShader: ShaderLib.cube.vertexShader,\n          fragmentShader: ShaderLib.cube.fragmentShader,\n          side: BackSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        boxMesh.geometry.deleteAttribute('normal');\n        boxMesh.geometry.deleteAttribute('uv');\n\n        boxMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        }; // enable code injection for non-built-in material\n\n\n        Object.defineProperty(boxMesh.material, 'envMap', {\n          get: function () {\n            return this.uniforms.envMap.value;\n          }\n        });\n        objects.update(boxMesh);\n      }\n\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;\n\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        boxMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      } // push to the pre-sorted opaque render list\n\n\n      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background && background.isTexture) {\n      if (planeMesh === undefined) {\n        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n          name: 'BackgroundMaterial',\n          uniforms: cloneUniforms(ShaderLib.background.uniforms),\n          vertexShader: ShaderLib.background.vertexShader,\n          fragmentShader: ShaderLib.background.fragmentShader,\n          side: FrontSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material\n\n        Object.defineProperty(planeMesh.material, 'map', {\n          get: function () {\n            return this.uniforms.t2D.value;\n          }\n        });\n        objects.update(planeMesh);\n      }\n\n      planeMesh.material.uniforms.t2D.value = background;\n\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        planeMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      } // push to the pre-sorted opaque render list\n\n\n      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n\n  function setClear(color, alpha) {\n    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n  }\n\n  return {\n    getClearColor: function () {\n      return clearColor;\n    },\n    setClearColor: function (color, alpha = 1) {\n      clearColor.set(color);\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function () {\n      return clearAlpha;\n    },\n    setClearAlpha: function (alpha) {\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    render: render\n  };\n}\n\nfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  const maxVertexAttributes = gl.getParameter(34921);\n  const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n  const vaoAvailable = capabilities.isWebGL2 || extension !== null;\n  const bindingStates = {};\n  const defaultState = createBindingState(null);\n  let currentState = defaultState;\n\n  function setup(object, material, program, geometry, index) {\n    let updateBuffers = false;\n\n    if (vaoAvailable) {\n      const state = getBindingState(geometry, program, material);\n\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n\n      updateBuffers = needsUpdate(geometry, index);\n      if (updateBuffers) saveCache(geometry, index);\n    } else {\n      const wireframe = material.wireframe === true;\n\n      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n        updateBuffers = true;\n      }\n    }\n\n    if (object.isInstancedMesh === true) {\n      updateBuffers = true;\n    }\n\n    if (index !== null) {\n      attributes.update(index, 34963);\n    }\n\n    if (updateBuffers) {\n      setupVertexAttributes(object, material, program, geometry);\n\n      if (index !== null) {\n        gl.bindBuffer(34963, attributes.get(index).buffer);\n      }\n    }\n  }\n\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2) return gl.createVertexArray();\n    return extension.createVertexArrayOES();\n  }\n\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n    return extension.bindVertexArrayOES(vao);\n  }\n\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n    return extension.deleteVertexArrayOES(vao);\n  }\n\n  function getBindingState(geometry, program, material) {\n    const wireframe = material.wireframe === true;\n    let programMap = bindingStates[geometry.id];\n\n    if (programMap === undefined) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n\n    let stateMap = programMap[program.id];\n\n    if (stateMap === undefined) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n\n    let state = stateMap[wireframe];\n\n    if (state === undefined) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n\n    return state;\n  }\n\n  function createBindingState(vao) {\n    const newAttributes = [];\n    const enabledAttributes = [];\n    const attributeDivisors = [];\n\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes: newAttributes,\n      enabledAttributes: enabledAttributes,\n      attributeDivisors: attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n\n  function needsUpdate(geometry, index) {\n    const cachedAttributes = currentState.attributes;\n    const geometryAttributes = geometry.attributes;\n    let attributesNum = 0;\n\n    for (const key in geometryAttributes) {\n      const cachedAttribute = cachedAttributes[key];\n      const geometryAttribute = geometryAttributes[key];\n      if (cachedAttribute === undefined) return true;\n      if (cachedAttribute.attribute !== geometryAttribute) return true;\n      if (cachedAttribute.data !== geometryAttribute.data) return true;\n      attributesNum++;\n    }\n\n    if (currentState.attributesNum !== attributesNum) return true;\n    if (currentState.index !== index) return true;\n    return false;\n  }\n\n  function saveCache(geometry, index) {\n    const cache = {};\n    const attributes = geometry.attributes;\n    let attributesNum = 0;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const data = {};\n      data.attribute = attribute;\n\n      if (attribute.data) {\n        data.data = attribute.data;\n      }\n\n      cache[key] = data;\n      attributesNum++;\n    }\n\n    currentState.attributes = cache;\n    currentState.attributesNum = attributesNum;\n    currentState.index = index;\n  }\n\n  function initAttributes() {\n    const newAttributes = currentState.newAttributes;\n\n    for (let i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    const attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n\n  function disableUnusedAttributes() {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n\n    for (let i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n      if (extensions.get('ANGLE_instanced_arrays') === null) return;\n    }\n\n    initAttributes();\n    const geometryAttributes = geometry.attributes;\n    const programAttributes = program.getAttributes();\n    const materialDefaultAttributeValues = material.defaultAttributeValues;\n\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n\n      if (programAttribute >= 0) {\n        const geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute !== undefined) {\n          const normalized = geometryAttribute.normalized;\n          const size = geometryAttribute.itemSize;\n          const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          const bytesPerElement = attribute.bytesPerElement;\n\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data = geometryAttribute.data;\n            const stride = data.stride;\n            const offset = geometryAttribute.offset;\n\n            if (data && data.isInstancedInterleavedBuffer) {\n              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\n\n              if (geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              enableAttribute(programAttribute);\n            }\n\n            gl.bindBuffer(34962, buffer);\n            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\n\n              if (geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              enableAttribute(programAttribute);\n            }\n\n            gl.bindBuffer(34962, buffer);\n            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\n          }\n        } else if (name === 'instanceMatrix') {\n          const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          enableAttributeAndDivisor(programAttribute + 0, 1);\n          enableAttributeAndDivisor(programAttribute + 1, 1);\n          enableAttributeAndDivisor(programAttribute + 2, 1);\n          enableAttributeAndDivisor(programAttribute + 3, 1);\n          gl.bindBuffer(34962, buffer);\n          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);\n          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);\n          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);\n          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);\n        } else if (name === 'instanceColor') {\n          const attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          enableAttributeAndDivisor(programAttribute, 1);\n          gl.bindBuffer(34962, buffer);\n          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);\n        } else if (materialDefaultAttributeValues !== undefined) {\n          const value = materialDefaultAttributeValues[name];\n\n          if (value !== undefined) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute, value);\n                break;\n\n              case 3:\n                gl.vertexAttrib3fv(programAttribute, value);\n                break;\n\n              case 4:\n                gl.vertexAttrib4fv(programAttribute, value);\n                break;\n\n              default:\n                gl.vertexAttrib1fv(programAttribute, value);\n            }\n          }\n        }\n      }\n    }\n\n    disableUnusedAttributes();\n  }\n\n  function dispose() {\n    reset();\n\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n\n      for (const programId in programMap) {\n        const stateMap = programMap[programId];\n\n        for (const wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n\n        delete programMap[programId];\n      }\n\n      delete bindingStates[geometryId];\n    }\n  }\n\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === undefined) return;\n    const programMap = bindingStates[geometry.id];\n\n    for (const programId in programMap) {\n      const stateMap = programMap[programId];\n\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[programId];\n    }\n\n    delete bindingStates[geometry.id];\n  }\n\n  function releaseStatesOfProgram(program) {\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      if (programMap[program.id] === undefined) continue;\n      const stateMap = programMap[program.id];\n\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[program.id];\n    }\n  }\n\n  function reset() {\n    resetDefaultState();\n    if (currentState === defaultState) return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  } // for backward-compatilibity\n\n\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n\n  return {\n    setup: setup,\n    reset: reset,\n    resetDefaultState: resetDefaultState,\n    dispose: dispose,\n    releaseStatesOfGeometry: releaseStatesOfGeometry,\n    releaseStatesOfProgram: releaseStatesOfProgram,\n    initAttributes: initAttributes,\n    enableAttribute: enableAttribute,\n    disableUnusedAttributes: disableUnusedAttributes\n  };\n}\n\nfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  let mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  function render(start, count) {\n    gl.drawArrays(mode, start, count);\n    info.update(count, mode, 1);\n  }\n\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n    let extension, methodName;\n\n    if (isWebGL2) {\n      extension = gl;\n      methodName = 'drawArraysInstanced';\n    } else {\n      extension = extensions.get('ANGLE_instanced_arrays');\n      methodName = 'drawArraysInstancedANGLE';\n\n      if (extension === null) {\n        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n        return;\n      }\n    }\n\n    extension[methodName](mode, start, count, primcount);\n    info.update(count, mode, primcount);\n  } //\n\n\n  this.setMode = setMode;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\n\nfunction WebGLCapabilities(gl, extensions, parameters) {\n  let maxAnisotropy;\n\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== undefined) return maxAnisotropy;\n\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      maxAnisotropy = 0;\n    }\n\n    return maxAnisotropy;\n  }\n\n  function getMaxPrecision(precision) {\n    if (precision === 'highp') {\n      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {\n        return 'highp';\n      }\n\n      precision = 'mediump';\n    }\n\n    if (precision === 'mediump') {\n      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {\n        return 'mediump';\n      }\n    }\n\n    return 'lowp';\n  }\n  /* eslint-disable no-undef */\n\n\n  const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;\n  /* eslint-enable no-undef */\n\n  let precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n  const maxPrecision = getMaxPrecision(precision);\n\n  if (maxPrecision !== precision) {\n    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');\n    precision = maxPrecision;\n  }\n\n  const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');\n  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n  const maxTextures = gl.getParameter(34930);\n  const maxVertexTextures = gl.getParameter(35660);\n  const maxTextureSize = gl.getParameter(3379);\n  const maxCubemapSize = gl.getParameter(34076);\n  const maxAttributes = gl.getParameter(34921);\n  const maxVertexUniforms = gl.getParameter(36347);\n  const maxVaryings = gl.getParameter(36348);\n  const maxFragmentUniforms = gl.getParameter(36349);\n  const vertexTextures = maxVertexTextures > 0;\n  const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');\n  const floatVertexTextures = vertexTextures && floatFragmentTextures;\n  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;\n  return {\n    isWebGL2: isWebGL2,\n    drawBuffers: drawBuffers,\n    getMaxAnisotropy: getMaxAnisotropy,\n    getMaxPrecision: getMaxPrecision,\n    precision: precision,\n    logarithmicDepthBuffer: logarithmicDepthBuffer,\n    maxTextures: maxTextures,\n    maxVertexTextures: maxVertexTextures,\n    maxTextureSize: maxTextureSize,\n    maxCubemapSize: maxCubemapSize,\n    maxAttributes: maxAttributes,\n    maxVertexUniforms: maxVertexUniforms,\n    maxVaryings: maxVaryings,\n    maxFragmentUniforms: maxFragmentUniforms,\n    vertexTextures: vertexTextures,\n    floatFragmentTextures: floatFragmentTextures,\n    floatVertexTextures: floatVertexTextures,\n    maxSamples: maxSamples\n  };\n}\n\nfunction WebGLClipping(properties) {\n  const scope = this;\n  let globalState = null,\n      numGlobalPlanes = 0,\n      localClippingEnabled = false,\n      renderingShadows = false;\n  const plane = new Plane(),\n        viewNormalMatrix = new Matrix3(),\n        uniform = {\n    value: null,\n    needsUpdate: false\n  };\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n\n  this.init = function (planes, enableLocalClipping, camera) {\n    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n    // run another frame in order to reset the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n\n  this.beginShadows = function () {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n\n  this.endShadows = function () {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n\n  this.setState = function (material, camera, useCache) {\n    const planes = material.clippingPlanes,\n          clipIntersection = material.clipIntersection,\n          clipShadows = material.clipShadows;\n    const materialProperties = properties.get(material);\n\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      // there's no local clipping\n      if (renderingShadows) {\n        // there's no global clipping\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n            lGlobal = nGlobal * 4;\n      let dstArray = materialProperties.clippingState || null;\n      uniform.value = dstArray; // ensure unique state\n\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n      for (let i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    const nPlanes = planes !== null ? planes.length : 0;\n    let dstArray = null;\n\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n\n      if (skipTransform !== true || dstArray === null) {\n        const flatSize = dstOffset + nPlanes * 4,\n              viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n\n        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n    return dstArray;\n  }\n}\n\nfunction WebGLCubeMaps(renderer) {\n  let cubemaps = new WeakMap();\n\n  function mapTextureMapping(texture, mapping) {\n    if (mapping === EquirectangularReflectionMapping) {\n      texture.mapping = CubeReflectionMapping;\n    } else if (mapping === EquirectangularRefractionMapping) {\n      texture.mapping = CubeRefractionMapping;\n    }\n\n    return texture;\n  }\n\n  function get(texture) {\n    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {\n      const mapping = texture.mapping;\n\n      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n        if (cubemaps.has(texture)) {\n          const cubemap = cubemaps.get(texture).texture;\n          return mapTextureMapping(cubemap, texture.mapping);\n        } else {\n          const image = texture.image;\n\n          if (image && image.height > 0) {\n            const currentRenderTarget = renderer.getRenderTarget();\n            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n            renderTarget.fromEquirectangularTexture(renderer, texture);\n            cubemaps.set(texture, renderTarget);\n            renderer.setRenderTarget(currentRenderTarget);\n            texture.addEventListener('dispose', onTextureDispose);\n            return mapTextureMapping(renderTarget.texture, texture.mapping);\n          } else {\n            // image not yet ready. try the conversion next frame\n            return null;\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    const cubemap = cubemaps.get(texture);\n\n    if (cubemap !== undefined) {\n      cubemaps.delete(texture);\n      cubemap.dispose();\n    }\n  }\n\n  function dispose() {\n    cubemaps = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nclass OrthographicCamera extends Camera {\n  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {\n    super();\n    this.type = 'OrthographicCamera';\n    this.zoom = 1;\n    this.view = null;\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    this.near = near;\n    this.far = far;\n    this.updateProjectionMatrix();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.left = source.left;\n    this.right = source.right;\n    this.top = source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n    this.zoom = source.zoom;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    return this;\n  }\n\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix() {\n    const dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n\n    if (this.view !== null && this.view.enabled) {\n      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n\n    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.zoom = this.zoom;\n    data.object.left = this.left;\n    data.object.right = this.right;\n    data.object.top = this.top;\n    data.object.bottom = this.bottom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    return data;\n  }\n\n}\n\nOrthographicCamera.prototype.isOrthographicCamera = true;\n\nclass RawShaderMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super(parameters);\n    this.type = 'RawShaderMaterial';\n  }\n\n}\n\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nconst MAX_SAMPLES = 20;\nconst ENCODINGS = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\nconst backgroundMaterial = new MeshBasicMaterial({\n  side: BackSide,\n  depthWrite: false,\n  depthTest: false\n});\nconst backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n\nconst _flatCamera$1 = /*@__PURE__*/new OrthographicCamera();\n\nconst {\n  _lodPlanes,\n  _sizeLods,\n  _sigmas\n} = /*@__PURE__*/_createPlanes();\n\nconst _clearColor = /*@__PURE__*/new Color();\n\nlet _oldTarget = null; // Golden Ratio\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nfunction convertLinearToRGBE(color) {\n  const maxComponent = Math.max(color.r, color.g, color.b);\n  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n  color.multiplyScalar(Math.pow(2.0, -fExp));\n  const alpha = (fExp + 128.0) / 255.0;\n  return alpha;\n}\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._blurMaterial = _getBlurShader(MAX_SAMPLES);\n    this._equirectShader = null;\n    this._cubemapShader = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n\n\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = this._allocateTargets();\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromEquirectangular(equirectangular) {\n    return this._fromTexture(equirectangular);\n  }\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromCubemap(cubemap) {\n    return this._fromTexture(cubemap);\n  }\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileCubemapShader() {\n    if (this._cubemapShader === null) {\n      this._cubemapShader = _getCubemapShader();\n\n      this._compileMaterial(this._cubemapShader);\n    }\n  }\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileEquirectangularShader() {\n    if (this._equirectShader === null) {\n      this._equirectShader = _getEquirectShader();\n\n      this._compileMaterial(this._equirectShader);\n    }\n  }\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n\n\n  dispose() {\n    this._blurMaterial.dispose();\n\n    if (this._cubemapShader !== null) this._cubemapShader.dispose();\n    if (this._equirectShader !== null) this._equirectShader.dispose();\n\n    for (let i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  } // private interface\n\n\n  _cleanup(outputTarget) {\n    this._pingPongRenderTarget.dispose();\n\n    this._renderer.setRenderTarget(_oldTarget);\n\n    outputTarget.scissorTest = false;\n\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = this._allocateTargets(texture);\n\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets(texture) {\n    // warning: null texture is valid\n    const params = {\n      magFilter: NearestFilter,\n      minFilter: NearestFilter,\n      generateMipmaps: false,\n      type: UnsignedByteType,\n      format: RGBEFormat,\n      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n      depthBuffer: false\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(params);\n\n    cubeUVRenderTarget.depthBuffer = texture ? false : true;\n    this._pingPongRenderTarget = _createRenderTarget(params);\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(_lodPlanes[0], material);\n\n    this._renderer.compile(tmpMesh, _flatCamera$1);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    renderer.autoClear = false;\n    let useSolidColor = false;\n    const background = scene.background;\n\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background).convertSRGBToLinear();\n        scene.background = null;\n        const alpha = convertLinearToRGBE(backgroundMaterial.color);\n        backgroundMaterial.opacity = alpha;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();\n      const alpha = convertLinearToRGBE(backgroundMaterial.color);\n      backgroundMaterial.opacity = alpha;\n      useSolidColor = true;\n    }\n\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n\n      if (col == 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col == 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n\n      renderer.render(scene, cubeCamera);\n    }\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    renderer.autoClear = originalAutoClear;\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n\n    if (texture.isCubeTexture) {\n      if (this._cubemapShader == null) {\n        this._cubemapShader = _getCubemapShader();\n      }\n    } else {\n      if (this._equirectShader == null) {\n        this._equirectShader = _getEquirectShader();\n      }\n    }\n\n    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n    const mesh = new Mesh(_lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n\n    if (!texture.isCubeTexture) {\n      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n    }\n\n    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera$1);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (let i = 1; i < TOTAL_LODS; i++) {\n      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n\n\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = _sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n    const outputSize = _sizeLods[lodOut];\n    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera$1);\n  }\n\n}\n\nfunction _isLDR(texture) {\n  if (texture === undefined || texture.type !== UnsignedByteType) return false;\n  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n}\n\nfunction _createPlanes() {\n  const _lodPlanes = [];\n  const _sizeLods = [];\n  const _sigmas = [];\n  let lod = LOD_MAX;\n\n  for (let i = 0; i < TOTAL_LODS; i++) {\n    const sizeLod = Math.pow(2, lod);\n\n    _sizeLods.push(sizeLod);\n\n    let sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    const texelSize = 1.0 / (sizeLod - 1);\n    const min = -texelSize / 2;\n    const max = 1 + texelSize / 2;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    _lodPlanes,\n    _sizeLods,\n    _sigmas\n  };\n}\n\nfunction _createRenderTarget(params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(maxSamples) {\n  const weights = new Float32Array(maxSamples);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': maxSamples\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  const texelSize = new Vector2(1, 1);\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'texelSize': {\n        value: texelSize\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  const shaderMaterial = new RawShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  );\n}\n\nfunction _getEncodings() {\n  return (\n    /* glsl */\n    `\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`\n  );\n}\n\nfunction WebGLCubeUVMaps(renderer) {\n  let cubeUVmaps = new WeakMap();\n  let pmremGenerator = null;\n\n  function get(texture) {\n    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {\n      const mapping = texture.mapping;\n      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;\n      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n\n      if (isEquirectMap || isCubeMap) {\n        // equirect/cube map to cubeUV conversion\n        if (cubeUVmaps.has(texture)) {\n          return cubeUVmaps.get(texture).texture;\n        } else {\n          const image = texture.image;\n\n          if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {\n            const currentRenderTarget = renderer.getRenderTarget();\n            if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);\n            cubeUVmaps.set(texture, renderTarget);\n            renderer.setRenderTarget(currentRenderTarget);\n            texture.addEventListener('dispose', onTextureDispose);\n            return renderTarget.texture;\n          } else {\n            // image not yet ready. try the conversion next frame\n            return null;\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function isCubeTextureComplete(image) {\n    let count = 0;\n    const length = 6;\n\n    for (let i = 0; i < length; i++) {\n      if (image[i] !== undefined) count++;\n    }\n\n    return count === length;\n  }\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    const cubemapUV = cubeUVmaps.get(texture);\n\n    if (cubemapUV !== undefined) {\n      cubemapUV.delete(texture);\n      cubemapUV.dispose();\n    }\n  }\n\n  function dispose() {\n    cubeUVmaps = new WeakMap();\n\n    if (pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n    }\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nfunction WebGLExtensions(gl) {\n  const extensions = {};\n\n  function getExtension(name) {\n    if (extensions[name] !== undefined) {\n      return extensions[name];\n    }\n\n    let extension;\n\n    switch (name) {\n      case 'WEBGL_depth_texture':\n        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');\n        break;\n\n      case 'EXT_texture_filter_anisotropic':\n        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n        break;\n\n      case 'WEBGL_compressed_texture_s3tc':\n        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n        break;\n\n      case 'WEBGL_compressed_texture_pvrtc':\n        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n        break;\n\n      default:\n        extension = gl.getExtension(name);\n    }\n\n    extensions[name] = extension;\n    return extension;\n  }\n\n  return {\n    has: function (name) {\n      return getExtension(name) !== null;\n    },\n    init: function (capabilities) {\n      if (capabilities.isWebGL2) {\n        getExtension('EXT_color_buffer_float');\n      } else {\n        getExtension('WEBGL_depth_texture');\n        getExtension('OES_texture_float');\n        getExtension('OES_texture_half_float');\n        getExtension('OES_texture_half_float_linear');\n        getExtension('OES_standard_derivatives');\n        getExtension('OES_element_index_uint');\n        getExtension('OES_vertex_array_object');\n        getExtension('ANGLE_instanced_arrays');\n      }\n\n      getExtension('OES_texture_float_linear');\n      getExtension('EXT_color_buffer_half_float');\n    },\n    get: function (name) {\n      const extension = getExtension(name);\n\n      if (extension === null) {\n        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\n      }\n\n      return extension;\n    }\n  };\n}\n\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  const geometries = {};\n  const wireframeAttributes = new WeakMap();\n\n  function onGeometryDispose(event) {\n    const geometry = event.target;\n\n    if (geometry.index !== null) {\n      attributes.remove(geometry.index);\n    }\n\n    for (const name in geometry.attributes) {\n      attributes.remove(geometry.attributes[name]);\n    }\n\n    geometry.removeEventListener('dispose', onGeometryDispose);\n    delete geometries[geometry.id];\n    const attribute = wireframeAttributes.get(geometry);\n\n    if (attribute) {\n      attributes.remove(attribute);\n      wireframeAttributes.delete(geometry);\n    }\n\n    bindingStates.releaseStatesOfGeometry(geometry);\n\n    if (geometry.isInstancedBufferGeometry === true) {\n      delete geometry._maxInstanceCount;\n    } //\n\n\n    info.memory.geometries--;\n  }\n\n  function get(object, geometry) {\n    if (geometries[geometry.id] === true) return geometry;\n    geometry.addEventListener('dispose', onGeometryDispose);\n    geometries[geometry.id] = true;\n    info.memory.geometries++;\n    return geometry;\n  }\n\n  function update(geometry) {\n    const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.\n\n    for (const name in geometryAttributes) {\n      attributes.update(geometryAttributes[name], 34962);\n    } // morph targets\n\n\n    const morphAttributes = geometry.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const array = morphAttributes[name];\n\n      for (let i = 0, l = array.length; i < l; i++) {\n        attributes.update(array[i], 34962);\n      }\n    }\n  }\n\n  function updateWireframeAttribute(geometry) {\n    const indices = [];\n    const geometryIndex = geometry.index;\n    const geometryPosition = geometry.attributes.position;\n    let version = 0;\n\n    if (geometryIndex !== null) {\n      const array = geometryIndex.array;\n      version = geometryIndex.version;\n\n      for (let i = 0, l = array.length; i < l; i += 3) {\n        const a = array[i + 0];\n        const b = array[i + 1];\n        const c = array[i + 2];\n        indices.push(a, b, b, c, c, a);\n      }\n    } else {\n      const array = geometryPosition.array;\n      version = geometryPosition.version;\n\n      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n        const a = i + 0;\n        const b = i + 1;\n        const c = i + 2;\n        indices.push(a, b, b, c, c, a);\n      }\n    }\n\n    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates\n    //\n\n    const previousAttribute = wireframeAttributes.get(geometry);\n    if (previousAttribute) attributes.remove(previousAttribute); //\n\n    wireframeAttributes.set(geometry, attribute);\n  }\n\n  function getWireframeAttribute(geometry) {\n    const currentAttribute = wireframeAttributes.get(geometry);\n\n    if (currentAttribute) {\n      const geometryIndex = geometry.index;\n\n      if (geometryIndex !== null) {\n        // if the attribute is obsolete, create a new one\n        if (currentAttribute.version < geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n        }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    }\n\n    return wireframeAttributes.get(geometry);\n  }\n\n  return {\n    get: get,\n    update: update,\n    getWireframeAttribute: getWireframeAttribute\n  };\n}\n\nfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  let mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  let type, bytesPerElement;\n\n  function setIndex(value) {\n    type = value.type;\n    bytesPerElement = value.bytesPerElement;\n  }\n\n  function render(start, count) {\n    gl.drawElements(mode, count, type, start * bytesPerElement);\n    info.update(count, mode, 1);\n  }\n\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n    let extension, methodName;\n\n    if (isWebGL2) {\n      extension = gl;\n      methodName = 'drawElementsInstanced';\n    } else {\n      extension = extensions.get('ANGLE_instanced_arrays');\n      methodName = 'drawElementsInstancedANGLE';\n\n      if (extension === null) {\n        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n        return;\n      }\n    }\n\n    extension[methodName](mode, count, type, start * bytesPerElement, primcount);\n    info.update(count, mode, primcount);\n  } //\n\n\n  this.setMode = setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\n\nfunction WebGLInfo(gl) {\n  const memory = {\n    geometries: 0,\n    textures: 0\n  };\n  const render = {\n    frame: 0,\n    calls: 0,\n    triangles: 0,\n    points: 0,\n    lines: 0\n  };\n\n  function update(count, mode, instanceCount) {\n    render.calls++;\n\n    switch (mode) {\n      case 4:\n        render.triangles += instanceCount * (count / 3);\n        break;\n\n      case 1:\n        render.lines += instanceCount * (count / 2);\n        break;\n\n      case 3:\n        render.lines += instanceCount * (count - 1);\n        break;\n\n      case 2:\n        render.lines += instanceCount * count;\n        break;\n\n      case 0:\n        render.points += instanceCount * count;\n        break;\n\n      default:\n        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);\n        break;\n    }\n  }\n\n  function reset() {\n    render.frame++;\n    render.calls = 0;\n    render.triangles = 0;\n    render.points = 0;\n    render.lines = 0;\n  }\n\n  return {\n    memory: memory,\n    render: render,\n    programs: null,\n    autoReset: true,\n    reset: reset,\n    update: update\n  };\n}\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction WebGLMorphtargets(gl) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const workInfluences = [];\n\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array\n    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n    const length = objectInfluences === undefined ? 0 : objectInfluences.length;\n    let influences = influencesList[geometry.id];\n\n    if (influences === undefined || influences.length !== length) {\n      // initialise list\n      influences = [];\n\n      for (let i = 0; i < length; i++) {\n        influences[i] = [i, 0];\n      }\n\n      influencesList[geometry.id] = influences;\n    } // Collect influences\n\n\n    for (let i = 0; i < length; i++) {\n      const influence = influences[i];\n      influence[0] = i;\n      influence[1] = objectInfluences[i];\n    }\n\n    influences.sort(absNumericalSort);\n\n    for (let i = 0; i < 8; i++) {\n      if (i < length && influences[i][1]) {\n        workInfluences[i][0] = influences[i][0];\n        workInfluences[i][1] = influences[i][1];\n      } else {\n        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n        workInfluences[i][1] = 0;\n      }\n    }\n\n    workInfluences.sort(numericalSort);\n    const morphTargets = geometry.morphAttributes.position;\n    const morphNormals = geometry.morphAttributes.normal;\n    let morphInfluencesSum = 0;\n\n    for (let i = 0; i < 8; i++) {\n      const influence = workInfluences[i];\n      const index = influence[0];\n      const value = influence[1];\n\n      if (index !== Number.MAX_SAFE_INTEGER && value) {\n        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n          geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n        }\n\n        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n          geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n        }\n\n        morphInfluences[i] = value;\n        morphInfluencesSum += value;\n      } else {\n        if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n          geometry.deleteAttribute('morphTarget' + i);\n        }\n\n        if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n          geometry.deleteAttribute('morphNormal' + i);\n        }\n\n        morphInfluences[i] = 0;\n      }\n    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n    // This allows us to switch between absolute morphs and relative morphs without changing shader code\n    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n  }\n\n  return {\n    update: update\n  };\n}\n\nfunction WebGLObjects(gl, geometries, attributes, info) {\n  let updateMap = new WeakMap();\n\n  function update(object) {\n    const frame = info.render.frame;\n    const geometry = object.geometry;\n    const buffergeometry = geometries.get(object, geometry); // Update once per frame\n\n    if (updateMap.get(buffergeometry) !== frame) {\n      geometries.update(buffergeometry);\n      updateMap.set(buffergeometry, frame);\n    }\n\n    if (object.isInstancedMesh) {\n      if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {\n        object.addEventListener('dispose', onInstancedMeshDispose);\n      }\n\n      attributes.update(object.instanceMatrix, 34962);\n\n      if (object.instanceColor !== null) {\n        attributes.update(object.instanceColor, 34962);\n      }\n    }\n\n    return buffergeometry;\n  }\n\n  function dispose() {\n    updateMap = new WeakMap();\n  }\n\n  function onInstancedMeshDispose(event) {\n    const instancedMesh = event.target;\n    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);\n    attributes.remove(instancedMesh.instanceMatrix);\n    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);\n  }\n\n  return {\n    update: update,\n    dispose: dispose\n  };\n}\n\nclass DataTexture2DArray extends Texture$1 {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.image = {\n      data,\n      width,\n      height,\n      depth\n    };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n  }\n\n}\n\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\nclass DataTexture3D extends Texture$1 {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    // We're going to add .setXXX() methods for setting properties later.\n    // Users can still set in DataTexture3D directly.\n    //\n    //\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n    // \ttexture.anisotropy = 16;\n    //\n    // See #14839\n    super(null);\n    this.image = {\n      data,\n      width,\n      height,\n      depth\n    };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n  }\n\n}\n\nDataTexture3D.prototype.isDataTexture3D = true;\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\nconst emptyTexture = new Texture$1();\nconst emptyTexture2dArray = new DataTexture2DArray();\nconst emptyTexture3d = new DataTexture3D();\nconst emptyCubeTexture = new CubeTexture(); // --- Utilities ---\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array(16);\nconst mat3array = new Float32Array(9);\nconst mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices\n\nfunction flatten(array, nBlocks, blockSize) {\n  const firstElem = array[0];\n  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )\n  // see http://jacksondunstan.com/articles/983\n\n  const n = nBlocks * blockSize;\n  let r = arrayCacheF32[n];\n\n  if (r === undefined) {\n    r = new Float32Array(n);\n    arrayCacheF32[n] = r;\n  }\n\n  if (nBlocks !== 0) {\n    firstElem.toArray(r, 0);\n\n    for (let i = 1, offset = 0; i !== nBlocks; ++i) {\n      offset += blockSize;\n      array[i].toArray(r, offset);\n    }\n  }\n\n  return r;\n}\n\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nfunction copyArray(a, b) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[i] = b[i];\n  }\n} // Texture unit allocation\n\n\nfunction allocTexUnits(textures, n) {\n  let r = arrayCacheI32[n];\n\n  if (r === undefined) {\n    r = new Int32Array(n);\n    arrayCacheI32[n] = r;\n  }\n\n  for (let i = 0; i !== n; ++i) {\n    r[i] = textures.allocateTextureUnit();\n  }\n\n  return r;\n} // --- Setters ---\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n// Single scalar\n\n\nfunction setValueV1f(gl, v) {\n  const cache = this.cache;\n  if (cache[0] === v) return;\n  gl.uniform1f(this.addr, v);\n  cache[0] = v;\n} // Single float vector (from flat array or THREE.VectorN)\n\n\nfunction setValueV2f(gl, v) {\n  const cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y) {\n      gl.uniform2f(this.addr, v.x, v.y);\n      cache[0] = v.x;\n      cache[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n    gl.uniform2fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\n\nfunction setValueV3f(gl, v) {\n  const cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n      gl.uniform3f(this.addr, v.x, v.y, v.z);\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n    }\n  } else if (v.r !== undefined) {\n    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n      gl.uniform3f(this.addr, v.r, v.g, v.b);\n      cache[0] = v.r;\n      cache[1] = v.g;\n      cache[2] = v.b;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n    gl.uniform3fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\n\nfunction setValueV4f(gl, v) {\n  const cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\n      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n      cache[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n    gl.uniform4fv(this.addr, v);\n    copyArray(cache, v);\n  }\n} // Single matrix (from flat array or THREE.MatrixN)\n\n\nfunction setValueM2(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n    gl.uniformMatrix2fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n    mat2array.set(elements);\n    gl.uniformMatrix2fv(this.addr, false, mat2array);\n    copyArray(cache, elements);\n  }\n}\n\nfunction setValueM3(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n    gl.uniformMatrix3fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n    mat3array.set(elements);\n    gl.uniformMatrix3fv(this.addr, false, mat3array);\n    copyArray(cache, elements);\n  }\n}\n\nfunction setValueM4(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n    gl.uniformMatrix4fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n    mat4array.set(elements);\n    gl.uniformMatrix4fv(this.addr, false, mat4array);\n    copyArray(cache, elements);\n  }\n} // Single integer / boolean\n\n\nfunction setValueV1i(gl, v) {\n  const cache = this.cache;\n  if (cache[0] === v) return;\n  gl.uniform1i(this.addr, v);\n  cache[0] = v;\n} // Single integer / boolean vector (from flat array)\n\n\nfunction setValueV2i(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform2iv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV3i(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform3iv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV4i(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform4iv(this.addr, v);\n  copyArray(cache, v);\n} // Single unsigned integer\n\n\nfunction setValueV1ui(gl, v) {\n  const cache = this.cache;\n  if (cache[0] === v) return;\n  gl.uniform1ui(this.addr, v);\n  cache[0] = v;\n} // Single unsigned integer vector (from flat array)\n\n\nfunction setValueV2ui(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform2uiv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV3ui(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform3uiv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV4ui(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform4uiv(this.addr, v);\n  copyArray(cache, v);\n} // Single texture (2D / Cube)\n\n\nfunction setValueT1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.safeSetTexture2D(v || emptyTexture, unit);\n}\n\nfunction setValueT3D1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture3D(v || emptyTexture3d, unit);\n}\n\nfunction setValueT6(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.safeSetTextureCube(v || emptyCubeTexture, unit);\n}\n\nfunction setValueT2DArray1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture2DArray(v || emptyTexture2dArray, unit);\n} // Helper to pick the right setter for the singular case\n\n\nfunction getSingularSetter(type) {\n  switch (type) {\n    case 0x1406:\n      return setValueV1f;\n    // FLOAT\n\n    case 0x8b50:\n      return setValueV2f;\n    // _VEC2\n\n    case 0x8b51:\n      return setValueV3f;\n    // _VEC3\n\n    case 0x8b52:\n      return setValueV4f;\n    // _VEC4\n\n    case 0x8b5a:\n      return setValueM2;\n    // _MAT2\n\n    case 0x8b5b:\n      return setValueM3;\n    // _MAT3\n\n    case 0x8b5c:\n      return setValueM4;\n    // _MAT4\n\n    case 0x1404:\n    case 0x8b56:\n      return setValueV1i;\n    // INT, BOOL\n\n    case 0x8b53:\n    case 0x8b57:\n      return setValueV2i;\n    // _VEC2\n\n    case 0x8b54:\n    case 0x8b58:\n      return setValueV3i;\n    // _VEC3\n\n    case 0x8b55:\n    case 0x8b59:\n      return setValueV4i;\n    // _VEC4\n\n    case 0x1405:\n      return setValueV1ui;\n    // UINT\n\n    case 0x8dc6:\n      return setValueV2ui;\n    // _VEC2\n\n    case 0x8dc7:\n      return setValueV3ui;\n    // _VEC3\n\n    case 0x8dc8:\n      return setValueV4ui;\n    // _VEC4\n\n    case 0x8b5e: // SAMPLER_2D\n\n    case 0x8d66: // SAMPLER_EXTERNAL_OES\n\n    case 0x8dca: // INT_SAMPLER_2D\n\n    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n    case 0x8b62:\n      // SAMPLER_2D_SHADOW\n      return setValueT1;\n\n    case 0x8b5f: // SAMPLER_3D\n\n    case 0x8dcb: // INT_SAMPLER_3D\n\n    case 0x8dd3:\n      // UNSIGNED_INT_SAMPLER_3D\n      return setValueT3D1;\n\n    case 0x8b60: // SAMPLER_CUBE\n\n    case 0x8dcc: // INT_SAMPLER_CUBE\n\n    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n    case 0x8dc5:\n      // SAMPLER_CUBE_SHADOW\n      return setValueT6;\n\n    case 0x8dc1: // SAMPLER_2D_ARRAY\n\n    case 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\n    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\n    case 0x8dc4:\n      // SAMPLER_2D_ARRAY_SHADOW\n      return setValueT2DArray1;\n  }\n} // Array of scalars\n\n\nfunction setValueV1fArray(gl, v) {\n  gl.uniform1fv(this.addr, v);\n} // Array of vectors (from flat array or array of THREE.VectorN)\n\n\nfunction setValueV2fArray(gl, v) {\n  const data = flatten(v, this.size, 2);\n  gl.uniform2fv(this.addr, data);\n}\n\nfunction setValueV3fArray(gl, v) {\n  const data = flatten(v, this.size, 3);\n  gl.uniform3fv(this.addr, data);\n}\n\nfunction setValueV4fArray(gl, v) {\n  const data = flatten(v, this.size, 4);\n  gl.uniform4fv(this.addr, data);\n} // Array of matrices (from flat array or array of THREE.MatrixN)\n\n\nfunction setValueM2Array(gl, v) {\n  const data = flatten(v, this.size, 4);\n  gl.uniformMatrix2fv(this.addr, false, data);\n}\n\nfunction setValueM3Array(gl, v) {\n  const data = flatten(v, this.size, 9);\n  gl.uniformMatrix3fv(this.addr, false, data);\n}\n\nfunction setValueM4Array(gl, v) {\n  const data = flatten(v, this.size, 16);\n  gl.uniformMatrix4fv(this.addr, false, data);\n} // Array of integer / boolean\n\n\nfunction setValueV1iArray(gl, v) {\n  gl.uniform1iv(this.addr, v);\n} // Array of integer / boolean vectors (from flat array)\n\n\nfunction setValueV2iArray(gl, v) {\n  gl.uniform2iv(this.addr, v);\n}\n\nfunction setValueV3iArray(gl, v) {\n  gl.uniform3iv(this.addr, v);\n}\n\nfunction setValueV4iArray(gl, v) {\n  gl.uniform4iv(this.addr, v);\n} // Array of unsigned integer\n\n\nfunction setValueV1uiArray(gl, v) {\n  gl.uniform1uiv(this.addr, v);\n} // Array of unsigned integer vectors (from flat array)\n\n\nfunction setValueV2uiArray(gl, v) {\n  gl.uniform2uiv(this.addr, v);\n}\n\nfunction setValueV3uiArray(gl, v) {\n  gl.uniform3uiv(this.addr, v);\n}\n\nfunction setValueV4uiArray(gl, v) {\n  gl.uniform4uiv(this.addr, v);\n} // Array of textures (2D / Cube)\n\n\nfunction setValueT1Array(gl, v, textures) {\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n\n  for (let i = 0; i !== n; ++i) {\n    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\n  }\n}\n\nfunction setValueT6Array(gl, v, textures) {\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n\n  for (let i = 0; i !== n; ++i) {\n    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\n  }\n} // Helper to pick the right setter for a pure (bottom-level) array\n\n\nfunction getPureArraySetter(type) {\n  switch (type) {\n    case 0x1406:\n      return setValueV1fArray;\n    // FLOAT\n\n    case 0x8b50:\n      return setValueV2fArray;\n    // _VEC2\n\n    case 0x8b51:\n      return setValueV3fArray;\n    // _VEC3\n\n    case 0x8b52:\n      return setValueV4fArray;\n    // _VEC4\n\n    case 0x8b5a:\n      return setValueM2Array;\n    // _MAT2\n\n    case 0x8b5b:\n      return setValueM3Array;\n    // _MAT3\n\n    case 0x8b5c:\n      return setValueM4Array;\n    // _MAT4\n\n    case 0x1404:\n    case 0x8b56:\n      return setValueV1iArray;\n    // INT, BOOL\n\n    case 0x8b53:\n    case 0x8b57:\n      return setValueV2iArray;\n    // _VEC2\n\n    case 0x8b54:\n    case 0x8b58:\n      return setValueV3iArray;\n    // _VEC3\n\n    case 0x8b55:\n    case 0x8b59:\n      return setValueV4iArray;\n    // _VEC4\n\n    case 0x1405:\n      return setValueV1uiArray;\n    // UINT\n\n    case 0x8dc6:\n      return setValueV2uiArray;\n    // _VEC2\n\n    case 0x8dc7:\n      return setValueV3uiArray;\n    // _VEC3\n\n    case 0x8dc8:\n      return setValueV4uiArray;\n    // _VEC4\n\n    case 0x8b5e: // SAMPLER_2D\n\n    case 0x8d66: // SAMPLER_EXTERNAL_OES\n\n    case 0x8dca: // INT_SAMPLER_2D\n\n    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n    case 0x8b62:\n      // SAMPLER_2D_SHADOW\n      return setValueT1Array;\n\n    case 0x8b60: // SAMPLER_CUBE\n\n    case 0x8dcc: // INT_SAMPLER_CUBE\n\n    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n    case 0x8dc5:\n      // SAMPLER_CUBE_SHADOW\n      return setValueT6Array;\n  }\n} // --- Uniform Classes ---\n\n\nfunction SingleUniform(id, activeInfo, addr) {\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n}\n\nfunction PureArrayUniform(id, activeInfo, addr) {\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.size = activeInfo.size;\n  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n}\n\nPureArrayUniform.prototype.updateCache = function (data) {\n  const cache = this.cache;\n\n  if (data instanceof Float32Array && cache.length !== data.length) {\n    this.cache = new Float32Array(data.length);\n  }\n\n  copyArray(cache, data);\n};\n\nfunction StructuredUniform(id) {\n  this.id = id;\n  this.seq = [];\n  this.map = {};\n}\n\nStructuredUniform.prototype.setValue = function (gl, value, textures) {\n  const seq = this.seq;\n\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i];\n    u.setValue(gl, value[u.id], textures);\n  }\n}; // --- Top-level ---\n// Parser - builds up the property tree from the path strings\n\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g; // extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform(container, uniformObject) {\n  container.seq.push(uniformObject);\n  container.map[uniformObject.id] = uniformObject;\n}\n\nfunction parseUniform(activeInfo, addr, container) {\n  const path = activeInfo.name,\n        pathLength = path.length; // reset RegExp object, because of the early exit of a previous run\n\n  RePathPart.lastIndex = 0;\n\n  while (true) {\n    const match = RePathPart.exec(path),\n          matchEnd = RePathPart.lastIndex;\n    let id = match[1];\n    const idIsIndex = match[2] === ']',\n          subscript = match[3];\n    if (idIsIndex) id = id | 0; // convert to integer\n\n    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {\n      // bare name or \"pure\" bottom-level array \"[0]\" suffix\n      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));\n      break;\n    } else {\n      // step into inner node / create it in case it doesn't exist\n      const map = container.map;\n      let next = map[id];\n\n      if (next === undefined) {\n        next = new StructuredUniform(id);\n        addUniform(container, next);\n      }\n\n      container = next;\n    }\n  }\n} // Root Container\n\n\nfunction WebGLUniforms(gl, program) {\n  this.seq = [];\n  this.map = {};\n  const n = gl.getProgramParameter(program, 35718);\n\n  for (let i = 0; i < n; ++i) {\n    const info = gl.getActiveUniform(program, i),\n          addr = gl.getUniformLocation(program, info.name);\n    parseUniform(info, addr, this);\n  }\n}\n\nWebGLUniforms.prototype.setValue = function (gl, name, value, textures) {\n  const u = this.map[name];\n  if (u !== undefined) u.setValue(gl, value, textures);\n};\n\nWebGLUniforms.prototype.setOptional = function (gl, object, name) {\n  const v = object[name];\n  if (v !== undefined) this.setValue(gl, name, v);\n}; // Static interface\n\n\nWebGLUniforms.upload = function (gl, seq, values, textures) {\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i],\n          v = values[u.id];\n\n    if (v.needsUpdate !== false) {\n      // note: always updating when .needsUpdate is undefined\n      u.setValue(gl, v.value, textures);\n    }\n  }\n};\n\nWebGLUniforms.seqWithValue = function (seq, values) {\n  const r = [];\n\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i];\n    if (u.id in values) r.push(u);\n  }\n\n  return r;\n};\n\nfunction WebGLShader(gl, type, string) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, string);\n  gl.compileShader(shader);\n  return shader;\n}\n\nlet programIdCount = 0;\n\nfunction addLineNumbers(string) {\n  const lines = string.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = i + 1 + ': ' + lines[i];\n  }\n\n  return lines.join('\\n');\n}\n\nfunction getEncodingComponents(encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return ['Linear', '( value )'];\n\n    case sRGBEncoding:\n      return ['sRGB', '( value )'];\n\n    case RGBEEncoding:\n      return ['RGBE', '( value )'];\n\n    case RGBM7Encoding:\n      return ['RGBM', '( value, 7.0 )'];\n\n    case RGBM16Encoding:\n      return ['RGBM', '( value, 16.0 )'];\n\n    case RGBDEncoding:\n      return ['RGBD', '( value, 256.0 )'];\n\n    case GammaEncoding:\n      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n\n    case LogLuvEncoding:\n      return ['LogLuv', '( value )'];\n\n    default:\n      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);\n      return ['Linear', '( value )'];\n  }\n}\n\nfunction getShaderErrors(gl, shader, type) {\n  const status = gl.getShaderParameter(shader, 35713);\n  const log = gl.getShaderInfoLog(shader).trim();\n  if (status && log === '') return ''; // --enable-privileged-webgl-extension\n  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n  const source = gl.getShaderSource(shader);\n  return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers(source);\n}\n\nfunction getTexelDecodingFunction(functionName, encoding) {\n  const components = getEncodingComponents(encoding);\n  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n}\n\nfunction getTexelEncodingFunction(functionName, encoding) {\n  const components = getEncodingComponents(encoding);\n  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';\n}\n\nfunction getToneMappingFunction(functionName, toneMapping) {\n  let toneMappingName;\n\n  switch (toneMapping) {\n    case LinearToneMapping:\n      toneMappingName = 'Linear';\n      break;\n\n    case ReinhardToneMapping:\n      toneMappingName = 'Reinhard';\n      break;\n\n    case CineonToneMapping:\n      toneMappingName = 'OptimizedCineon';\n      break;\n\n    case ACESFilmicToneMapping:\n      toneMappingName = 'ACESFilmic';\n      break;\n\n    case CustomToneMapping:\n      toneMappingName = 'Custom';\n      break;\n\n    default:\n      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);\n      toneMappingName = 'Linear';\n  }\n\n  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n}\n\nfunction generateExtensions(parameters) {\n  const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];\n  return chunks.filter(filterEmptyLine).join('\\n');\n}\n\nfunction generateDefines(defines) {\n  const chunks = [];\n\n  for (const name in defines) {\n    const value = defines[name];\n    if (value === false) continue;\n    chunks.push('#define ' + name + ' ' + value);\n  }\n\n  return chunks.join('\\n');\n}\n\nfunction fetchAttributeLocations(gl, program) {\n  const attributes = {};\n  const n = gl.getProgramParameter(program, 35721);\n\n  for (let i = 0; i < n; i++) {\n    const info = gl.getActiveAttrib(program, i);\n    const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n    attributes[name] = gl.getAttribLocation(program, name);\n  }\n\n  return attributes;\n}\n\nfunction filterEmptyLine(string) {\n  return string !== '';\n}\n\nfunction replaceLightNums(string, parameters) {\n  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n}\n\nfunction replaceClippingPlaneNums(string, parameters) {\n  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n} // Resolve Includes\n\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes(string) {\n  return string.replace(includePattern, includeReplacer);\n}\n\nfunction includeReplacer(match, include) {\n  const string = ShaderChunk[include];\n\n  if (string === undefined) {\n    throw new Error('Can not resolve #include <' + include + '>');\n  }\n\n  return resolveIncludes(string);\n} // Unroll Loops\n\n\nconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops(string) {\n  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n}\n\nfunction deprecatedLoopReplacer(match, start, end, snippet) {\n  console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');\n  return loopReplacer(match, start, end, snippet);\n}\n\nfunction loopReplacer(match, start, end, snippet) {\n  let string = '';\n\n  for (let i = parseInt(start); i < parseInt(end); i++) {\n    string += snippet.replace(/\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);\n  }\n\n  return string;\n} //\n\n\nfunction generatePrecision(parameters) {\n  let precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n  if (parameters.precision === 'highp') {\n    precisionstring += '\\n#define HIGH_PRECISION';\n  } else if (parameters.precision === 'mediump') {\n    precisionstring += '\\n#define MEDIUM_PRECISION';\n  } else if (parameters.precision === 'lowp') {\n    precisionstring += '\\n#define LOW_PRECISION';\n  }\n\n  return precisionstring;\n}\n\nfunction generateShadowMapTypeDefine(parameters) {\n  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n  if (parameters.shadowMapType === PCFShadowMap) {\n    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n  } else if (parameters.shadowMapType === PCFSoftShadowMap) {\n    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n  } else if (parameters.shadowMapType === VSMShadowMap) {\n    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n  }\n\n  return shadowMapTypeDefine;\n}\n\nfunction generateEnvMapTypeDefine(parameters) {\n  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeReflectionMapping:\n      case CubeRefractionMapping:\n        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n        break;\n\n      case CubeUVReflectionMapping:\n      case CubeUVRefractionMapping:\n        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n        break;\n    }\n  }\n\n  return envMapTypeDefine;\n}\n\nfunction generateEnvMapModeDefine(parameters) {\n  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeRefractionMapping:\n      case CubeUVRefractionMapping:\n        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n        break;\n    }\n  }\n\n  return envMapModeDefine;\n}\n\nfunction generateEnvMapBlendingDefine(parameters) {\n  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n  if (parameters.envMap) {\n    switch (parameters.combine) {\n      case MultiplyOperation:\n        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n        break;\n\n      case MixOperation:\n        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n        break;\n\n      case AddOperation:\n        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n        break;\n    }\n  }\n\n  return envMapBlendingDefine;\n}\n\nfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n  const gl = renderer.getContext();\n  const defines = parameters.defines;\n  let vertexShader = parameters.vertexShader;\n  let fragmentShader = parameters.fragmentShader;\n  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n  const envMapModeDefine = generateEnvMapModeDefine(parameters);\n  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;\n  const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);\n  const customDefines = generateDefines(defines);\n  const program = gl.createProgram();\n  let prefixVertex, prefixFragment;\n  let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n  if (parameters.isRawShaderMaterial) {\n    prefixVertex = [customDefines].filter(filterEmptyLine).join('\\n');\n\n    if (prefixVertex.length > 0) {\n      prefixVertex += '\\n';\n    }\n\n    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\\n');\n\n    if (prefixFragment.length > 0) {\n      prefixFragment += '\\n';\n    }\n  } else {\n    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '\tattribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '\tattribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '\tattribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '\tattribute vec4 color;', '#elif defined( USE_COLOR )', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\\n'].filter(filterEmptyLine).join('\\n');\n    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer\n    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below\n    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below\n    parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.specularTintMap ? getTexelDecodingFunction('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\\n'].filter(filterEmptyLine).join('\\n');\n  }\n\n  vertexShader = resolveIncludes(vertexShader);\n  vertexShader = replaceLightNums(vertexShader, parameters);\n  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n  fragmentShader = resolveIncludes(fragmentShader);\n  fragmentShader = replaceLightNums(fragmentShader, parameters);\n  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n  vertexShader = unrollLoops(vertexShader);\n  fragmentShader = unrollLoops(fragmentShader);\n\n  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n    // GLSL 3.0 conversion for built-in materials and ShaderMaterial\n    versionString = '#version 300 es\\n';\n    prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\\n') + '\\n' + prefixVertex;\n    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\\n') + '\\n' + prefixFragment;\n  }\n\n  const vertexGlsl = versionString + prefixVertex + vertexShader;\n  const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );\n  // console.log( '*FRAGMENT*', fragmentGlsl );\n\n  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);\n  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);\n  gl.attachShader(program, glVertexShader);\n  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.\n\n  if (parameters.index0AttributeName !== undefined) {\n    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n  } else if (parameters.morphTargets === true) {\n    // programs with morphTargets displace position out of attribute 0\n    gl.bindAttribLocation(program, 0, 'position');\n  }\n\n  gl.linkProgram(program); // check for link errors\n\n  if (renderer.debug.checkShaderErrors) {\n    const programLog = gl.getProgramInfoLog(program).trim();\n    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n    let runnable = true;\n    let haveDiagnostics = true;\n\n    if (gl.getProgramParameter(program, 35714) === false) {\n      runnable = false;\n      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');\n      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');\n      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);\n    } else if (programLog !== '') {\n      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);\n    } else if (vertexLog === '' || fragmentLog === '') {\n      haveDiagnostics = false;\n    }\n\n    if (haveDiagnostics) {\n      this.diagnostics = {\n        runnable: runnable,\n        programLog: programLog,\n        vertexShader: {\n          log: vertexLog,\n          prefix: prefixVertex\n        },\n        fragmentShader: {\n          log: fragmentLog,\n          prefix: prefixFragment\n        }\n      };\n    }\n  } // Clean up\n  // Crashes in iOS9 and iOS10. #18402\n  // gl.detachShader( program, glVertexShader );\n  // gl.detachShader( program, glFragmentShader );\n\n\n  gl.deleteShader(glVertexShader);\n  gl.deleteShader(glFragmentShader); // set up caching for uniform locations\n\n  let cachedUniforms;\n\n  this.getUniforms = function () {\n    if (cachedUniforms === undefined) {\n      cachedUniforms = new WebGLUniforms(gl, program);\n    }\n\n    return cachedUniforms;\n  }; // set up caching for attribute locations\n\n\n  let cachedAttributes;\n\n  this.getAttributes = function () {\n    if (cachedAttributes === undefined) {\n      cachedAttributes = fetchAttributeLocations(gl, program);\n    }\n\n    return cachedAttributes;\n  }; // free resource\n\n\n  this.destroy = function () {\n    bindingStates.releaseStatesOfProgram(this);\n    gl.deleteProgram(program);\n    this.program = undefined;\n  }; //\n\n\n  this.name = parameters.shaderName;\n  this.id = programIdCount++;\n  this.cacheKey = cacheKey;\n  this.usedTimes = 1;\n  this.program = program;\n  this.vertexShader = glVertexShader;\n  this.fragmentShader = glFragmentShader;\n  return this;\n}\n\nfunction WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {\n  const programs = [];\n  const isWebGL2 = capabilities.isWebGL2;\n  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  const floatVertexTextures = capabilities.floatVertexTextures;\n  const maxVertexUniforms = capabilities.maxVertexUniforms;\n  const vertexTextures = capabilities.vertexTextures;\n  let precision = capabilities.precision;\n  const shaderIDs = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'toon',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n  const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'specularIntensityMap', 'specularTintMap', 'specularTintMapEncoding', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];\n\n  function getMaxBones(object) {\n    const skeleton = object.skeleton;\n    const bones = skeleton.bones;\n\n    if (floatVertexTextures) {\n      return 1024;\n    } else {\n      // default for when object is not specified\n      // ( for example when prebuilding shader to be used with multiple objects )\n      //\n      //  - leave some extra space for other uniforms\n      //  - limit here is ANGLE's 254 max uniform vectors\n      //    (up to 54 should be safe)\n      const nVertexUniforms = maxVertexUniforms;\n      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n      const maxBones = Math.min(nVertexMatrices, bones.length);\n\n      if (maxBones < bones.length) {\n        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');\n        return 0;\n      }\n\n      return maxBones;\n    }\n  }\n\n  function getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\\'t use render targets as textures. Use their .texture property instead.');\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  function getParameters(material, lights, shadows, scene, object) {\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n    // (not to blow over maxLights budget)\n\n    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n\n      if (precision !== material.precision) {\n        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');\n      }\n    }\n\n    let vertexShader, fragmentShader;\n\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      vertexShader = shader.vertexShader;\n      fragmentShader = shader.fragmentShader;\n    } else {\n      vertexShader = material.vertexShader;\n      fragmentShader = material.fragmentShader;\n    }\n\n    const currentRenderTarget = renderer.getRenderTarget();\n    const parameters = {\n      isWebGL2: isWebGL2,\n      shaderID: shaderID,\n      shaderName: material.type,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      defines: material.defines,\n      isRawShaderMaterial: material.isRawShaderMaterial === true,\n      glslVersion: material.glslVersion,\n      precision: precision,\n      instancing: object.isInstancedMesh === true,\n      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n      supportsVertexTextures: vertexTextures,\n      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,\n      map: !!material.map,\n      mapEncoding: getTextureEncodingFromMap(material.map),\n      matcap: !!material.matcap,\n      matcapEncoding: getTextureEncodingFromMap(material.matcap),\n      envMap: !!envMap,\n      envMapMode: envMap && envMap.mapping,\n      envMapEncoding: getTextureEncodingFromMap(envMap),\n      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),\n      lightMap: !!material.lightMap,\n      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),\n      aoMap: !!material.aoMap,\n      emissiveMap: !!material.emissiveMap,\n      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),\n      bumpMap: !!material.bumpMap,\n      normalMap: !!material.normalMap,\n      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n      clearcoatMap: !!material.clearcoatMap,\n      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,\n      clearcoatNormalMap: !!material.clearcoatNormalMap,\n      displacementMap: !!material.displacementMap,\n      roughnessMap: !!material.roughnessMap,\n      metalnessMap: !!material.metalnessMap,\n      specularMap: !!material.specularMap,\n      specularIntensityMap: !!material.specularIntensityMap,\n      specularTintMap: !!material.specularTintMap,\n      specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),\n      alphaMap: !!material.alphaMap,\n      gradientMap: !!material.gradientMap,\n      sheen: !!material.sheen,\n      transmission: !!material.transmission,\n      transmissionMap: !!material.transmissionMap,\n      thicknessMap: !!material.thicknessMap,\n      combine: material.combine,\n      vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,\n      vertexColors: material.vertexColors,\n      vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,\n      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,\n      fog: !!fog,\n      useFog: material.fog,\n      fogExp2: fog && fog.isFogExp2,\n      flatShading: !!material.flatShading,\n      sizeAttenuation: material.sizeAttenuation,\n      logarithmicDepthBuffer: logarithmicDepthBuffer,\n      skinning: object.isSkinnedMesh === true && maxBones > 0,\n      maxBones: maxBones,\n      useVertexTexture: floatVertexTextures,\n      morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,\n      morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,\n      numDirLights: lights.directional.length,\n      numPointLights: lights.point.length,\n      numSpotLights: lights.spot.length,\n      numRectAreaLights: lights.rectArea.length,\n      numHemiLights: lights.hemi.length,\n      numDirLightShadows: lights.directionalShadowMap.length,\n      numPointLightShadows: lights.pointShadowMap.length,\n      numSpotLightShadows: lights.spotShadowMap.length,\n      numClippingPlanes: clipping.numPlanes,\n      numClipIntersection: clipping.numIntersection,\n      dithering: material.dithering,\n      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n      shadowMapType: renderer.shadowMap.type,\n      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n      physicallyCorrectLights: renderer.physicallyCorrectLights,\n      premultipliedAlpha: material.premultipliedAlpha,\n      alphaTest: material.alphaTest,\n      doubleSided: material.side === DoubleSide,\n      flipSided: material.side === BackSide,\n      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,\n      index0AttributeName: material.index0AttributeName,\n      extensionDerivatives: material.extensions && material.extensions.derivatives,\n      extensionFragDepth: material.extensions && material.extensions.fragDepth,\n      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),\n      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),\n      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),\n      customProgramCacheKey: material.customProgramCacheKey()\n    };\n    return parameters;\n  }\n\n  function getProgramCacheKey(parameters) {\n    const array = [];\n\n    if (parameters.shaderID) {\n      array.push(parameters.shaderID);\n    } else {\n      array.push(parameters.fragmentShader);\n      array.push(parameters.vertexShader);\n    }\n\n    if (parameters.defines !== undefined) {\n      for (const name in parameters.defines) {\n        array.push(name);\n        array.push(parameters.defines[name]);\n      }\n    }\n\n    if (parameters.isRawShaderMaterial === false) {\n      for (let i = 0; i < parameterNames.length; i++) {\n        array.push(parameters[parameterNames[i]]);\n      }\n\n      array.push(renderer.outputEncoding);\n      array.push(renderer.gammaFactor);\n    }\n\n    array.push(parameters.customProgramCacheKey);\n    return array.join();\n  }\n\n  function getUniforms(material) {\n    const shaderID = shaderIDs[material.type];\n    let uniforms;\n\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      uniforms = UniformsUtils.clone(shader.uniforms);\n    } else {\n      uniforms = material.uniforms;\n    }\n\n    return uniforms;\n  }\n\n  function acquireProgram(parameters, cacheKey) {\n    let program; // Check if code has been already compiled\n\n    for (let p = 0, pl = programs.length; p < pl; p++) {\n      const preexistingProgram = programs[p];\n\n      if (preexistingProgram.cacheKey === cacheKey) {\n        program = preexistingProgram;\n        ++program.usedTimes;\n        break;\n      }\n    }\n\n    if (program === undefined) {\n      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n      programs.push(program);\n    }\n\n    return program;\n  }\n\n  function releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      // Remove from unordered set\n      const i = programs.indexOf(program);\n      programs[i] = programs[programs.length - 1];\n      programs.pop(); // Free WebGL resources\n\n      program.destroy();\n    }\n  }\n\n  return {\n    getParameters: getParameters,\n    getProgramCacheKey: getProgramCacheKey,\n    getUniforms: getUniforms,\n    acquireProgram: acquireProgram,\n    releaseProgram: releaseProgram,\n    // Exposed for resource monitoring & error feedback via renderer.info:\n    programs: programs\n  };\n}\n\nfunction WebGLProperties() {\n  let properties = new WeakMap();\n\n  function get(object) {\n    let map = properties.get(object);\n\n    if (map === undefined) {\n      map = {};\n      properties.set(object, map);\n    }\n\n    return map;\n  }\n\n  function remove(object) {\n    properties.delete(object);\n  }\n\n  function update(object, key, value) {\n    properties.get(object)[key] = value;\n  }\n\n  function dispose() {\n    properties = new WeakMap();\n  }\n\n  return {\n    get: get,\n    remove: remove,\n    update: update,\n    dispose: dispose\n  };\n}\n\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.program !== b.program) {\n    return a.program.id - b.program.id;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\nfunction WebGLRenderList(properties) {\n  const renderItems = [];\n  let renderItemsIndex = 0;\n  const opaque = [];\n  const transmissive = [];\n  const transparent = [];\n  const defaultProgram = {\n    id: -1\n  };\n\n  function init() {\n    renderItemsIndex = 0;\n    opaque.length = 0;\n    transmissive.length = 0;\n    transparent.length = 0;\n  }\n\n  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n    let renderItem = renderItems[renderItemsIndex];\n    const materialProperties = properties.get(material);\n\n    if (renderItem === undefined) {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        program: materialProperties.program || defaultProgram,\n        groupOrder: groupOrder,\n        renderOrder: object.renderOrder,\n        z: z,\n        group: group\n      };\n      renderItems[renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.program = materialProperties.program || defaultProgram;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n    }\n\n    renderItemsIndex++;\n    return renderItem;\n  }\n\n  function push(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n    if (material.transmission > 0.0) {\n      transmissive.push(renderItem);\n    } else if (material.transparent === true) {\n      transparent.push(renderItem);\n    } else {\n      opaque.push(renderItem);\n    }\n  }\n\n  function unshift(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n    if (material.transmission > 0.0) {\n      transmissive.unshift(renderItem);\n    } else if (material.transparent === true) {\n      transparent.unshift(renderItem);\n    } else {\n      opaque.unshift(renderItem);\n    }\n  }\n\n  function sort(customOpaqueSort, customTransparentSort) {\n    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);\n    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n\n  function finish() {\n    // Clear references from inactive renderItems in the list\n    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n      const renderItem = renderItems[i];\n      if (renderItem.id === null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.program = null;\n      renderItem.group = null;\n    }\n  }\n\n  return {\n    opaque: opaque,\n    transmissive: transmissive,\n    transparent: transparent,\n    init: init,\n    push: push,\n    unshift: unshift,\n    finish: finish,\n    sort: sort\n  };\n}\n\nfunction WebGLRenderLists(properties) {\n  let lists = new WeakMap();\n\n  function get(scene, renderCallDepth) {\n    let list;\n\n    if (lists.has(scene) === false) {\n      list = new WebGLRenderList(properties);\n      lists.set(scene, [list]);\n    } else {\n      if (renderCallDepth >= lists.get(scene).length) {\n        list = new WebGLRenderList(properties);\n        lists.get(scene).push(list);\n      } else {\n        list = lists.get(scene)[renderCallDepth];\n      }\n    }\n\n    return list;\n  }\n\n  function dispose() {\n    lists = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nfunction UniformsCache() {\n  const lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      let uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n\n        case 'HemisphereLight':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n\n        case 'RectAreaLight':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nfunction ShadowUniformsCache() {\n  const lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      let uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000\n          };\n          break;\n        // TODO (abelnation): set RectAreaLight shadow uniforms\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nlet nextVersion = 0;\n\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\n\nfunction WebGLLights(extensions, capabilities) {\n  const cache = new UniformsCache();\n  const shadowCache = ShadowUniformsCache();\n  const state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: []\n  };\n\n  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n  const vector3 = new Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new Matrix4();\n\n  function setup(lights) {\n    let r = 0,\n        g = 0,\n        b = 0;\n\n    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    let numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let numSpotShadows = 0;\n    lights.sort(shadowCastingLightsFirst);\n\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      const color = light.color;\n      const intensity = light.intensity;\n      const distance = light.distance;\n      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n      if (light.isAmbientLight) {\n        r += color.r * intensity;\n        g += color.g * intensity;\n        b += color.b * intensity;\n      } else if (light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = cache.get(light);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.distance = distance;\n        uniforms.coneCos = Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.spotShadow[spotLength] = shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n          numSpotShadows++;\n        }\n\n        state.spot[spotLength] = uniforms;\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = cache.get(light); // (a) intensity is the total visible light emitted\n        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n        // (b) intensity is the brightness of the light\n\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        state.rectArea[rectAreaLength] = uniforms;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          shadowUniforms.shadowCameraNear = shadow.camera.near;\n          shadowUniforms.shadowCameraFar = shadow.camera.far;\n          state.pointShadow[pointLength] = shadowUniforms;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n\n        state.point[pointLength] = uniforms;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = cache.get(light);\n        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n        state.hemi[hemiLength] = uniforms;\n        hemiLength++;\n      }\n    }\n\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        // WebGL 2\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        // WebGL 1\n        if (extensions.has('OES_texture_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has('OES_texture_half_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n        }\n      }\n    }\n\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    const hash = state.hash;\n\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      state.version = nextVersion++;\n    }\n  }\n\n  function setupView(lights, camera) {\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    const viewMatrix = camera.matrixWorldInverse;\n\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n\n      if (light.isDirectionalLight) {\n        const uniforms = state.directional[directionalLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = state.spot[spotLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = state.rectArea[rectAreaLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        uniforms.halfWidth.applyMatrix4(matrix42);\n        uniforms.halfHeight.applyMatrix4(matrix42);\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = state.point[pointLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = state.hemi[hemiLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.direction.normalize();\n        hemiLength++;\n      }\n    }\n  }\n\n  return {\n    setup: setup,\n    setupView: setupView,\n    state: state\n  };\n}\n\nfunction WebGLRenderState(extensions, capabilities) {\n  const lights = new WebGLLights(extensions, capabilities);\n  const lightsArray = [];\n  const shadowsArray = [];\n\n  function init() {\n    lightsArray.length = 0;\n    shadowsArray.length = 0;\n  }\n\n  function pushLight(light) {\n    lightsArray.push(light);\n  }\n\n  function pushShadow(shadowLight) {\n    shadowsArray.push(shadowLight);\n  }\n\n  function setupLights() {\n    lights.setup(lightsArray);\n  }\n\n  function setupLightsView(camera) {\n    lights.setupView(lightsArray, camera);\n  }\n\n  const state = {\n    lightsArray: lightsArray,\n    shadowsArray: shadowsArray,\n    lights: lights\n  };\n  return {\n    init: init,\n    state: state,\n    setupLights: setupLights,\n    setupLightsView: setupLightsView,\n    pushLight: pushLight,\n    pushShadow: pushShadow\n  };\n}\n\nfunction WebGLRenderStates(extensions, capabilities) {\n  let renderStates = new WeakMap();\n\n  function get(scene, renderCallDepth = 0) {\n    let renderState;\n\n    if (renderStates.has(scene) === false) {\n      renderState = new WebGLRenderState(extensions, capabilities);\n      renderStates.set(scene, [renderState]);\n    } else {\n      if (renderCallDepth >= renderStates.get(scene).length) {\n        renderState = new WebGLRenderState(extensions, capabilities);\n        renderStates.get(scene).push(renderState);\n      } else {\n        renderState = renderStates.get(scene)[renderCallDepth];\n      }\n    }\n\n    return renderState;\n  }\n\n  function dispose() {\n    renderStates = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n/**\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\n\nclass MeshDepthMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'MeshDepthMaterial';\n    this.depthPacking = BasicDepthPacking;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.depthPacking = source.depthPacking;\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    return this;\n  }\n\n}\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n/**\n * parameters = {\n *\n *  referencePosition: <float>,\n *  nearDistance: <float>,\n *  farDistance: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>\n *\n * }\n */\n\nclass MeshDistanceMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'MeshDistanceMaterial';\n    this.referencePosition = new Vector3();\n    this.nearDistance = 1;\n    this.farDistance = 1000;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.fog = false;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.referencePosition.copy(source.referencePosition);\n    this.nearDistance = source.nearDistance;\n    this.farDistance = source.farDistance;\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    return this;\n  }\n\n}\n\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\nvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean * HALF_SAMPLE_RATE;\\n\\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\nvar vsm_vert = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n  let _frustum = new Frustum();\n\n  const _shadowMapSize = new Vector2(),\n        _viewportSize = new Vector2(),\n        _viewport = new Vector4(),\n        _depthMaterial = new MeshDepthMaterial({\n    depthPacking: RGBADepthPacking\n  }),\n        _distanceMaterial = new MeshDistanceMaterial(),\n        _materialCache = {},\n        _maxTextureSize = _capabilities.maxTextureSize;\n\n  const shadowSide = {\n    0: BackSide,\n    1: FrontSide,\n    2: DoubleSide\n  };\n  const shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      SAMPLE_RATE: 2.0 / 8.0,\n      HALF_SAMPLE_RATE: 1.0 / 8.0\n    },\n    uniforms: {\n      shadow_pass: {\n        value: null\n      },\n      resolution: {\n        value: new Vector2()\n      },\n      radius: {\n        value: 4.0\n      }\n    },\n    vertexShader: vsm_vert,\n    fragmentShader: vsm_frag\n  });\n  const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  const fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  const scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n\n  this.render = function (lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n    if (lights.length === 0) return;\n\n    const currentRenderTarget = _renderer.getRenderTarget();\n\n    const activeCubeFace = _renderer.getActiveCubeFace();\n\n    const activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n    const _state = _renderer.state; // Set GL state for depth map.\n\n    _state.setBlending(NoBlending);\n\n    _state.buffers.color.setClear(1, 1, 1, 1);\n\n    _state.buffers.depth.setTest(true);\n\n    _state.setScissorTest(false); // render depth map\n\n\n    for (let i = 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n      const shadow = light.shadow;\n\n      if (shadow === undefined) {\n        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n        continue;\n      }\n\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n      _shadowMapSize.copy(shadow.mapSize);\n\n      const shadowFrameExtents = shadow.getFrameExtents();\n\n      _shadowMapSize.multiply(shadowFrameExtents);\n\n      _viewportSize.copy(shadow.mapSize);\n\n      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n\n      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        const pars = {\n          minFilter: LinearFilter,\n          magFilter: LinearFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + '.shadowMap';\n        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      if (shadow.map === null) {\n        const pars = {\n          minFilter: NearestFilter,\n          magFilter: NearestFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + '.shadowMap';\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      _renderer.setRenderTarget(shadow.map);\n\n      _renderer.clear();\n\n      const viewportCount = shadow.getViewportCount();\n\n      for (let vp = 0; vp < viewportCount; vp++) {\n        const viewport = shadow.getViewport(vp);\n\n        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n        _state.viewport(_viewport);\n\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      } // do blur pass for VSM\n\n\n      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n\n      shadow.needsUpdate = false;\n    }\n\n    scope.needsUpdate = false;\n\n    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n\n  function VSMPass(shadow, camera) {\n    const geometry = _objects.update(fullScreenMesh); // vertical pass\n\n\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.mapPass);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass\n\n\n    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.map);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n\n  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {\n    let result = null;\n    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;\n\n    if (customMaterial !== undefined) {\n      result = customMaterial;\n    } else {\n      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;\n    }\n\n    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {\n      // in this case we need a unique material instance reflecting the\n      // appropriate state\n      const keyA = result.uuid,\n            keyB = material.uuid;\n      let materialsForVariant = _materialCache[keyA];\n\n      if (materialsForVariant === undefined) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n\n      let cachedMaterial = materialsForVariant[keyB];\n\n      if (cachedMaterial === undefined) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n\n      result = cachedMaterial;\n    }\n\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n\n    return result;\n  }\n\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n        const geometry = _objects.update(object);\n\n        const material = object.material;\n\n        if (Array.isArray(material)) {\n          const groups = geometry.groups;\n\n          for (let k = 0, kl = groups.length; k < kl; k++) {\n            const group = groups[k];\n            const groupMaterial = material[group.materialIndex];\n\n            if (groupMaterial && groupMaterial.visible) {\n              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n            }\n          }\n        } else if (material.visible) {\n          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);\n\n          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n        }\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n}\n\nfunction WebGLState(gl, extensions, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  function ColorBuffer() {\n    let locked = false;\n    const color = new Vector4();\n    let currentColorMask = null;\n    const currentColorClear = new Vector4(0, 0, 0, 0);\n    return {\n      setMask: function (colorMask) {\n        if (currentColorMask !== colorMask && !locked) {\n          gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n          currentColorMask = colorMask;\n        }\n      },\n      setLocked: function (lock) {\n        locked = lock;\n      },\n      setClear: function (r, g, b, a, premultipliedAlpha) {\n        if (premultipliedAlpha === true) {\n          r *= a;\n          g *= a;\n          b *= a;\n        }\n\n        color.set(r, g, b, a);\n\n        if (currentColorClear.equals(color) === false) {\n          gl.clearColor(r, g, b, a);\n          currentColorClear.copy(color);\n        }\n      },\n      reset: function () {\n        locked = false;\n        currentColorMask = null;\n        currentColorClear.set(-1, 0, 0, 0); // set to invalid state\n      }\n    };\n  }\n\n  function DepthBuffer() {\n    let locked = false;\n    let currentDepthMask = null;\n    let currentDepthFunc = null;\n    let currentDepthClear = null;\n    return {\n      setTest: function (depthTest) {\n        if (depthTest) {\n          enable(2929);\n        } else {\n          disable(2929);\n        }\n      },\n      setMask: function (depthMask) {\n        if (currentDepthMask !== depthMask && !locked) {\n          gl.depthMask(depthMask);\n          currentDepthMask = depthMask;\n        }\n      },\n      setFunc: function (depthFunc) {\n        if (currentDepthFunc !== depthFunc) {\n          if (depthFunc) {\n            switch (depthFunc) {\n              case NeverDepth:\n                gl.depthFunc(512);\n                break;\n\n              case AlwaysDepth:\n                gl.depthFunc(519);\n                break;\n\n              case LessDepth:\n                gl.depthFunc(513);\n                break;\n\n              case LessEqualDepth:\n                gl.depthFunc(515);\n                break;\n\n              case EqualDepth:\n                gl.depthFunc(514);\n                break;\n\n              case GreaterEqualDepth:\n                gl.depthFunc(518);\n                break;\n\n              case GreaterDepth:\n                gl.depthFunc(516);\n                break;\n\n              case NotEqualDepth:\n                gl.depthFunc(517);\n                break;\n\n              default:\n                gl.depthFunc(515);\n            }\n          } else {\n            gl.depthFunc(515);\n          }\n\n          currentDepthFunc = depthFunc;\n        }\n      },\n      setLocked: function (lock) {\n        locked = lock;\n      },\n      setClear: function (depth) {\n        if (currentDepthClear !== depth) {\n          gl.clearDepth(depth);\n          currentDepthClear = depth;\n        }\n      },\n      reset: function () {\n        locked = false;\n        currentDepthMask = null;\n        currentDepthFunc = null;\n        currentDepthClear = null;\n      }\n    };\n  }\n\n  function StencilBuffer() {\n    let locked = false;\n    let currentStencilMask = null;\n    let currentStencilFunc = null;\n    let currentStencilRef = null;\n    let currentStencilFuncMask = null;\n    let currentStencilFail = null;\n    let currentStencilZFail = null;\n    let currentStencilZPass = null;\n    let currentStencilClear = null;\n    return {\n      setTest: function (stencilTest) {\n        if (!locked) {\n          if (stencilTest) {\n            enable(2960);\n          } else {\n            disable(2960);\n          }\n        }\n      },\n      setMask: function (stencilMask) {\n        if (currentStencilMask !== stencilMask && !locked) {\n          gl.stencilMask(stencilMask);\n          currentStencilMask = stencilMask;\n        }\n      },\n      setFunc: function (stencilFunc, stencilRef, stencilMask) {\n        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n          currentStencilFunc = stencilFunc;\n          currentStencilRef = stencilRef;\n          currentStencilFuncMask = stencilMask;\n        }\n      },\n      setOp: function (stencilFail, stencilZFail, stencilZPass) {\n        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n          currentStencilFail = stencilFail;\n          currentStencilZFail = stencilZFail;\n          currentStencilZPass = stencilZPass;\n        }\n      },\n      setLocked: function (lock) {\n        locked = lock;\n      },\n      setClear: function (stencil) {\n        if (currentStencilClear !== stencil) {\n          gl.clearStencil(stencil);\n          currentStencilClear = stencil;\n        }\n      },\n      reset: function () {\n        locked = false;\n        currentStencilMask = null;\n        currentStencilFunc = null;\n        currentStencilRef = null;\n        currentStencilFuncMask = null;\n        currentStencilFail = null;\n        currentStencilZFail = null;\n        currentStencilZPass = null;\n        currentStencilClear = null;\n      }\n    };\n  } //\n\n\n  const colorBuffer = new ColorBuffer();\n  const depthBuffer = new DepthBuffer();\n  const stencilBuffer = new StencilBuffer();\n  let enabledCapabilities = {};\n  let xrFramebuffer = null;\n  let currentBoundFramebuffers = {};\n  let currentProgram = null;\n  let currentBlendingEnabled = false;\n  let currentBlending = null;\n  let currentBlendEquation = null;\n  let currentBlendSrc = null;\n  let currentBlendDst = null;\n  let currentBlendEquationAlpha = null;\n  let currentBlendSrcAlpha = null;\n  let currentBlendDstAlpha = null;\n  let currentPremultipledAlpha = false;\n  let currentFlipSided = null;\n  let currentCullFace = null;\n  let currentLineWidth = null;\n  let currentPolygonOffsetFactor = null;\n  let currentPolygonOffsetUnits = null;\n  const maxTextures = gl.getParameter(35661);\n  let lineWidthAvailable = false;\n  let version = 0;\n  const glVersion = gl.getParameter(7938);\n\n  if (glVersion.indexOf('WebGL') !== -1) {\n    version = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 1.0;\n  } else if (glVersion.indexOf('OpenGL ES') !== -1) {\n    version = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 2.0;\n  }\n\n  let currentTextureSlot = null;\n  let currentBoundTextures = {};\n  const scissorParam = gl.getParameter(3088);\n  const viewportParam = gl.getParameter(2978);\n  const currentScissor = new Vector4().fromArray(scissorParam);\n  const currentViewport = new Vector4().fromArray(viewportParam);\n\n  function createTexture(type, target, count) {\n    const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n\n    const texture = gl.createTexture();\n    gl.bindTexture(type, texture);\n    gl.texParameteri(type, 10241, 9728);\n    gl.texParameteri(type, 10240, 9728);\n\n    for (let i = 0; i < count; i++) {\n      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);\n    }\n\n    return texture;\n  }\n\n  const emptyTextures = {};\n  emptyTextures[3553] = createTexture(3553, 3553, 1);\n  emptyTextures[34067] = createTexture(34067, 34069, 6); // init\n\n  colorBuffer.setClear(0, 0, 0, 1);\n  depthBuffer.setClear(1);\n  stencilBuffer.setClear(0);\n  enable(2929);\n  depthBuffer.setFunc(LessEqualDepth);\n  setFlipSided(false);\n  setCullFace(CullFaceBack);\n  enable(2884);\n  setBlending(NoBlending); //\n\n  function enable(id) {\n    if (enabledCapabilities[id] !== true) {\n      gl.enable(id);\n      enabledCapabilities[id] = true;\n    }\n  }\n\n  function disable(id) {\n    if (enabledCapabilities[id] !== false) {\n      gl.disable(id);\n      enabledCapabilities[id] = false;\n    }\n  }\n\n  function bindXRFramebuffer(framebuffer) {\n    if (framebuffer !== xrFramebuffer) {\n      gl.bindFramebuffer(36160, framebuffer);\n      xrFramebuffer = framebuffer;\n    }\n  }\n\n  function bindFramebuffer(target, framebuffer) {\n    if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n\n      if (isWebGL2) {\n        // 36009 is equivalent to 36160\n        if (target === 36009) {\n          currentBoundFramebuffers[36160] = framebuffer;\n        }\n\n        if (target === 36160) {\n          currentBoundFramebuffers[36009] = framebuffer;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function useProgram(program) {\n    if (currentProgram !== program) {\n      gl.useProgram(program);\n      currentProgram = program;\n      return true;\n    }\n\n    return false;\n  }\n\n  const equationToGL = {\n    [AddEquation]: 32774,\n    [SubtractEquation]: 32778,\n    [ReverseSubtractEquation]: 32779\n  };\n\n  if (isWebGL2) {\n    equationToGL[MinEquation] = 32775;\n    equationToGL[MaxEquation] = 32776;\n  } else {\n    const extension = extensions.get('EXT_blend_minmax');\n\n    if (extension !== null) {\n      equationToGL[MinEquation] = extension.MIN_EXT;\n      equationToGL[MaxEquation] = extension.MAX_EXT;\n    }\n  }\n\n  const factorToGL = {\n    [ZeroFactor]: 0,\n    [OneFactor]: 1,\n    [SrcColorFactor]: 768,\n    [SrcAlphaFactor]: 770,\n    [SrcAlphaSaturateFactor]: 776,\n    [DstColorFactor]: 774,\n    [DstAlphaFactor]: 772,\n    [OneMinusSrcColorFactor]: 769,\n    [OneMinusSrcAlphaFactor]: 771,\n    [OneMinusDstColorFactor]: 775,\n    [OneMinusDstAlphaFactor]: 773\n  };\n\n  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n    if (blending === NoBlending) {\n      if (currentBlendingEnabled === true) {\n        disable(3042);\n        currentBlendingEnabled = false;\n      }\n\n      return;\n    }\n\n    if (currentBlendingEnabled === false) {\n      enable(3042);\n      currentBlendingEnabled = true;\n    }\n\n    if (blending !== CustomBlending) {\n      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(32774);\n          currentBlendEquation = AddEquation;\n          currentBlendEquationAlpha = AddEquation;\n        }\n\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(1, 771, 1, 771);\n              break;\n\n            case AdditiveBlending:\n              gl.blendFunc(1, 1);\n              break;\n\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(0, 0, 769, 771);\n              break;\n\n            case MultiplyBlending:\n              gl.blendFuncSeparate(0, 768, 0, 770);\n              break;\n\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(770, 771, 1, 771);\n              break;\n\n            case AdditiveBlending:\n              gl.blendFunc(770, 1);\n              break;\n\n            case SubtractiveBlending:\n              gl.blendFunc(0, 769);\n              break;\n\n            case MultiplyBlending:\n              gl.blendFunc(0, 768);\n              break;\n\n            default:\n              console.error('THREE.WebGLState: Invalid blending: ', blending);\n              break;\n          }\n        }\n\n        currentBlendSrc = null;\n        currentBlendDst = null;\n        currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n        currentBlending = blending;\n        currentPremultipledAlpha = premultipliedAlpha;\n      }\n\n      return;\n    } // custom blending\n\n\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n\n    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      currentBlendEquation = blendEquation;\n      currentBlendEquationAlpha = blendEquationAlpha;\n    }\n\n    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      currentBlendSrc = blendSrc;\n      currentBlendDst = blendDst;\n      currentBlendSrcAlpha = blendSrcAlpha;\n      currentBlendDstAlpha = blendDstAlpha;\n    }\n\n    currentBlending = blending;\n    currentPremultipledAlpha = null;\n  }\n\n  function setMaterial(material, frontFaceCW) {\n    material.side === DoubleSide ? disable(2884) : enable(2884);\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n    setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n    depthBuffer.setFunc(material.depthFunc);\n    depthBuffer.setTest(material.depthTest);\n    depthBuffer.setMask(material.depthWrite);\n    colorBuffer.setMask(material.colorWrite);\n    const stencilWrite = material.stencilWrite;\n    stencilBuffer.setTest(stencilWrite);\n\n    if (stencilWrite) {\n      stencilBuffer.setMask(material.stencilWriteMask);\n      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n\n    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true ? enable(32926) : disable(32926);\n  } //\n\n\n  function setFlipSided(flipSided) {\n    if (currentFlipSided !== flipSided) {\n      if (flipSided) {\n        gl.frontFace(2304);\n      } else {\n        gl.frontFace(2305);\n      }\n\n      currentFlipSided = flipSided;\n    }\n  }\n\n  function setCullFace(cullFace) {\n    if (cullFace !== CullFaceNone) {\n      enable(2884);\n\n      if (cullFace !== currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(1029);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(1028);\n        } else {\n          gl.cullFace(1032);\n        }\n      }\n    } else {\n      disable(2884);\n    }\n\n    currentCullFace = cullFace;\n  }\n\n  function setLineWidth(width) {\n    if (width !== currentLineWidth) {\n      if (lineWidthAvailable) gl.lineWidth(width);\n      currentLineWidth = width;\n    }\n  }\n\n  function setPolygonOffset(polygonOffset, factor, units) {\n    if (polygonOffset) {\n      enable(32823);\n\n      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        currentPolygonOffsetFactor = factor;\n        currentPolygonOffsetUnits = units;\n      }\n    } else {\n      disable(32823);\n    }\n  }\n\n  function setScissorTest(scissorTest) {\n    if (scissorTest) {\n      enable(3089);\n    } else {\n      disable(3089);\n    }\n  } // texture\n\n\n  function activeTexture(webglSlot) {\n    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;\n\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = webglSlot;\n    }\n  }\n\n  function bindTexture(webglType, webglTexture) {\n    if (currentTextureSlot === null) {\n      activeTexture();\n    }\n\n    let boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture === undefined) {\n      boundTexture = {\n        type: undefined,\n        texture: undefined\n      };\n      currentBoundTextures[currentTextureSlot] = boundTexture;\n    }\n\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n\n  function unbindTexture() {\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture !== undefined && boundTexture.type !== undefined) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = undefined;\n      boundTexture.texture = undefined;\n    }\n  }\n\n  function compressedTexImage2D() {\n    try {\n      gl.compressedTexImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error('THREE.WebGLState:', error);\n    }\n  }\n\n  function texImage2D() {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error('THREE.WebGLState:', error);\n    }\n  }\n\n  function texImage3D() {\n    try {\n      gl.texImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error('THREE.WebGLState:', error);\n    }\n  } //\n\n\n  function scissor(scissor) {\n    if (currentScissor.equals(scissor) === false) {\n      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\n      currentScissor.copy(scissor);\n    }\n  }\n\n  function viewport(viewport) {\n    if (currentViewport.equals(viewport) === false) {\n      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\n      currentViewport.copy(viewport);\n    }\n  } //\n\n\n  function reset() {\n    // reset state\n    gl.disable(3042);\n    gl.disable(2884);\n    gl.disable(2929);\n    gl.disable(32823);\n    gl.disable(3089);\n    gl.disable(2960);\n    gl.disable(32926);\n    gl.blendEquation(32774);\n    gl.blendFunc(1, 0);\n    gl.blendFuncSeparate(1, 0, 1, 0);\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0, 0, 0, 0);\n    gl.depthMask(true);\n    gl.depthFunc(513);\n    gl.clearDepth(1);\n    gl.stencilMask(0xffffffff);\n    gl.stencilFunc(519, 0, 0xffffffff);\n    gl.stencilOp(7680, 7680, 7680);\n    gl.clearStencil(0);\n    gl.cullFace(1029);\n    gl.frontFace(2305);\n    gl.polygonOffset(0, 0);\n    gl.activeTexture(33984);\n    gl.bindFramebuffer(36160, null);\n\n    if (isWebGL2 === true) {\n      gl.bindFramebuffer(36009, null);\n      gl.bindFramebuffer(36008, null);\n    }\n\n    gl.useProgram(null);\n    gl.lineWidth(1);\n    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals\n\n    enabledCapabilities = {};\n    currentTextureSlot = null;\n    currentBoundTextures = {};\n    xrFramebuffer = null;\n    currentBoundFramebuffers = {};\n    currentProgram = null;\n    currentBlendingEnabled = false;\n    currentBlending = null;\n    currentBlendEquation = null;\n    currentBlendSrc = null;\n    currentBlendDst = null;\n    currentBlendEquationAlpha = null;\n    currentBlendSrcAlpha = null;\n    currentBlendDstAlpha = null;\n    currentPremultipledAlpha = false;\n    currentFlipSided = null;\n    currentCullFace = null;\n    currentLineWidth = null;\n    currentPolygonOffsetFactor = null;\n    currentPolygonOffsetUnits = null;\n    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n    colorBuffer.reset();\n    depthBuffer.reset();\n    stencilBuffer.reset();\n  }\n\n  return {\n    buffers: {\n      color: colorBuffer,\n      depth: depthBuffer,\n      stencil: stencilBuffer\n    },\n    enable: enable,\n    disable: disable,\n    bindFramebuffer: bindFramebuffer,\n    bindXRFramebuffer: bindXRFramebuffer,\n    useProgram: useProgram,\n    setBlending: setBlending,\n    setMaterial: setMaterial,\n    setFlipSided: setFlipSided,\n    setCullFace: setCullFace,\n    setLineWidth: setLineWidth,\n    setPolygonOffset: setPolygonOffset,\n    setScissorTest: setScissorTest,\n    activeTexture: activeTexture,\n    bindTexture: bindTexture,\n    unbindTexture: unbindTexture,\n    compressedTexImage2D: compressedTexImage2D,\n    texImage2D: texImage2D,\n    texImage3D: texImage3D,\n    scissor: scissor,\n    viewport: viewport,\n    reset: reset\n  };\n}\n\nfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const maxTextures = capabilities.maxTextures;\n  const maxCubemapSize = capabilities.maxCubemapSize;\n  const maxTextureSize = capabilities.maxTextureSize;\n  const maxSamples = capabilities.maxSamples;\n\n  const _videoTextures = new WeakMap();\n\n  let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n  // also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\n  let useOffscreenCanvas = false;\n\n  try {\n    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;\n  } catch (err) {// Ignore any errors\n  }\n\n  function createCanvas(width, height) {\n    // Use OffscreenCanvas when available. Specially needed in web workers\n    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n  }\n\n  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n    let scale = 1; // handle case if texture exceeds max size\n\n    if (image.width > maxSize || image.height > maxSize) {\n      scale = maxSize / Math.max(image.width, image.height);\n    } // only perform resize if necessary\n\n\n    if (scale < 1 || needsPowerOfTwo === true) {\n      // only perform resize for certain image types\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n        const width = floor(scale * image.width);\n        const height = floor(scale * image.height);\n        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas\n\n        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n        canvas.width = width;\n        canvas.height = height;\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0, width, height);\n        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');\n        return canvas;\n      } else {\n        if ('data' in image) {\n          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');\n        }\n\n        return image;\n      }\n    }\n\n    return image;\n  }\n\n  function isPowerOfTwo$1(image) {\n    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n  }\n\n  function textureNeedsPowerOfTwo(texture) {\n    if (isWebGL2) return false;\n    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n\n  function textureNeedsGenerateMipmaps(texture, supportsMips) {\n    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n\n  function generateMipmap(target, texture, width, height, depth = 1) {\n    _gl.generateMipmap(target);\n\n    const textureProperties = properties.get(texture);\n    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));\n  }\n\n  function getInternalFormat(internalFormatName, glFormat, glType) {\n    if (isWebGL2 === false) return glFormat;\n\n    if (internalFormatName !== null) {\n      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n    }\n\n    let internalFormat = glFormat;\n\n    if (glFormat === 6403) {\n      if (glType === 5126) internalFormat = 33326;\n      if (glType === 5131) internalFormat = 33325;\n      if (glType === 5121) internalFormat = 33321;\n    }\n\n    if (glFormat === 6407) {\n      if (glType === 5126) internalFormat = 34837;\n      if (glType === 5131) internalFormat = 34843;\n      if (glType === 5121) internalFormat = 32849;\n    }\n\n    if (glFormat === 6408) {\n      if (glType === 5126) internalFormat = 34836;\n      if (glType === 5131) internalFormat = 34842;\n      if (glType === 5121) internalFormat = 32856;\n    }\n\n    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {\n      extensions.get('EXT_color_buffer_float');\n    }\n\n    return internalFormat;\n  } // Fallback filters for non-power-of-2 textures\n\n\n  function filterFallback(f) {\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return 9728;\n    }\n\n    return 9729;\n  } //\n\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    deallocateTexture(texture);\n\n    if (texture.isVideoTexture) {\n      _videoTextures.delete(texture);\n    }\n\n    info.memory.textures--;\n  }\n\n  function onRenderTargetDispose(event) {\n    const renderTarget = event.target;\n    renderTarget.removeEventListener('dispose', onRenderTargetDispose);\n    deallocateRenderTarget(renderTarget);\n  } //\n\n\n  function deallocateTexture(texture) {\n    const textureProperties = properties.get(texture);\n    if (textureProperties.__webglInit === undefined) return;\n\n    _gl.deleteTexture(textureProperties.__webglTexture);\n\n    properties.remove(texture);\n  }\n\n  function deallocateRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    if (!renderTarget) return;\n\n    if (textureProperties.__webglTexture !== undefined) {\n      _gl.deleteTexture(textureProperties.__webglTexture);\n\n      info.memory.textures--;\n    }\n\n    if (renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n    }\n\n    if (renderTarget.isWebGLCubeRenderTarget) {\n      for (let i = 0; i < 6; i++) {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n\n        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n      }\n    } else {\n      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    }\n\n    if (renderTarget.isWebGLMultipleRenderTargets) {\n      for (let i = 0, il = texture.length; i < il; i++) {\n        const attachmentProperties = properties.get(texture[i]);\n\n        if (attachmentProperties.__webglTexture) {\n          _gl.deleteTexture(attachmentProperties.__webglTexture);\n\n          info.memory.textures--;\n        }\n\n        properties.remove(texture[i]);\n      }\n    }\n\n    properties.remove(texture);\n    properties.remove(renderTarget);\n  } //\n\n\n  let textureUnits = 0;\n\n  function resetTextureUnits() {\n    textureUnits = 0;\n  }\n\n  function allocateTextureUnit() {\n    const textureUnit = textureUnits;\n\n    if (textureUnit >= maxTextures) {\n      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);\n    }\n\n    textureUnits += 1;\n    return textureUnit;\n  } //\n\n\n  function setTexture2D(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.isVideoTexture) updateVideoTexture(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      const image = texture.image;\n\n      if (image === undefined) {\n        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');\n      } else if (image.complete === false) {\n        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');\n      } else {\n        uploadTexture(textureProperties, texture, slot);\n        return;\n      }\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(3553, textureProperties.__webglTexture);\n  }\n\n  function setTexture2DArray(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(35866, textureProperties.__webglTexture);\n  }\n\n  function setTexture3D(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(32879, textureProperties.__webglTexture);\n  }\n\n  function setTextureCube(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadCubeTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n  }\n\n  const wrappingToGL = {\n    [RepeatWrapping]: 10497,\n    [ClampToEdgeWrapping]: 33071,\n    [MirroredRepeatWrapping]: 33648\n  };\n  const filterToGL = {\n    [NearestFilter]: 9728,\n    [NearestMipmapNearestFilter]: 9984,\n    [NearestMipmapLinearFilter]: 9986,\n    [LinearFilter]: 9729,\n    [LinearMipmapNearestFilter]: 9985,\n    [LinearMipmapLinearFilter]: 9987\n  };\n\n  function setTextureParameters(textureType, texture, supportsMips) {\n    if (supportsMips) {\n      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);\n\n      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);\n\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);\n      }\n\n      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);\n\n      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);\n    } else {\n      _gl.texParameteri(textureType, 10242, 33071);\n\n      _gl.texParameteri(textureType, 10243, 33071);\n\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, 33071);\n      }\n\n      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');\n      }\n\n      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));\n\n      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));\n\n      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');\n      }\n    }\n\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n      if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only\n\n      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n\n  function initTexture(textureProperties, texture) {\n    if (textureProperties.__webglInit === undefined) {\n      textureProperties.__webglInit = true;\n      texture.addEventListener('dispose', onTextureDispose);\n      textureProperties.__webglTexture = _gl.createTexture();\n      info.memory.textures++;\n    }\n  }\n\n  function uploadTexture(textureProperties, texture, slot) {\n    let textureType = 3553;\n    if (texture.isDataTexture2DArray) textureType = 35866;\n    if (texture.isDataTexture3D) textureType = 32879;\n    initTexture(textureProperties, texture);\n    state.activeTexture(33984 + slot);\n    state.bindTexture(textureType, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(37440, texture.flipY);\n\n    _gl.pixelStorei(37441, texture.premultiplyAlpha);\n\n    _gl.pixelStorei(3317, texture.unpackAlignment);\n\n    _gl.pixelStorei(37443, 0);\n\n    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;\n    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n    const supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n          glFormat = utils.convert(texture.format);\n    let glType = utils.convert(texture.type),\n        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n    setTextureParameters(textureType, texture, supportsMips);\n    let mipmap;\n    const mipmaps = texture.mipmaps;\n\n    if (texture.isDepthTexture) {\n      // populate depth texture with dummy data\n      glInternalFormat = 6402;\n\n      if (isWebGL2) {\n        if (texture.type === FloatType) {\n          glInternalFormat = 36012;\n        } else if (texture.type === UnsignedIntType) {\n          glInternalFormat = 33190;\n        } else if (texture.type === UnsignedInt248Type) {\n          glInternalFormat = 35056;\n        } else {\n          glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D\n        }\n      } else {\n        if (texture.type === FloatType) {\n          console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');\n        }\n      } // validation checks for WebGL 1\n\n\n      if (texture.format === DepthFormat && glInternalFormat === 6402) {\n        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\n          texture.type = UnsignedShortType;\n          glType = utils.convert(texture.type);\n        }\n      }\n\n      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {\n        // Depth stencil textures need the DEPTH_STENCIL internal format\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\n        if (texture.type !== UnsignedInt248Type) {\n          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\n          texture.type = UnsignedInt248Type;\n          glType = utils.convert(texture.type);\n        }\n      } //\n\n\n      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n    } else if (texture.isDataTexture) {\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n      if (mipmaps.length > 0 && supportsMips) {\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n        }\n\n        texture.generateMipmaps = false;\n        textureProperties.__maxMipLevel = mipmaps.length - 1;\n      } else {\n        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n        textureProperties.__maxMipLevel = 0;\n      }\n    } else if (texture.isCompressedTexture) {\n      for (let i = 0, il = mipmaps.length; i < il; i++) {\n        mipmap = mipmaps[i];\n\n        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n          if (glFormat !== null) {\n            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n          } else {\n            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n          }\n        } else {\n          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n        }\n      }\n\n      textureProperties.__maxMipLevel = mipmaps.length - 1;\n    } else if (texture.isDataTexture2DArray) {\n      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n      textureProperties.__maxMipLevel = 0;\n    } else if (texture.isDataTexture3D) {\n      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n      textureProperties.__maxMipLevel = 0;\n    } else {\n      // regular Texture (image, video, canvas)\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n      if (mipmaps.length > 0 && supportsMips) {\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);\n        }\n\n        texture.generateMipmaps = false;\n        textureProperties.__maxMipLevel = mipmaps.length - 1;\n      } else {\n        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);\n        textureProperties.__maxMipLevel = 0;\n      }\n    }\n\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      generateMipmap(textureType, texture, image.width, image.height);\n    }\n\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n\n  function uploadCubeTexture(textureProperties, texture, slot) {\n    if (texture.image.length !== 6) return;\n    initTexture(textureProperties, texture);\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(37440, texture.flipY);\n\n    _gl.pixelStorei(37441, texture.premultiplyAlpha);\n\n    _gl.pixelStorei(3317, texture.unpackAlignment);\n\n    _gl.pixelStorei(37443, 0);\n\n    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n    const cubeImage = [];\n\n    for (let i = 0; i < 6; i++) {\n      if (!isCompressed && !isDataTexture) {\n        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);\n      } else {\n        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n      }\n    }\n\n    const image = cubeImage[0],\n          supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n          glFormat = utils.convert(texture.format),\n          glType = utils.convert(texture.type),\n          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n    setTextureParameters(34067, texture, supportsMips);\n    let mipmaps;\n\n    if (isCompressed) {\n      for (let i = 0; i < 6; i++) {\n        mipmaps = cubeImage[i].mipmaps;\n\n        for (let j = 0; j < mipmaps.length; j++) {\n          const mipmap = mipmaps[j];\n\n          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n            if (glFormat !== null) {\n              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n            } else {\n              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');\n            }\n          } else {\n            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n          }\n        }\n      }\n\n      textureProperties.__maxMipLevel = mipmaps.length - 1;\n    } else {\n      mipmaps = texture.mipmaps;\n\n      for (let i = 0; i < 6; i++) {\n        if (isDataTexture) {\n          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            const mipmapImage = mipmap.image[i].image;\n            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n          }\n        } else {\n          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n          }\n        }\n      }\n\n      textureProperties.__maxMipLevel = mipmaps.length;\n    }\n\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      // We assume images for cube map have the same size.\n      generateMipmap(34067, texture, image.width, image.height);\n    }\n\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  } // Render targets\n  // Setup storage for target texture and bind it to correct framebuffer\n\n\n  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {\n    const glFormat = utils.convert(texture.format);\n    const glType = utils.convert(texture.type);\n    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n    if (textureTarget === 32879 || textureTarget === 35866) {\n      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n    } else {\n      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n    }\n\n    state.bindFramebuffer(36160, framebuffer);\n\n    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n\n    state.bindFramebuffer(36160, null);\n  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\n\n  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    _gl.bindRenderbuffer(36161, renderbuffer);\n\n    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n      let glInternalFormat = 33189;\n\n      if (isMultisample) {\n        const depthTexture = renderTarget.depthTexture;\n\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === FloatType) {\n            glInternalFormat = 36012;\n          } else if (depthTexture.type === UnsignedIntType) {\n            glInternalFormat = 33190;\n          }\n        }\n\n        const samples = getRenderTargetSamples(renderTarget);\n\n        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n\n      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);\n    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n      if (isMultisample) {\n        const samples = getRenderTargetSamples(renderTarget);\n\n        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);\n      }\n\n      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);\n    } else {\n      // Use the first texture for MRT so far\n      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;\n      const glFormat = utils.convert(texture.format);\n      const glType = utils.convert(texture.type);\n      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n      if (isMultisample) {\n        const samples = getRenderTargetSamples(renderTarget);\n\n        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n    }\n\n    _gl.bindRenderbuffer(36161, null);\n  } // Setup resources for a Depth Texture for a FBO (needs an extension)\n\n\n  function setupDepthTexture(framebuffer, renderTarget) {\n    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');\n    state.bindFramebuffer(36160, framebuffer);\n\n    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n    } // upload an empty depth texture with framebuffer size\n\n\n    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n      renderTarget.depthTexture.image.width = renderTarget.width;\n      renderTarget.depthTexture.image.height = renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n    }\n\n    setTexture2D(renderTarget.depthTexture, 0);\n\n    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n\n    if (renderTarget.depthTexture.format === DepthFormat) {\n      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);\n    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);\n    } else {\n      throw new Error('Unknown depthTexture format');\n    }\n  } // Setup GL resources for a non-texture depth buffer\n\n\n  function setupDepthRenderbuffer(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n    if (renderTarget.depthTexture) {\n      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');\n      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n    } else {\n      if (isCube) {\n        renderTargetProperties.__webglDepthbuffer = [];\n\n        for (let i = 0; i < 6; i++) {\n          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);\n          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n        }\n      } else {\n        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\n        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n      }\n    }\n\n    state.bindFramebuffer(36160, null);\n  } // Set up GL resources for the render target\n\n\n  function setupRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    renderTarget.addEventListener('dispose', onRenderTargetDispose);\n\n    if (renderTarget.isWebGLMultipleRenderTargets !== true) {\n      textureProperties.__webglTexture = _gl.createTexture();\n      textureProperties.__version = texture.version;\n      info.memory.textures++;\n    }\n\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;\n    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;\n    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858\n\n    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {\n      texture.format = RGBAFormat;\n      console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');\n    } // Setup framebuffer\n\n\n    if (isCube) {\n      renderTargetProperties.__webglFramebuffer = [];\n\n      for (let i = 0; i < 6; i++) {\n        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n      }\n    } else {\n      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n      if (isMultipleRenderTargets) {\n        if (capabilities.drawBuffers) {\n          const textures = renderTarget.texture;\n\n          for (let i = 0, il = textures.length; i < il; i++) {\n            const attachmentProperties = properties.get(textures[i]);\n\n            if (attachmentProperties.__webglTexture === undefined) {\n              attachmentProperties.__webglTexture = _gl.createTexture();\n              info.memory.textures++;\n            }\n          }\n        } else {\n          console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');\n        }\n      } else if (isMultisample) {\n        if (isWebGL2) {\n          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);\n\n          const glFormat = utils.convert(texture.format);\n          const glType = utils.convert(texture.type);\n          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n          const samples = getRenderTargetSamples(renderTarget);\n\n          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\n          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);\n\n          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);\n\n          _gl.bindRenderbuffer(36161, null);\n\n          if (renderTarget.depthBuffer) {\n            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n          }\n\n          state.bindFramebuffer(36160, null);\n        } else {\n          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n        }\n      }\n    } // Setup color buffer\n\n\n    if (isCube) {\n      state.bindTexture(34067, textureProperties.__webglTexture);\n      setTextureParameters(34067, texture, supportsMips);\n\n      for (let i = 0; i < 6; i++) {\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);\n      }\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);\n      }\n\n      state.bindTexture(34067, null);\n    } else if (isMultipleRenderTargets) {\n      const textures = renderTarget.texture;\n\n      for (let i = 0, il = textures.length; i < il; i++) {\n        const attachment = textures[i];\n        const attachmentProperties = properties.get(attachment);\n        state.bindTexture(3553, attachmentProperties.__webglTexture);\n        setTextureParameters(3553, attachment, supportsMips);\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);\n\n        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n          generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);\n        }\n      }\n\n      state.bindTexture(3553, null);\n    } else {\n      let glTextureType = 3553;\n\n      if (isRenderTarget3D) {\n        // Render targets containing layers, i.e: Texture 3D and 2d arrays\n        if (isWebGL2) {\n          const isTexture3D = texture.isDataTexture3D;\n          glTextureType = isTexture3D ? 32879 : 35866;\n        } else {\n          console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');\n        }\n      }\n\n      state.bindTexture(glTextureType, textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, texture, supportsMips);\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);\n      }\n\n      state.bindTexture(glTextureType, null);\n    } // Setup depth and stencil buffers\n\n\n    if (renderTarget.depthBuffer) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n\n  function updateRenderTargetMipmap(renderTarget) {\n    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n    for (let i = 0, il = textures.length; i < il; i++) {\n      const texture = textures[i];\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\n\n        const webglTexture = properties.get(texture).__webglTexture;\n\n        state.bindTexture(target, webglTexture);\n        generateMipmap(target, texture, renderTarget.width, renderTarget.height);\n        state.bindTexture(target, null);\n      }\n    }\n  }\n\n  function updateMultisampleRenderTarget(renderTarget) {\n    if (renderTarget.isWebGLMultisampleRenderTarget) {\n      if (isWebGL2) {\n        const width = renderTarget.width;\n        const height = renderTarget.height;\n        let mask = 16384;\n        if (renderTarget.depthBuffer) mask |= 256;\n        if (renderTarget.stencilBuffer) mask |= 1024;\n        const renderTargetProperties = properties.get(renderTarget);\n        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);\n        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);\n\n        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);\n\n        state.bindFramebuffer(36008, null);\n        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);\n      } else {\n        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n      }\n    }\n  }\n\n  function getRenderTargetSamples(renderTarget) {\n    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;\n  }\n\n  function updateVideoTexture(texture) {\n    const frame = info.render.frame; // Check the last frame we updated the VideoTexture\n\n    if (_videoTextures.get(texture) !== frame) {\n      _videoTextures.set(texture, frame);\n\n      texture.update();\n    }\n  } // backwards compatibility\n\n\n  let warnedTexture2D = false;\n  let warnedTextureCube = false;\n\n  function safeSetTexture2D(texture, slot) {\n    if (texture && texture.isWebGLRenderTarget) {\n      if (warnedTexture2D === false) {\n        console.warn('THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.');\n        warnedTexture2D = true;\n      }\n\n      texture = texture.texture;\n    }\n\n    setTexture2D(texture, slot);\n  }\n\n  function safeSetTextureCube(texture, slot) {\n    if (texture && texture.isWebGLCubeRenderTarget) {\n      if (warnedTextureCube === false) {\n        console.warn('THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.');\n        warnedTextureCube = true;\n      }\n\n      texture = texture.texture;\n    }\n\n    setTextureCube(texture, slot);\n  } //\n\n\n  this.allocateTextureUnit = allocateTextureUnit;\n  this.resetTextureUnits = resetTextureUnits;\n  this.setTexture2D = setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  this.setupRenderTarget = setupRenderTarget;\n  this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n  this.safeSetTexture2D = safeSetTexture2D;\n  this.safeSetTextureCube = safeSetTextureCube;\n}\n\nfunction WebGLUtils(gl, extensions, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n\n  function convert(p) {\n    let extension;\n    if (p === UnsignedByteType) return 5121;\n    if (p === UnsignedShort4444Type) return 32819;\n    if (p === UnsignedShort5551Type) return 32820;\n    if (p === UnsignedShort565Type) return 33635;\n    if (p === ByteType) return 5120;\n    if (p === ShortType) return 5122;\n    if (p === UnsignedShortType) return 5123;\n    if (p === IntType) return 5124;\n    if (p === UnsignedIntType) return 5125;\n    if (p === FloatType) return 5126;\n\n    if (p === HalfFloatType) {\n      if (isWebGL2) return 5131;\n      extension = extensions.get('OES_texture_half_float');\n\n      if (extension !== null) {\n        return extension.HALF_FLOAT_OES;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === AlphaFormat) return 6406;\n    if (p === RGBFormat) return 6407;\n    if (p === RGBAFormat) return 6408;\n    if (p === LuminanceFormat) return 6409;\n    if (p === LuminanceAlphaFormat) return 6410;\n    if (p === DepthFormat) return 6402;\n    if (p === DepthStencilFormat) return 34041;\n    if (p === RedFormat) return 6403; // WebGL2 formats.\n\n    if (p === RedIntegerFormat) return 36244;\n    if (p === RGFormat) return 33319;\n    if (p === RGIntegerFormat) return 33320;\n    if (p === RGBIntegerFormat) return 36248;\n    if (p === RGBAIntegerFormat) return 36249;\n\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_s3tc');\n\n      if (extension !== null) {\n        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_pvrtc');\n\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGB_ETC1_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc1');\n\n      if (extension !== null) {\n        return extension.COMPRESSED_RGB_ETC1_WEBGL;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_etc');\n\n      if (extension !== null) {\n        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;\n      }\n    }\n\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {\n      extension = extensions.get('WEBGL_compressed_texture_astc');\n\n      if (extension !== null) {\n        // TODO Complete?\n        return p;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get('EXT_texture_compression_bptc');\n\n      if (extension !== null) {\n        // TODO Complete?\n        return p;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === UnsignedInt248Type) {\n      if (isWebGL2) return 34042;\n      extension = extensions.get('WEBGL_depth_texture');\n\n      if (extension !== null) {\n        return extension.UNSIGNED_INT_24_8_WEBGL;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return {\n    convert: convert\n  };\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n  constructor(array = []) {\n    super();\n    this.cameras = array;\n  }\n\n}\n\nArrayCamera.prototype.isArrayCamera = true;\n\nclass Group extends Object3D {\n  constructor() {\n    super();\n    this.type = 'Group';\n  }\n\n}\n\nGroup.prototype.isGroup = true;\nconst _moveEvent = {\n  type: 'move'\n};\n\nclass WebXRController {\n  constructor() {\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n\n  getHandSpace() {\n    if (this._hand === null) {\n      this._hand = new Group();\n      this._hand.matrixAutoUpdate = false;\n      this._hand.visible = false;\n      this._hand.joints = {};\n      this._hand.inputState = {\n        pinching: false\n      };\n    }\n\n    return this._hand;\n  }\n\n  getTargetRaySpace() {\n    if (this._targetRay === null) {\n      this._targetRay = new Group();\n      this._targetRay.matrixAutoUpdate = false;\n      this._targetRay.visible = false;\n      this._targetRay.hasLinearVelocity = false;\n      this._targetRay.linearVelocity = new Vector3();\n      this._targetRay.hasAngularVelocity = false;\n      this._targetRay.angularVelocity = new Vector3();\n    }\n\n    return this._targetRay;\n  }\n\n  getGripSpace() {\n    if (this._grip === null) {\n      this._grip = new Group();\n      this._grip.matrixAutoUpdate = false;\n      this._grip.visible = false;\n      this._grip.hasLinearVelocity = false;\n      this._grip.linearVelocity = new Vector3();\n      this._grip.hasAngularVelocity = false;\n      this._grip.angularVelocity = new Vector3();\n    }\n\n    return this._grip;\n  }\n\n  dispatchEvent(event) {\n    if (this._targetRay !== null) {\n      this._targetRay.dispatchEvent(event);\n    }\n\n    if (this._grip !== null) {\n      this._grip.dispatchEvent(event);\n    }\n\n    if (this._hand !== null) {\n      this._hand.dispatchEvent(event);\n    }\n\n    return this;\n  }\n\n  disconnect(inputSource) {\n    this.dispatchEvent({\n      type: 'disconnected',\n      data: inputSource\n    });\n\n    if (this._targetRay !== null) {\n      this._targetRay.visible = false;\n    }\n\n    if (this._grip !== null) {\n      this._grip.visible = false;\n    }\n\n    if (this._hand !== null) {\n      this._hand.visible = false;\n    }\n\n    return this;\n  }\n\n  update(inputSource, frame, referenceSpace) {\n    let inputPose = null;\n    let gripPose = null;\n    let handPose = null;\n    const targetRay = this._targetRay;\n    const grip = this._grip;\n    const hand = this._hand;\n\n    if (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n      if (targetRay !== null) {\n        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n        if (inputPose !== null) {\n          targetRay.matrix.fromArray(inputPose.transform.matrix);\n          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n\n          if (inputPose.linearVelocity) {\n            targetRay.hasLinearVelocity = true;\n            targetRay.linearVelocity.copy(inputPose.linearVelocity);\n          } else {\n            targetRay.hasLinearVelocity = false;\n          }\n\n          if (inputPose.angularVelocity) {\n            targetRay.hasAngularVelocity = true;\n            targetRay.angularVelocity.copy(inputPose.angularVelocity);\n          } else {\n            targetRay.hasAngularVelocity = false;\n          }\n\n          this.dispatchEvent(_moveEvent);\n        }\n      }\n\n      if (hand && inputSource.hand) {\n        handPose = true;\n\n        for (const inputjoint of inputSource.hand.values()) {\n          // Update the joints groups with the XRJoint poses\n          const jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n          if (hand.joints[inputjoint.jointName] === undefined) {\n            // The transform of this joint will be updated with the joint pose on each frame\n            const joint = new Group();\n            joint.matrixAutoUpdate = false;\n            joint.visible = false;\n            hand.joints[inputjoint.jointName] = joint; // ??\n\n            hand.add(joint);\n          }\n\n          const joint = hand.joints[inputjoint.jointName];\n\n          if (jointPose !== null) {\n            joint.matrix.fromArray(jointPose.transform.matrix);\n            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n            joint.jointRadius = jointPose.radius;\n          }\n\n          joint.visible = jointPose !== null;\n        } // Custom events\n        // Check pinchz\n\n\n        const indexTip = hand.joints['index-finger-tip'];\n        const thumbTip = hand.joints['thumb-tip'];\n        const distance = indexTip.position.distanceTo(thumbTip.position);\n        const distanceToPinch = 0.02;\n        const threshold = 0.005;\n\n        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n          hand.inputState.pinching = false;\n          this.dispatchEvent({\n            type: 'pinchend',\n            handedness: inputSource.handedness,\n            target: this\n          });\n        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n          hand.inputState.pinching = true;\n          this.dispatchEvent({\n            type: 'pinchstart',\n            handedness: inputSource.handedness,\n            target: this\n          });\n        }\n      } else {\n        if (grip !== null && inputSource.gripSpace) {\n          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n          if (gripPose !== null) {\n            grip.matrix.fromArray(gripPose.transform.matrix);\n            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n            if (gripPose.linearVelocity) {\n              grip.hasLinearVelocity = true;\n              grip.linearVelocity.copy(gripPose.linearVelocity);\n            } else {\n              grip.hasLinearVelocity = false;\n            }\n\n            if (gripPose.angularVelocity) {\n              grip.hasAngularVelocity = true;\n              grip.angularVelocity.copy(gripPose.angularVelocity);\n            } else {\n              grip.hasAngularVelocity = false;\n            }\n          }\n        }\n      }\n    }\n\n    if (targetRay !== null) {\n      targetRay.visible = inputPose !== null;\n    }\n\n    if (grip !== null) {\n      grip.visible = gripPose !== null;\n    }\n\n    if (hand !== null) {\n      hand.visible = handPose !== null;\n    }\n\n    return this;\n  }\n\n}\n\nclass WebXRManager extends EventDispatcher {\n  constructor(renderer, gl) {\n    super();\n    const scope = this;\n    const state = renderer.state;\n    let session = null;\n    let framebufferScaleFactor = 1.0;\n    let referenceSpace = null;\n    let referenceSpaceType = 'local-floor';\n    let pose = null;\n    let glBinding = null;\n    let glFramebuffer = null;\n    let glProjLayer = null;\n    let glBaseLayer = null;\n    const controllers = [];\n    const inputSourcesMap = new Map(); //\n\n    const cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n    const cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n    const cameras = [cameraL, cameraR];\n    const cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n    let _currentDepthNear = null;\n    let _currentDepthFar = null; //\n\n    this.cameraAutoUpdate = true;\n    this.enabled = false;\n    this.isPresenting = false;\n\n    this.getController = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getTargetRaySpace();\n    };\n\n    this.getControllerGrip = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getGripSpace();\n    };\n\n    this.getHand = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getHandSpace();\n    }; //\n\n\n    function onSessionEvent(event) {\n      const controller = inputSourcesMap.get(event.inputSource);\n\n      if (controller) {\n        controller.dispatchEvent({\n          type: event.type,\n          data: event.inputSource\n        });\n      }\n    }\n\n    function onSessionEnd() {\n      inputSourcesMap.forEach(function (controller, inputSource) {\n        controller.disconnect(inputSource);\n      });\n      inputSourcesMap.clear();\n      _currentDepthNear = null;\n      _currentDepthFar = null; // restore framebuffer/rendering state\n\n      state.bindXRFramebuffer(null);\n      renderer.setRenderTarget(renderer.getRenderTarget()); //\n\n      animation.stop();\n      scope.isPresenting = false;\n      scope.dispatchEvent({\n        type: 'sessionend'\n      });\n    }\n\n    this.setFramebufferScaleFactor = function (value) {\n      framebufferScaleFactor = value;\n\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n      }\n    };\n\n    this.setReferenceSpaceType = function (value) {\n      referenceSpaceType = value;\n\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n      }\n    };\n\n    this.getReferenceSpace = function () {\n      return referenceSpace;\n    };\n\n    this.getSession = function () {\n      return session;\n    };\n\n    this.setSession = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (value) {\n        session = value;\n\n        if (session !== null) {\n          session.addEventListener('select', onSessionEvent);\n          session.addEventListener('selectstart', onSessionEvent);\n          session.addEventListener('selectend', onSessionEvent);\n          session.addEventListener('squeeze', onSessionEvent);\n          session.addEventListener('squeezestart', onSessionEvent);\n          session.addEventListener('squeezeend', onSessionEvent);\n          session.addEventListener('end', onSessionEnd);\n          session.addEventListener('inputsourceschange', onInputSourcesChange);\n          const attributes = gl.getContextAttributes();\n\n          if (attributes.xrCompatible !== true) {\n            yield gl.makeXRCompatible();\n          }\n\n          if (session.renderState.layers === undefined) {\n            const layerInit = {\n              antialias: attributes.antialias,\n              alpha: attributes.alpha,\n              depth: attributes.depth,\n              stencil: attributes.stencil,\n              framebufferScaleFactor: framebufferScaleFactor\n            };\n            glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n            session.updateRenderState({\n              baseLayer: glBaseLayer\n            });\n          } else {\n            let depthFormat = 0; // for anti-aliased output, use classic webgllayer for now\n\n            if (attributes.antialias) {\n              const layerInit = {\n                antialias: true,\n                alpha: attributes.alpha,\n                depth: attributes.depth,\n                stencil: attributes.stencil,\n                framebufferScaleFactor: framebufferScaleFactor\n              };\n              glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n              session.updateRenderState({\n                layers: [glBaseLayer]\n              });\n            } else {\n              if (attributes.depth) {\n                depthFormat = attributes.stencil ? 34041 : 6402;\n              }\n\n              const projectionlayerInit = {\n                colorFormat: attributes.alpha ? 6408 : 6407,\n                depthFormat: depthFormat,\n                scaleFactor: framebufferScaleFactor\n              };\n              glBinding = new XRWebGLBinding(session, gl);\n              glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n              glFramebuffer = gl.createFramebuffer();\n              session.updateRenderState({\n                layers: [glProjLayer]\n              });\n            }\n          }\n\n          referenceSpace = yield session.requestReferenceSpace(referenceSpaceType);\n          animation.setContext(session);\n          animation.start();\n          scope.isPresenting = true;\n          scope.dispatchEvent({\n            type: 'sessionstart'\n          });\n        }\n      });\n\n      return function (_x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    function onInputSourcesChange(event) {\n      const inputSources = session.inputSources; // Assign inputSources to available controllers\n\n      for (let i = 0; i < controllers.length; i++) {\n        inputSourcesMap.set(inputSources[i], controllers[i]);\n      } // Notify disconnected\n\n\n      for (let i = 0; i < event.removed.length; i++) {\n        const inputSource = event.removed[i];\n        const controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({\n            type: 'disconnected',\n            data: inputSource\n          });\n          inputSourcesMap.delete(inputSource);\n        }\n      } // Notify connected\n\n\n      for (let i = 0; i < event.added.length; i++) {\n        const inputSource = event.added[i];\n        const controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({\n            type: 'connected',\n            data: inputSource\n          });\n        }\n      }\n    } //\n\n\n    const cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n    /**\n     * Assumes 2 cameras that are parallel and share an X-axis, and that\n     * the cameras' projection and world matrices have already been set.\n     * And that near and far planes are identical for both cameras.\n     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n     */\n\n    function setProjectionFromUnion(camera, cameraL, cameraR) {\n      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n      const ipd = cameraLPos.distanceTo(cameraRPos);\n      const projL = cameraL.projectionMatrix.elements;\n      const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n      // most likely identical top and bottom frustum extents.\n      // Use the left camera for these values.\n\n      const near = projL[14] / (projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / projL[5];\n      const leftFov = (projL[8] - 1) / projL[0];\n      const rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n      const right = near * rightFov; // Calculate the new camera's position offset from the\n      // left camera. xOffset should be roughly half `ipd`.\n\n      const zOffset = ipd / (-leftFov + rightFov);\n      const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n      // the values so that the near plane's position does not change in world space,\n      // although must now be relative to the new union camera.\n\n      const near2 = near + zOffset;\n      const far2 = far + zOffset;\n      const left2 = left - xOffset;\n      const right2 = right + (ipd - xOffset);\n      const top2 = topFov * far / far2 * near2;\n      const bottom2 = bottomFov * far / far2 * near2;\n      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n    }\n\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n\n    this.updateCamera = function (camera) {\n      if (session === null) return;\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n        // Note that the new renderState won't apply until the next frame. See #18320\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far\n        });\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n\n      const parent = camera.parent;\n      const cameras = cameraVR.cameras;\n      updateCamera(cameraVR, parent);\n\n      for (let i = 0; i < cameras.length; i++) {\n        updateCamera(cameras[i], parent);\n      }\n\n      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children\n\n      camera.position.copy(cameraVR.position);\n      camera.quaternion.copy(cameraVR.quaternion);\n      camera.scale.copy(cameraVR.scale);\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrixWorld.copy(cameraVR.matrixWorld);\n      const children = camera.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateMatrixWorld(true);\n      } // update projection matrix for proper view frustum culling\n\n\n      if (cameras.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        // assume single camera setup (AR)\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n    };\n\n    this.getCamera = function () {\n      return cameraVR;\n    };\n\n    this.getFoveation = function () {\n      if (glProjLayer !== null) {\n        return glProjLayer.fixedFoveation;\n      }\n\n      if (glBaseLayer !== null) {\n        return glBaseLayer.fixedFoveation;\n      }\n\n      return undefined;\n    };\n\n    this.setFoveation = function (foveation) {\n      // 0 = no foveation = full resolution\n      // 1 = maximum foveation = the edges render at lower resolution\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = foveation;\n      }\n\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {\n        glBaseLayer.fixedFoveation = foveation;\n      }\n    }; // Animation Loop\n\n\n    let onAnimationFrameCallback = null;\n\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(referenceSpace);\n\n      if (pose !== null) {\n        const views = pose.views;\n\n        if (glBaseLayer !== null) {\n          state.bindXRFramebuffer(glBaseLayer.framebuffer);\n        }\n\n        let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list\n\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n          cameraVRNeedsUpdate = true;\n        }\n\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n          let viewport = null;\n\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            state.bindXRFramebuffer(glFramebuffer);\n\n            if (glSubImage.depthStencilTexture !== undefined) {\n              gl.framebufferTexture2D(36160, 36096, 3553, glSubImage.depthStencilTexture, 0);\n            }\n\n            gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);\n            viewport = glSubImage.viewport;\n          }\n\n          const camera = cameras[i];\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n          if (i === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n      } //\n\n\n      const inputSources = session.inputSources;\n\n      for (let i = 0; i < controllers.length; i++) {\n        const controller = controllers[i];\n        const inputSource = inputSources[i];\n        controller.update(inputSource, frame, referenceSpace);\n      }\n\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n    }\n\n    const animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n\n    this.setAnimationLoop = function (callback) {\n      onAnimationFrameCallback = callback;\n    };\n\n    this.dispose = function () {};\n  }\n\n}\n\nfunction WebGLMaterials(properties) {\n  function refreshFogUniforms(uniforms, fog) {\n    uniforms.fogColor.value.copy(fog.color);\n\n    if (fog.isFog) {\n      uniforms.fogNear.value = fog.near;\n      uniforms.fogFar.value = fog.far;\n    } else if (fog.isFogExp2) {\n      uniforms.fogDensity.value = fog.density;\n    }\n  }\n\n  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {\n    if (material.isMeshBasicMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isMeshLambertMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsLambert(uniforms, material);\n    } else if (material.isMeshToonMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsToon(uniforms, material);\n    } else if (material.isMeshPhongMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsPhong(uniforms, material);\n    } else if (material.isMeshStandardMaterial) {\n      refreshUniformsCommon(uniforms, material);\n\n      if (material.isMeshPhysicalMaterial) {\n        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n      } else {\n        refreshUniformsStandard(uniforms, material);\n      }\n    } else if (material.isMeshMatcapMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsMatcap(uniforms, material);\n    } else if (material.isMeshDepthMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDepth(uniforms, material);\n    } else if (material.isMeshDistanceMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDistance(uniforms, material);\n    } else if (material.isMeshNormalMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsNormal(uniforms, material);\n    } else if (material.isLineBasicMaterial) {\n      refreshUniformsLine(uniforms, material);\n\n      if (material.isLineDashedMaterial) {\n        refreshUniformsDash(uniforms, material);\n      }\n    } else if (material.isPointsMaterial) {\n      refreshUniformsPoints(uniforms, material, pixelRatio, height);\n    } else if (material.isSpriteMaterial) {\n      refreshUniformsSprites(uniforms, material);\n    } else if (material.isShadowMaterial) {\n      uniforms.color.value.copy(material.color);\n      uniforms.opacity.value = material.opacity;\n    } else if (material.isShaderMaterial) {\n      material.uniformsNeedUpdate = false; // #15581\n    }\n  }\n\n  function refreshUniformsCommon(uniforms, material) {\n    uniforms.opacity.value = material.opacity;\n\n    if (material.color) {\n      uniforms.diffuse.value.copy(material.color);\n    }\n\n    if (material.emissive) {\n      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n    }\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.specularMap) {\n      uniforms.specularMap.value = material.specularMap;\n    }\n\n    const envMap = properties.get(material).envMap;\n\n    if (envMap) {\n      uniforms.envMap.value = envMap;\n      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n      uniforms.reflectivity.value = material.reflectivity;\n      uniforms.refractionRatio.value = material.refractionRatio;\n\n      const maxMipLevel = properties.get(envMap).__maxMipLevel;\n\n      if (maxMipLevel !== undefined) {\n        uniforms.maxMipLevel.value = maxMipLevel;\n      }\n    }\n\n    if (material.lightMap) {\n      uniforms.lightMap.value = material.lightMap;\n      uniforms.lightMapIntensity.value = material.lightMapIntensity;\n    }\n\n    if (material.aoMap) {\n      uniforms.aoMap.value = material.aoMap;\n      uniforms.aoMapIntensity.value = material.aoMapIntensity;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. specular map\n    // 3. displacementMap map\n    // 4. normal map\n    // 5. bump map\n    // 6. roughnessMap map\n    // 7. metalnessMap map\n    // 8. alphaMap map\n    // 9. emissiveMap map\n    // 10. clearcoat map\n    // 11. clearcoat normal map\n    // 12. clearcoat roughnessMap map\n    // 13. specular intensity map\n    // 14. specular tint map\n\n\n    let uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.specularMap) {\n      uvScaleMap = material.specularMap;\n    } else if (material.displacementMap) {\n      uvScaleMap = material.displacementMap;\n    } else if (material.normalMap) {\n      uvScaleMap = material.normalMap;\n    } else if (material.bumpMap) {\n      uvScaleMap = material.bumpMap;\n    } else if (material.roughnessMap) {\n      uvScaleMap = material.roughnessMap;\n    } else if (material.metalnessMap) {\n      uvScaleMap = material.metalnessMap;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    } else if (material.emissiveMap) {\n      uvScaleMap = material.emissiveMap;\n    } else if (material.clearcoatMap) {\n      uvScaleMap = material.clearcoatMap;\n    } else if (material.clearcoatNormalMap) {\n      uvScaleMap = material.clearcoatNormalMap;\n    } else if (material.clearcoatRoughnessMap) {\n      uvScaleMap = material.clearcoatRoughnessMap;\n    } else if (material.specularIntensityMap) {\n      uvScaleMap = material.specularIntensityMap;\n    } else if (material.specularTintMap) {\n      uvScaleMap = material.specularTintMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      // backwards compatibility\n      if (uvScaleMap.isWebGLRenderTarget) {\n        uvScaleMap = uvScaleMap.texture;\n      }\n\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    } // uv repeat and offset setting priorities for uv2\n    // 1. ao map\n    // 2. light map\n\n\n    let uv2ScaleMap;\n\n    if (material.aoMap) {\n      uv2ScaleMap = material.aoMap;\n    } else if (material.lightMap) {\n      uv2ScaleMap = material.lightMap;\n    }\n\n    if (uv2ScaleMap !== undefined) {\n      // backwards compatibility\n      if (uv2ScaleMap.isWebGLRenderTarget) {\n        uv2ScaleMap = uv2ScaleMap.texture;\n      }\n\n      if (uv2ScaleMap.matrixAutoUpdate === true) {\n        uv2ScaleMap.updateMatrix();\n      }\n\n      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsLine(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n  }\n\n  function refreshUniformsDash(uniforms, material) {\n    uniforms.dashSize.value = material.dashSize;\n    uniforms.totalSize.value = material.dashSize + material.gapSize;\n    uniforms.scale.value = material.scale;\n  }\n\n  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.size.value = material.size * pixelRatio;\n    uniforms.scale.value = height * 0.5;\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. alpha map\n\n\n    let uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsSprites(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.rotation.value = material.rotation;\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. alpha map\n\n\n    let uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsLambert(uniforms, material) {\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n  }\n\n  function refreshUniformsPhong(uniforms, material) {\n    uniforms.specular.value.copy(material.specular);\n    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsToon(uniforms, material) {\n    if (material.gradientMap) {\n      uniforms.gradientMap.value = material.gradientMap;\n    }\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsStandard(uniforms, material) {\n    uniforms.roughness.value = material.roughness;\n    uniforms.metalness.value = material.metalness;\n\n    if (material.roughnessMap) {\n      uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (material.metalnessMap) {\n      uniforms.metalnessMap.value = material.metalnessMap;\n    }\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n\n    const envMap = properties.get(material).envMap;\n\n    if (envMap) {\n      //uniforms.envMap.value = material.envMap; // part of uniforms common\n      uniforms.envMapIntensity.value = material.envMapIntensity;\n    }\n  }\n\n  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {\n    refreshUniformsStandard(uniforms, material);\n    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n    uniforms.clearcoat.value = material.clearcoat;\n    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n    if (material.sheen) uniforms.sheen.value.copy(material.sheen);\n\n    if (material.clearcoatMap) {\n      uniforms.clearcoatMap.value = material.clearcoatMap;\n    }\n\n    if (material.clearcoatRoughnessMap) {\n      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n    }\n\n    if (material.clearcoatNormalMap) {\n      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n      if (material.side === BackSide) {\n        uniforms.clearcoatNormalScale.value.negate();\n      }\n    }\n\n    uniforms.transmission.value = material.transmission;\n\n    if (material.transmissionMap) {\n      uniforms.transmissionMap.value = material.transmissionMap;\n    }\n\n    if (material.transmission > 0.0) {\n      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);\n    }\n\n    uniforms.thickness.value = material.thickness;\n\n    if (material.thicknessMap) {\n      uniforms.thicknessMap.value = material.thicknessMap;\n    }\n\n    uniforms.attenuationDistance.value = material.attenuationDistance;\n    uniforms.attenuationTint.value.copy(material.attenuationTint);\n    uniforms.specularIntensity.value = material.specularIntensity;\n    uniforms.specularTint.value.copy(material.specularTint);\n\n    if (material.specularIntensityMap) {\n      uniforms.specularIntensityMap.value = material.specularIntensityMap;\n    }\n\n    if (material.specularTintMap) {\n      uniforms.specularTintMap.value = material.specularTintMap;\n    }\n  }\n\n  function refreshUniformsMatcap(uniforms, material) {\n    if (material.matcap) {\n      uniforms.matcap.value = material.matcap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsDepth(uniforms, material) {\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  function refreshUniformsDistance(uniforms, material) {\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n\n    uniforms.referencePosition.value.copy(material.referencePosition);\n    uniforms.nearDistance.value = material.nearDistance;\n    uniforms.farDistance.value = material.farDistance;\n  }\n\n  function refreshUniformsNormal(uniforms, material) {\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n\n  return {\n    refreshFogUniforms: refreshFogUniforms,\n    refreshMaterialUniforms: refreshMaterialUniforms\n  };\n}\n\nfunction createCanvasElement() {\n  const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n  canvas.style.display = 'block';\n  return canvas;\n}\n\nfunction WebGLRenderer(parameters = {}) {\n  const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n        _context = parameters.context !== undefined ? parameters.context : null,\n        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n        _depth = parameters.depth !== undefined ? parameters.depth : true,\n        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n  let currentRenderList = null;\n  let currentRenderState = null; // render() can be called from within a callback triggered by another render.\n  // We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n  const renderListStack = [];\n  const renderStateStack = []; // public properties\n\n  this.domElement = _canvas; // Debug configuration container\n\n  this.debug = {\n    /**\n     * Enables error checking and reporting when shader programs are being compiled\n     * @type {boolean}\n     */\n    checkShaderErrors: true\n  }; // clearing\n\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true; // scene graph\n\n  this.sortObjects = true; // user-defined clipping\n\n  this.clippingPlanes = [];\n  this.localClippingEnabled = false; // physically based shading\n\n  this.gammaFactor = 2.0; // for backwards compatibility\n\n  this.outputEncoding = LinearEncoding; // physical lights\n\n  this.physicallyCorrectLights = false; // tone mapping\n\n  this.toneMapping = NoToneMapping;\n  this.toneMappingExposure = 1.0; // internal properties\n\n  const _this = this;\n\n  let _isContextLost = false; // internal state cache\n\n  let _currentActiveCubeFace = 0;\n  let _currentActiveMipmapLevel = 0;\n  let _currentRenderTarget = null;\n\n  let _currentMaterialId = -1;\n\n  let _currentCamera = null;\n\n  const _currentViewport = new Vector4();\n\n  const _currentScissor = new Vector4();\n\n  let _currentScissorTest = null; //\n\n  let _width = _canvas.width;\n  let _height = _canvas.height;\n  let _pixelRatio = 1;\n  let _opaqueSort = null;\n  let _transparentSort = null;\n\n  const _viewport = new Vector4(0, 0, _width, _height);\n\n  const _scissor = new Vector4(0, 0, _width, _height);\n\n  let _scissorTest = false; //\n\n  const _currentDrawBuffers = []; // frustum\n\n  const _frustum = new Frustum(); // clipping\n\n\n  let _clippingEnabled = false;\n  let _localClippingEnabled = false; // transmission\n\n  let _transmissionRenderTarget = null; // camera matrices cache\n\n  const _projScreenMatrix = new Matrix4();\n\n  const _vector3 = new Vector3();\n\n  const _emptyScene = {\n    background: null,\n    fog: null,\n    environment: null,\n    overrideMaterial: null,\n    isScene: true\n  };\n\n  function getTargetPixelRatio() {\n    return _currentRenderTarget === null ? _pixelRatio : 1;\n  } // initialize\n\n\n  let _gl = _context;\n\n  function getContext(contextNames, contextAttributes) {\n    for (let i = 0; i < contextNames.length; i++) {\n      const contextName = contextNames[i];\n\n      const context = _canvas.getContext(contextName, contextAttributes);\n\n      if (context !== null) return context;\n    }\n\n    return null;\n  }\n\n  try {\n    const contextAttributes = {\n      alpha: _alpha,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer,\n      powerPreference: _powerPreference,\n      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n    }; // event listeners must be registered before WebGL context is created, see #12753\n\n    _canvas.addEventListener('webglcontextlost', onContextLost, false);\n\n    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n\n    if (_gl === null) {\n      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n\n      if (_this.isWebGL1Renderer === true) {\n        contextNames.shift();\n      }\n\n      _gl = getContext(contextNames, contextAttributes);\n\n      if (_gl === null) {\n        if (getContext(contextNames)) {\n          throw new Error('Error creating WebGL context with your selected attributes.');\n        } else {\n          throw new Error('Error creating WebGL context.');\n        }\n      }\n    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\n    if (_gl.getShaderPrecisionFormat === undefined) {\n      _gl.getShaderPrecisionFormat = function () {\n        return {\n          'rangeMin': 1,\n          'rangeMax': 1,\n          'precision': 1\n        };\n      };\n    }\n  } catch (error) {\n    console.error('THREE.WebGLRenderer: ' + error.message);\n    throw error;\n  }\n\n  let extensions, capabilities, state, info;\n  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n  let programCache, materials, renderLists, renderStates, clipping, shadowMap;\n  let background, morphtargets, bufferRenderer, indexedBufferRenderer;\n  let utils, bindingStates;\n\n  function initGLContext() {\n    extensions = new WebGLExtensions(_gl);\n    capabilities = new WebGLCapabilities(_gl, extensions, parameters);\n    extensions.init(capabilities);\n    utils = new WebGLUtils(_gl, extensions, capabilities);\n    state = new WebGLState(_gl, extensions, capabilities);\n    _currentDrawBuffers[0] = 1029;\n    info = new WebGLInfo(_gl);\n    properties = new WebGLProperties();\n    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n    cubemaps = new WebGLCubeMaps(_this);\n    cubeuvmaps = new WebGLCubeUVMaps(_this);\n    attributes = new WebGLAttributes(_gl, capabilities);\n    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n    objects = new WebGLObjects(_gl, geometries, attributes, info);\n    morphtargets = new WebGLMorphtargets(_gl);\n    clipping = new WebGLClipping(properties);\n    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);\n    materials = new WebGLMaterials(properties);\n    renderLists = new WebGLRenderLists(properties);\n    renderStates = new WebGLRenderStates(extensions, capabilities);\n    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);\n    shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n    info.programs = programCache.programs;\n    _this.capabilities = capabilities;\n    _this.extensions = extensions;\n    _this.properties = properties;\n    _this.renderLists = renderLists;\n    _this.shadowMap = shadowMap;\n    _this.state = state;\n    _this.info = info;\n  }\n\n  initGLContext(); // xr\n\n  const xr = new WebXRManager(_this, _gl);\n  this.xr = xr; // API\n\n  this.getContext = function () {\n    return _gl;\n  };\n\n  this.getContextAttributes = function () {\n    return _gl.getContextAttributes();\n  };\n\n  this.forceContextLoss = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.loseContext();\n  };\n\n  this.forceContextRestore = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.restoreContext();\n  };\n\n  this.getPixelRatio = function () {\n    return _pixelRatio;\n  };\n\n  this.setPixelRatio = function (value) {\n    if (value === undefined) return;\n    _pixelRatio = value;\n    this.setSize(_width, _height, false);\n  };\n\n  this.getSize = function (target) {\n    return target.set(_width, _height);\n  };\n\n  this.setSize = function (width, height, updateStyle) {\n    if (xr.isPresenting) {\n      console.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\n      return;\n    }\n\n    _width = width;\n    _height = height;\n    _canvas.width = Math.floor(width * _pixelRatio);\n    _canvas.height = Math.floor(height * _pixelRatio);\n\n    if (updateStyle !== false) {\n      _canvas.style.width = width + 'px';\n      _canvas.style.height = height + 'px';\n    }\n\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getDrawingBufferSize = function (target) {\n    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n  };\n\n  this.setDrawingBufferSize = function (width, height, pixelRatio) {\n    _width = width;\n    _height = height;\n    _pixelRatio = pixelRatio;\n    _canvas.width = Math.floor(width * pixelRatio);\n    _canvas.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getCurrentViewport = function (target) {\n    return target.copy(_currentViewport);\n  };\n\n  this.getViewport = function (target) {\n    return target.copy(_viewport);\n  };\n\n  this.setViewport = function (x, y, width, height) {\n    if (x.isVector4) {\n      _viewport.set(x.x, x.y, x.z, x.w);\n    } else {\n      _viewport.set(x, y, width, height);\n    }\n\n    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n  };\n\n  this.getScissor = function (target) {\n    return target.copy(_scissor);\n  };\n\n  this.setScissor = function (x, y, width, height) {\n    if (x.isVector4) {\n      _scissor.set(x.x, x.y, x.z, x.w);\n    } else {\n      _scissor.set(x, y, width, height);\n    }\n\n    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n  };\n\n  this.getScissorTest = function () {\n    return _scissorTest;\n  };\n\n  this.setScissorTest = function (boolean) {\n    state.setScissorTest(_scissorTest = boolean);\n  };\n\n  this.setOpaqueSort = function (method) {\n    _opaqueSort = method;\n  };\n\n  this.setTransparentSort = function (method) {\n    _transparentSort = method;\n  }; // Clearing\n\n\n  this.getClearColor = function (target) {\n    return target.copy(background.getClearColor());\n  };\n\n  this.setClearColor = function () {\n    background.setClearColor.apply(background, arguments);\n  };\n\n  this.getClearAlpha = function () {\n    return background.getClearAlpha();\n  };\n\n  this.setClearAlpha = function () {\n    background.setClearAlpha.apply(background, arguments);\n  };\n\n  this.clear = function (color, depth, stencil) {\n    let bits = 0;\n    if (color === undefined || color) bits |= 16384;\n    if (depth === undefined || depth) bits |= 256;\n    if (stencil === undefined || stencil) bits |= 1024;\n\n    _gl.clear(bits);\n  };\n\n  this.clearColor = function () {\n    this.clear(true, false, false);\n  };\n\n  this.clearDepth = function () {\n    this.clear(false, true, false);\n  };\n\n  this.clearStencil = function () {\n    this.clear(false, false, true);\n  }; //\n\n\n  this.dispose = function () {\n    _canvas.removeEventListener('webglcontextlost', onContextLost, false);\n\n    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\n\n    renderLists.dispose();\n    renderStates.dispose();\n    properties.dispose();\n    cubemaps.dispose();\n    cubeuvmaps.dispose();\n    objects.dispose();\n    bindingStates.dispose();\n    xr.dispose();\n    xr.removeEventListener('sessionstart', onXRSessionStart);\n    xr.removeEventListener('sessionend', onXRSessionEnd);\n\n    if (_transmissionRenderTarget) {\n      _transmissionRenderTarget.dispose();\n\n      _transmissionRenderTarget = null;\n    }\n\n    animation.stop();\n  }; // Events\n\n\n  function onContextLost(event) {\n    event.preventDefault();\n    console.log('THREE.WebGLRenderer: Context Lost.');\n    _isContextLost = true;\n  }\n\n  function onContextRestore()\n  /* event */\n  {\n    console.log('THREE.WebGLRenderer: Context Restored.');\n    _isContextLost = false;\n    const infoAutoReset = info.autoReset;\n    const shadowMapEnabled = shadowMap.enabled;\n    const shadowMapAutoUpdate = shadowMap.autoUpdate;\n    const shadowMapNeedsUpdate = shadowMap.needsUpdate;\n    const shadowMapType = shadowMap.type;\n    initGLContext();\n    info.autoReset = infoAutoReset;\n    shadowMap.enabled = shadowMapEnabled;\n    shadowMap.autoUpdate = shadowMapAutoUpdate;\n    shadowMap.needsUpdate = shadowMapNeedsUpdate;\n    shadowMap.type = shadowMapType;\n  }\n\n  function onMaterialDispose(event) {\n    const material = event.target;\n    material.removeEventListener('dispose', onMaterialDispose);\n    deallocateMaterial(material);\n  } // Buffer deallocation\n\n\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReferences(material);\n    properties.remove(material);\n  }\n\n  function releaseMaterialProgramReferences(material) {\n    const programs = properties.get(material).programs;\n\n    if (programs !== undefined) {\n      programs.forEach(function (program) {\n        programCache.releaseProgram(program);\n      });\n    }\n  } // Buffer rendering\n\n\n  function renderObjectImmediate(object, program) {\n    object.render(function (object) {\n      _this.renderBufferImmediate(object, program);\n    });\n  }\n\n  this.renderBufferImmediate = function (object, program) {\n    bindingStates.initAttributes();\n    const buffers = properties.get(object);\n    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();\n    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();\n    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();\n    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();\n    const programAttributes = program.getAttributes();\n\n    if (object.hasPositions) {\n      _gl.bindBuffer(34962, buffers.position);\n\n      _gl.bufferData(34962, object.positionArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.position);\n\n      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);\n    }\n\n    if (object.hasNormals) {\n      _gl.bindBuffer(34962, buffers.normal);\n\n      _gl.bufferData(34962, object.normalArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.normal);\n\n      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);\n    }\n\n    if (object.hasUvs) {\n      _gl.bindBuffer(34962, buffers.uv);\n\n      _gl.bufferData(34962, object.uvArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.uv);\n\n      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);\n    }\n\n    if (object.hasColors) {\n      _gl.bindBuffer(34962, buffers.color);\n\n      _gl.bufferData(34962, object.colorArray, 35048);\n\n      bindingStates.enableAttribute(programAttributes.color);\n\n      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);\n    }\n\n    bindingStates.disableUnusedAttributes();\n\n    _gl.drawArrays(4, 0, object.count);\n\n    object.count = 0;\n  };\n\n  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    const program = setProgram(camera, scene, material, object);\n    state.setMaterial(material, frontFaceCW); //\n\n    let index = geometry.index;\n    const position = geometry.attributes.position; //\n\n    if (index === null) {\n      if (position === undefined || position.count === 0) return;\n    } else if (index.count === 0) {\n      return;\n    } //\n\n\n    let rangeFactor = 1;\n\n    if (material.wireframe === true) {\n      index = geometries.getWireframeAttribute(geometry);\n      rangeFactor = 2;\n    }\n\n    if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) {\n      morphtargets.update(object, geometry, material, program);\n    }\n\n    bindingStates.setup(object, material, program, geometry, index);\n    let attribute;\n    let renderer = bufferRenderer;\n\n    if (index !== null) {\n      attribute = attributes.get(index);\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(attribute);\n    } //\n\n\n    const dataCount = index !== null ? index.count : position.count;\n    const rangeStart = geometry.drawRange.start * rangeFactor;\n    const rangeCount = geometry.drawRange.count * rangeFactor;\n    const groupStart = group !== null ? group.start * rangeFactor : 0;\n    const groupCount = group !== null ? group.count * rangeFactor : Infinity;\n    const drawStart = Math.max(rangeStart, groupStart);\n    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n    const drawCount = Math.max(0, drawEnd - drawStart + 1);\n    if (drawCount === 0) return; //\n\n    if (object.isMesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n        renderer.setMode(1);\n      } else {\n        renderer.setMode(4);\n      }\n    } else if (object.isLine) {\n      let lineWidth = material.linewidth;\n      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n      state.setLineWidth(lineWidth * getTargetPixelRatio());\n\n      if (object.isLineSegments) {\n        renderer.setMode(1);\n      } else if (object.isLineLoop) {\n        renderer.setMode(2);\n      } else {\n        renderer.setMode(3);\n      }\n    } else if (object.isPoints) {\n      renderer.setMode(0);\n    } else if (object.isSprite) {\n      renderer.setMode(4);\n    }\n\n    if (object.isInstancedMesh) {\n      renderer.renderInstances(drawStart, drawCount, object.count);\n    } else if (geometry.isInstancedBufferGeometry) {\n      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n      renderer.renderInstances(drawStart, drawCount, instanceCount);\n    } else {\n      renderer.render(drawStart, drawCount);\n    }\n  }; // Compile\n\n\n  this.compile = function (scene, camera) {\n    currentRenderState = renderStates.get(scene);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n    scene.traverseVisible(function (object) {\n      if (object.isLight && object.layers.test(camera.layers)) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      }\n    });\n    currentRenderState.setupLights();\n    scene.traverse(function (object) {\n      const material = object.material;\n\n      if (material) {\n        if (Array.isArray(material)) {\n          for (let i = 0; i < material.length; i++) {\n            const material2 = material[i];\n            getProgram(material2, scene, object);\n          }\n        } else {\n          getProgram(material, scene, object);\n        }\n      }\n    });\n    renderStateStack.pop();\n    currentRenderState = null;\n  }; // Animation Loop\n\n\n  let onAnimationFrameCallback = null;\n\n  function onAnimationFrame(time) {\n    if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n  }\n\n  function onXRSessionStart() {\n    animation.stop();\n  }\n\n  function onXRSessionEnd() {\n    animation.start();\n  }\n\n  const animation = new WebGLAnimation();\n  animation.setAnimationLoop(onAnimationFrame);\n  if (typeof window !== 'undefined') animation.setContext(window);\n\n  this.setAnimationLoop = function (callback) {\n    onAnimationFrameCallback = callback;\n    xr.setAnimationLoop(callback);\n    callback === null ? animation.stop() : animation.start();\n  };\n\n  xr.addEventListener('sessionstart', onXRSessionStart);\n  xr.addEventListener('sessionend', onXRSessionEnd); // Rendering\n\n  this.render = function (scene, camera) {\n    if (camera !== undefined && camera.isCamera !== true) {\n      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n      return;\n    }\n\n    if (_isContextLost === true) return; // update scene graph\n\n    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    if (xr.enabled === true && xr.isPresenting === true) {\n      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n      camera = xr.getCamera(); // use XR camera for rendering\n    } //\n\n\n    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n    currentRenderState = renderStates.get(scene, renderStateStack.length);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n    _frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n    _localClippingEnabled = this.localClippingEnabled;\n    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n    currentRenderList = renderLists.get(scene, renderListStack.length);\n    currentRenderList.init();\n    renderListStack.push(currentRenderList);\n    projectObject(scene, camera, 0, _this.sortObjects);\n    currentRenderList.finish();\n\n    if (_this.sortObjects === true) {\n      currentRenderList.sort(_opaqueSort, _transparentSort);\n    } //\n\n\n    if (_clippingEnabled === true) clipping.beginShadows();\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    shadowMap.render(shadowsArray, scene, camera);\n    currentRenderState.setupLights();\n    currentRenderState.setupLightsView(camera);\n    if (_clippingEnabled === true) clipping.endShadows(); //\n\n    if (this.info.autoReset === true) this.info.reset(); //\n\n    background.render(currentRenderList, scene); // render scene\n\n    const opaqueObjects = currentRenderList.opaque;\n    const transmissiveObjects = currentRenderList.transmissive;\n    const transparentObjects = currentRenderList.transparent;\n    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n    if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);\n    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //\n\n    if (_currentRenderTarget !== null) {\n      // resolve multisample renderbuffers to a single-sample texture if necessary\n      textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering\n\n      textures.updateRenderTargetMipmap(_currentRenderTarget);\n    } //\n\n\n    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n    state.buffers.depth.setTest(true);\n    state.buffers.depth.setMask(true);\n    state.buffers.color.setMask(true);\n    state.setPolygonOffset(false); // _gl.finish();\n\n    bindingStates.resetDefaultState();\n    _currentMaterialId = -1;\n    _currentCamera = null;\n    renderStateStack.pop();\n\n    if (renderStateStack.length > 0) {\n      currentRenderState = renderStateStack[renderStateStack.length - 1];\n    } else {\n      currentRenderState = null;\n    }\n\n    renderListStack.pop();\n\n    if (renderListStack.length > 0) {\n      currentRenderList = renderListStack[renderListStack.length - 1];\n    } else {\n      currentRenderList = null;\n    }\n  };\n\n  function projectObject(object, camera, groupOrder, sortObjects) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n\n          const geometry = objects.update(object);\n          const material = object.material;\n\n          if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      } else if (object.isImmediateRenderObject) {\n        if (sortObjects) {\n          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n        }\n\n        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.isSkinnedMesh) {\n          // update skeleton only once in a frame\n          if (object.skeleton.frame !== info.render.frame) {\n            object.skeleton.update();\n            object.skeleton.frame = info.render.frame;\n          }\n        }\n\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n\n          const geometry = objects.update(object);\n          const material = object.material;\n\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n\n              if (groupMaterial && groupMaterial.visible) {\n                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n              }\n            }\n          } else if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i], camera, groupOrder, sortObjects);\n    }\n  }\n\n  function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {\n    if (_transmissionRenderTarget === null) {\n      const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;\n      const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;\n      _transmissionRenderTarget = new renderTargetType(1024, 1024, {\n        generateMipmaps: true,\n        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,\n        minFilter: LinearMipmapLinearFilter,\n        magFilter: NearestFilter,\n        wrapS: ClampToEdgeWrapping,\n        wrapT: ClampToEdgeWrapping\n      });\n    }\n\n    const currentRenderTarget = _this.getRenderTarget();\n\n    _this.setRenderTarget(_transmissionRenderTarget);\n\n    _this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.\n    // Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\n\n    const currentToneMapping = _this.toneMapping;\n    _this.toneMapping = NoToneMapping;\n    renderObjects(opaqueObjects, scene, camera);\n    _this.toneMapping = currentToneMapping;\n    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);\n    textures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n    _this.setRenderTarget(currentRenderTarget);\n\n    renderObjects(transmissiveObjects, scene, camera);\n  }\n\n  function renderObjects(renderList, scene, camera) {\n    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n    if (camera.isArrayCamera) {\n      const cameras = camera.cameras;\n\n      for (let i = 0, l = cameras.length; i < l; i++) {\n        const camera2 = cameras[i];\n        state.viewport(_currentViewport.copy(camera2.viewport));\n        currentRenderState.setupLightsView(camera2);\n\n        for (let j = 0, jl = renderList.length; j < jl; j++) {\n          const renderItem = renderList[j];\n          const object = renderItem.object;\n          const geometry = renderItem.geometry;\n          const material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n          const group = renderItem.group;\n\n          if (object.layers.test(camera2.layers)) {\n            renderObject(object, scene, camera2, geometry, material, group);\n          }\n        }\n      }\n    } else {\n      for (let j = 0, jl = renderList.length; j < jl; j++) {\n        const renderItem = renderList[j];\n        const object = renderItem.object;\n        const geometry = renderItem.geometry;\n        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n        const group = renderItem.group;\n        renderObject(object, scene, camera, geometry, material, group);\n      }\n    }\n  }\n\n  function renderObject(object, scene, camera, geometry, material, group) {\n    object.onBeforeRender(_this, scene, camera, geometry, material, group);\n    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n    if (object.isImmediateRenderObject) {\n      const program = setProgram(camera, scene, material, object);\n      state.setMaterial(material);\n      bindingStates.reset();\n      renderObjectImmediate(object, program);\n    } else {\n      if (material.transparent === true && material.side === DoubleSide) {\n        material.side = BackSide;\n        material.needsUpdate = true;\n\n        _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\n        material.side = FrontSide;\n        material.needsUpdate = true;\n\n        _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\n        material.side = DoubleSide;\n      } else {\n        _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n      }\n    }\n\n    object.onAfterRender(_this, scene, camera, geometry, material, group);\n  }\n\n  function getProgram(material, scene, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    const lightsStateVersion = lights.state.version;\n    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n    const programCacheKey = programCache.getProgramCacheKey(parameters);\n    let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n    materialProperties.fog = scene.fog;\n    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);\n\n    if (programs === undefined) {\n      // new material\n      material.addEventListener('dispose', onMaterialDispose);\n      programs = new Map();\n      materialProperties.programs = programs;\n    }\n\n    let program = programs.get(programCacheKey);\n\n    if (program !== undefined) {\n      // early out if program and light state is identical\n      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n        updateCommonMaterialProperties(material, parameters);\n        return program;\n      }\n    } else {\n      parameters.uniforms = programCache.getUniforms(material);\n      material.onBuild(parameters, _this);\n      material.onBeforeCompile(parameters, _this);\n      program = programCache.acquireProgram(parameters, programCacheKey);\n      programs.set(programCacheKey, program);\n      materialProperties.uniforms = parameters.uniforms;\n    }\n\n    const uniforms = materialProperties.uniforms;\n\n    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n      uniforms.clippingPlanes = clipping.uniform;\n    }\n\n    updateCommonMaterialProperties(material, parameters); // store the light setup it was created for\n\n    materialProperties.needsLights = materialNeedsLights(material);\n    materialProperties.lightsStateVersion = lightsStateVersion;\n\n    if (materialProperties.needsLights) {\n      // wire up the material to this renderer's lighting state\n      uniforms.ambientLightColor.value = lights.state.ambient;\n      uniforms.lightProbe.value = lights.state.probe;\n      uniforms.directionalLights.value = lights.state.directional;\n      uniforms.directionalLightShadows.value = lights.state.directionalShadow;\n      uniforms.spotLights.value = lights.state.spot;\n      uniforms.spotLightShadows.value = lights.state.spotShadow;\n      uniforms.rectAreaLights.value = lights.state.rectArea;\n      uniforms.ltc_1.value = lights.state.rectAreaLTC1;\n      uniforms.ltc_2.value = lights.state.rectAreaLTC2;\n      uniforms.pointLights.value = lights.state.point;\n      uniforms.pointLightShadows.value = lights.state.pointShadow;\n      uniforms.hemisphereLights.value = lights.state.hemi;\n      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n      uniforms.spotShadowMap.value = lights.state.spotShadowMap;\n      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n      uniforms.pointShadowMap.value = lights.state.pointShadowMap;\n      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms\n    }\n\n    const progUniforms = program.getUniforms();\n    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n    materialProperties.currentProgram = program;\n    materialProperties.uniformsList = uniformsList;\n    return program;\n  }\n\n  function updateCommonMaterialProperties(material, parameters) {\n    const materialProperties = properties.get(material);\n    materialProperties.outputEncoding = parameters.outputEncoding;\n    materialProperties.instancing = parameters.instancing;\n    materialProperties.skinning = parameters.skinning;\n    materialProperties.morphTargets = parameters.morphTargets;\n    materialProperties.morphNormals = parameters.morphNormals;\n    materialProperties.numClippingPlanes = parameters.numClippingPlanes;\n    materialProperties.numIntersection = parameters.numClipIntersection;\n    materialProperties.vertexAlphas = parameters.vertexAlphas;\n    materialProperties.vertexTangents = parameters.vertexTangents;\n  }\n\n  function setProgram(camera, scene, material, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    textures.resetTextureUnits();\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    const vertexAlphas = material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n    const vertexTangents = !!object.geometry && !!object.geometry.attributes.tangent;\n    const morphTargets = !!object.geometry && !!object.geometry.morphAttributes.position;\n    const morphNormals = !!object.geometry && !!object.geometry.morphAttributes.normal;\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n\n    if (_clippingEnabled === true) {\n      if (_localClippingEnabled === true || camera !== _currentCamera) {\n        const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup\n        // object instead of the material, once it becomes feasible\n        // (#8465, #8379)\n\n        clipping.setState(material, camera, useCache);\n      }\n    } //\n\n\n    let needsProgramChange = false;\n\n    if (material.version === materialProperties.__version) {\n      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n        needsProgramChange = true;\n      } else if (materialProperties.outputEncoding !== encoding) {\n        needsProgramChange = true;\n      } else if (object.isInstancedMesh && materialProperties.instancing === false) {\n        needsProgramChange = true;\n      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n        needsProgramChange = true;\n      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n        needsProgramChange = true;\n      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n        needsProgramChange = true;\n      } else if (materialProperties.envMap !== envMap) {\n        needsProgramChange = true;\n      } else if (material.fog && materialProperties.fog !== fog) {\n        needsProgramChange = true;\n      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexTangents !== vertexTangents) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphTargets !== morphTargets) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphNormals !== morphNormals) {\n        needsProgramChange = true;\n      }\n    } else {\n      needsProgramChange = true;\n      materialProperties.__version = material.version;\n    } //\n\n\n    let program = materialProperties.currentProgram;\n\n    if (needsProgramChange === true) {\n      program = getProgram(material, scene, object);\n    }\n\n    let refreshProgram = false;\n    let refreshMaterial = false;\n    let refreshLights = false;\n    const p_uniforms = program.getUniforms(),\n          m_uniforms = materialProperties.uniforms;\n\n    if (state.useProgram(program.program)) {\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n\n    if (material.id !== _currentMaterialId) {\n      _currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n\n    if (refreshProgram || _currentCamera !== camera) {\n      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n\n      if (capabilities.logarithmicDepthBuffer) {\n        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n      }\n\n      if (_currentCamera !== camera) {\n        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update\n        // now, in case this material supports lights - or later, when\n        // the next material that does gets activated:\n\n        refreshMaterial = true; // set to true on material change\n\n        refreshLights = true; // remains set until update done\n      } // load material specific uniforms\n      // (shader material also gets them for the sake of genericity)\n\n\n      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n        const uCamPos = p_uniforms.map.cameraPosition;\n\n        if (uCamPos !== undefined) {\n          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n        }\n      }\n\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);\n      }\n\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n      }\n    } // skinning uniforms must be set even if material didn't change\n    // auto-setting of texture unit for bone texture must go before other textures\n    // otherwise textures used for skinning can take over texture units reserved for other material textures\n\n\n    if (object.isSkinnedMesh) {\n      p_uniforms.setOptional(_gl, object, 'bindMatrix');\n      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n      const skeleton = object.skeleton;\n\n      if (skeleton) {\n        if (capabilities.floatVertexTextures) {\n          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\n          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n        } else {\n          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\n        }\n      }\n    }\n\n    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n      materialProperties.receiveShadow = object.receiveShadow;\n      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n    }\n\n    if (refreshMaterial) {\n      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\n\n      if (materialProperties.needsLights) {\n        // the current material requires lighting info\n        // note: all lighting uniforms are always set correctly\n        // they simply reference the renderer's state for their\n        // values\n        //\n        // use the current material's .needsUpdate flags to set\n        // the GL state when required\n        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n      } // refresh uniforms common to several materials\n\n\n      if (fog && material.fog) {\n        materials.refreshFogUniforms(m_uniforms, fog);\n      }\n\n      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n    }\n\n    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n      material.uniformsNeedUpdate = false;\n    }\n\n    if (material.isSpriteMaterial) {\n      p_uniforms.setValue(_gl, 'center', object.center);\n    } // common matrices\n\n\n    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n    return program;\n  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.lightProbe.needsUpdate = value;\n    uniforms.directionalLights.needsUpdate = value;\n    uniforms.directionalLightShadows.needsUpdate = value;\n    uniforms.pointLights.needsUpdate = value;\n    uniforms.pointLightShadows.needsUpdate = value;\n    uniforms.spotLights.needsUpdate = value;\n    uniforms.spotLightShadows.needsUpdate = value;\n    uniforms.rectAreaLights.needsUpdate = value;\n    uniforms.hemisphereLights.needsUpdate = value;\n  }\n\n  function materialNeedsLights(material) {\n    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n  }\n\n  this.getActiveCubeFace = function () {\n    return _currentActiveCubeFace;\n  };\n\n  this.getActiveMipmapLevel = function () {\n    return _currentActiveMipmapLevel;\n  };\n\n  this.getRenderTarget = function () {\n    return _currentRenderTarget;\n  };\n\n  this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n    _currentRenderTarget = renderTarget;\n    _currentActiveCubeFace = activeCubeFace;\n    _currentActiveMipmapLevel = activeMipmapLevel;\n\n    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {\n      textures.setupRenderTarget(renderTarget);\n    }\n\n    let framebuffer = null;\n    let isCube = false;\n    let isRenderTarget3D = false;\n\n    if (renderTarget) {\n      const texture = renderTarget.texture;\n\n      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {\n        isRenderTarget3D = true;\n      }\n\n      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n      if (renderTarget.isWebGLCubeRenderTarget) {\n        framebuffer = __webglFramebuffer[activeCubeFace];\n        isCube = true;\n      } else if (renderTarget.isWebGLMultisampleRenderTarget) {\n        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n      } else {\n        framebuffer = __webglFramebuffer;\n      }\n\n      _currentViewport.copy(renderTarget.viewport);\n\n      _currentScissor.copy(renderTarget.scissor);\n\n      _currentScissorTest = renderTarget.scissorTest;\n    } else {\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n\n      _currentScissorTest = _scissorTest;\n    }\n\n    const framebufferBound = state.bindFramebuffer(36160, framebuffer);\n\n    if (framebufferBound && capabilities.drawBuffers) {\n      let needsUpdate = false;\n\n      if (renderTarget) {\n        if (renderTarget.isWebGLMultipleRenderTargets) {\n          const textures = renderTarget.texture;\n\n          if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== 36064) {\n            for (let i = 0, il = textures.length; i < il; i++) {\n              _currentDrawBuffers[i] = 36064 + i;\n            }\n\n            _currentDrawBuffers.length = textures.length;\n            needsUpdate = true;\n          }\n        } else {\n          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {\n            _currentDrawBuffers[0] = 36064;\n            _currentDrawBuffers.length = 1;\n            needsUpdate = true;\n          }\n        }\n      } else {\n        if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {\n          _currentDrawBuffers[0] = 1029;\n          _currentDrawBuffers.length = 1;\n          needsUpdate = true;\n        }\n      }\n\n      if (needsUpdate) {\n        if (capabilities.isWebGL2) {\n          _gl.drawBuffers(_currentDrawBuffers);\n        } else {\n          extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);\n        }\n      }\n    }\n\n    state.viewport(_currentViewport);\n    state.scissor(_currentScissor);\n    state.setScissorTest(_currentScissorTest);\n\n    if (isCube) {\n      const textureProperties = properties.get(renderTarget.texture);\n\n      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n    } else if (isRenderTarget3D) {\n      const textureProperties = properties.get(renderTarget.texture);\n      const layer = activeCubeFace || 0;\n\n      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n    }\n  };\n\n  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n      return;\n    }\n\n    let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n      framebuffer = framebuffer[activeCubeFaceIndex];\n    }\n\n    if (framebuffer) {\n      state.bindFramebuffer(36160, framebuffer);\n\n      try {\n        const texture = renderTarget.texture;\n        const textureFormat = texture.format;\n        const textureType = texture.type;\n\n        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\n          return;\n        }\n\n        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));\n\n        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)\n        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox\n        !halfFloatSupportedByExt) {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\n          return;\n        }\n\n        if (_gl.checkFramebufferStatus(36160) === 36053) {\n          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n          }\n        } else {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n        }\n      } finally {\n        // restore framebuffer of current render target if necessary\n        const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n        state.bindFramebuffer(36160, framebuffer);\n      }\n    }\n  };\n\n  this.copyFramebufferToTexture = function (position, texture, level = 0) {\n    const levelScale = Math.pow(2, -level);\n    const width = Math.floor(texture.image.width * levelScale);\n    const height = Math.floor(texture.image.height * levelScale);\n    let glFormat = utils.convert(texture.format);\n\n    if (capabilities.isWebGL2) {\n      // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100\n      // Not needed in Chrome 93+\n      if (glFormat === 6407) glFormat = 32849;\n      if (glFormat === 6408) glFormat = 32856;\n    }\n\n    textures.setTexture2D(texture, 0);\n\n    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);\n\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {\n    const width = srcTexture.image.width;\n    const height = srcTexture.image.height;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n\n    _gl.pixelStorei(37440, dstTexture.flipY);\n\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n\n    if (srcTexture.isDataTexture) {\n      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n      } else {\n        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);\n      }\n    } // Generate mipmaps only when copying level 0\n\n\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {\n    if (_this.isWebGL1Renderer) {\n      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');\n      return;\n    }\n\n    const width = sourceBox.max.x - sourceBox.min.x + 1;\n    const height = sourceBox.max.y - sourceBox.min.y + 1;\n    const depth = sourceBox.max.z - sourceBox.min.z + 1;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    let glTarget;\n\n    if (dstTexture.isDataTexture3D) {\n      textures.setTexture3D(dstTexture, 0);\n      glTarget = 32879;\n    } else if (dstTexture.isDataTexture2DArray) {\n      textures.setTexture2DArray(dstTexture, 0);\n      glTarget = 35866;\n    } else {\n      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');\n      return;\n    }\n\n    _gl.pixelStorei(37440, dstTexture.flipY);\n\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n\n    const unpackRowLen = _gl.getParameter(3314);\n\n    const unpackImageHeight = _gl.getParameter(32878);\n\n    const unpackSkipPixels = _gl.getParameter(3316);\n\n    const unpackSkipRows = _gl.getParameter(3315);\n\n    const unpackSkipImages = _gl.getParameter(32877);\n\n    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;\n\n    _gl.pixelStorei(3314, image.width);\n\n    _gl.pixelStorei(32878, image.height);\n\n    _gl.pixelStorei(3316, sourceBox.min.x);\n\n    _gl.pixelStorei(3315, sourceBox.min.y);\n\n    _gl.pixelStorei(32877, sourceBox.min.z);\n\n    if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {\n      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');\n\n        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);\n      } else {\n        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);\n      }\n    }\n\n    _gl.pixelStorei(3314, unpackRowLen);\n\n    _gl.pixelStorei(32878, unpackImageHeight);\n\n    _gl.pixelStorei(3316, unpackSkipPixels);\n\n    _gl.pixelStorei(3315, unpackSkipRows);\n\n    _gl.pixelStorei(32877, unpackSkipImages); // Generate mipmaps only when copying level 0\n\n\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n    state.unbindTexture();\n  };\n\n  this.initTexture = function (texture) {\n    textures.setTexture2D(texture, 0);\n    state.unbindTexture();\n  };\n\n  this.resetState = function () {\n    _currentActiveCubeFace = 0;\n    _currentActiveMipmapLevel = 0;\n    _currentRenderTarget = null;\n    state.reset();\n    bindingStates.reset();\n  };\n\n  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n      detail: this\n    })); // eslint-disable-line no-undef\n\n  }\n}\n\nclass WebGL1Renderer extends WebGLRenderer {}\n\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\nclass Scene extends Object3D {\n  constructor() {\n    super();\n    this.type = 'Scene';\n    this.background = null;\n    this.environment = null;\n    this.fog = null;\n    this.overrideMaterial = null;\n    this.autoUpdate = true; // checked by the renderer\n\n    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n        detail: this\n      })); // eslint-disable-line no-undef\n\n    }\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.background !== null) this.background = source.background.clone();\n    if (source.environment !== null) this.environment = source.environment.clone();\n    if (source.fog !== null) this.fog = source.fog.clone();\n    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n    this.autoUpdate = source.autoUpdate;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.fog !== null) data.object.fog = this.fog.toJSON();\n    return data;\n  }\n\n}\n\nScene.prototype.isScene = true;\n\nclass InterleavedBuffer {\n  constructor(array, stride) {\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== undefined ? array.length / stride : 0;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {\n      offset: 0,\n      count: -1\n    };\n    this.version = 0;\n    this.uuid = generateUUID();\n  }\n\n  onUploadCallback() {}\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n\n  copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.count = source.count;\n    this.stride = source.stride;\n    this.usage = source.usage;\n    return this;\n  }\n\n  copyAt(index1, attribute, index2) {\n    index1 *= this.stride;\n    index2 *= attribute.stride;\n\n    for (let i = 0, l = this.stride; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  }\n\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n\n  clone(data) {\n    if (data.arrayBuffers === undefined) {\n      data.arrayBuffers = {};\n    }\n\n    if (this.array.buffer._uuid === undefined) {\n      this.array.buffer._uuid = generateUUID();\n    }\n\n    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n    }\n\n    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n    const ib = new this.constructor(array, this.stride);\n    ib.setUsage(this.usage);\n    return ib;\n  }\n\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n\n  toJSON(data) {\n    if (data.arrayBuffers === undefined) {\n      data.arrayBuffers = {};\n    } // generate UUID for array buffer if necessary\n\n\n    if (this.array.buffer._uuid === undefined) {\n      this.array.buffer._uuid = generateUUID();\n    }\n\n    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n    } //\n\n\n    return {\n      uuid: this.uuid,\n      buffer: this.array.buffer._uuid,\n      type: this.array.constructor.name,\n      stride: this.stride\n    };\n  }\n\n}\n\nInterleavedBuffer.prototype.isInterleavedBuffer = true;\n\nconst _vector$6 = /*@__PURE__*/new Vector3();\n\nclass InterleavedBufferAttribute {\n  constructor(interleavedBuffer, itemSize, offset, normalized = false) {\n    this.name = '';\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n    this.normalized = normalized === true;\n  }\n\n  get count() {\n    return this.data.count;\n  }\n\n  get array() {\n    return this.data.array;\n  }\n\n  set needsUpdate(value) {\n    this.data.needsUpdate = value;\n  }\n\n  applyMatrix4(m) {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n\n      _vector$6.applyMatrix4(m);\n\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n\n      _vector$6.applyNormalMatrix(m);\n\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n\n    return this;\n  }\n\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n\n      _vector$6.transformDirection(m);\n\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n\n    return this;\n  }\n\n  setX(index, x) {\n    this.data.array[index * this.data.stride + this.offset] = x;\n    return this;\n  }\n\n  setY(index, y) {\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n    return this;\n  }\n\n  setZ(index, z) {\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n    return this;\n  }\n\n  setW(index, w) {\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n    return this;\n  }\n\n  getX(index) {\n    return this.data.array[index * this.data.stride + this.offset];\n  }\n\n  getY(index) {\n    return this.data.array[index * this.data.stride + this.offset + 1];\n  }\n\n  getZ(index) {\n    return this.data.array[index * this.data.stride + this.offset + 2];\n  }\n\n  getW(index) {\n    return this.data.array[index * this.data.stride + this.offset + 3];\n  }\n\n  setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    return this;\n  }\n\n  setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    return this;\n  }\n\n  setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n    return this;\n  }\n\n  clone(data) {\n    if (data === undefined) {\n      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');\n      const array = [];\n\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n\n      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n    } else {\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n\n      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n    }\n  }\n\n  toJSON(data) {\n    if (data === undefined) {\n      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');\n      const array = [];\n\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      } // deinterleave data and save it as an ordinary buffer attribute for now\n\n\n      return {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: array,\n        normalized: this.normalized\n      };\n    } else {\n      // save as true interlaved attribtue\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n\n      return {\n        isInterleavedBufferAttribute: true,\n        itemSize: this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n        normalized: this.normalized\n      };\n    }\n  }\n\n}\n\nInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *  rotation: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nclass SpriteMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'SpriteMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.alphaMap = null;\n    this.rotation = 0;\n    this.sizeAttenuation = true;\n    this.transparent = true;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.rotation = source.rotation;\n    this.sizeAttenuation = source.sizeAttenuation;\n    return this;\n  }\n\n}\n\nSpriteMaterial.prototype.isSpriteMaterial = true;\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/new Vector3();\n\nconst _worldScale = /*@__PURE__*/new Vector3();\n\nconst _mvPosition = /*@__PURE__*/new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/new Vector2();\n\nconst _rotatedPosition = /*@__PURE__*/new Vector2();\n\nconst _viewWorldMatrix = /*@__PURE__*/new Matrix4();\n\nconst _vA = /*@__PURE__*/new Vector3();\n\nconst _vB = /*@__PURE__*/new Vector3();\n\nconst _vC = /*@__PURE__*/new Vector3();\n\nconst _uvA = /*@__PURE__*/new Vector2();\n\nconst _uvB = /*@__PURE__*/new Vector2();\n\nconst _uvC = /*@__PURE__*/new Vector2();\n\nclass Sprite extends Object3D {\n  constructor(material) {\n    super();\n    this.type = 'Sprite';\n\n    if (_geometry === undefined) {\n      _geometry = new BufferGeometry();\n      const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\n      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n\n    this.geometry = _geometry;\n    this.material = material !== undefined ? material : new SpriteMaterial();\n    this.center = new Vector2(0.5, 0.5);\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n    }\n\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n\n    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n\n    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n\n    const rotation = this.material.rotation;\n    let sin, cos;\n\n    if (rotation !== 0) {\n      cos = Math.cos(rotation);\n      sin = Math.sin(rotation);\n    }\n\n    const center = this.center;\n    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n    _uvA.set(0, 0);\n\n    _uvB.set(1, 0);\n\n    _uvC.set(1, 1); // check first triangle\n\n\n    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n    if (intersect === null) {\n      // check second triangle\n      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n      _uvB.set(0, 1);\n\n      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n\n      if (intersect === null) {\n        return;\n      }\n    }\n\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n      face: null,\n      object: this\n    });\n  }\n\n  copy(source) {\n    super.copy(source);\n    if (source.center !== undefined) this.center.copy(source.center);\n    this.material = source.material;\n    return this;\n  }\n\n}\n\nSprite.prototype.isSprite = true;\n\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  // compute position in camera space\n  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero\n\n\n  if (sin !== undefined) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y; // transform to world space\n\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\n\nconst _basePosition = /*@__PURE__*/new Vector3();\n\nconst _skinIndex = /*@__PURE__*/new Vector4();\n\nconst _skinWeight = /*@__PURE__*/new Vector4();\n\nconst _vector$5 = /*@__PURE__*/new Vector3();\n\nconst _matrix = /*@__PURE__*/new Matrix4();\n\nclass SkinnedMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = 'SkinnedMesh';\n    this.bindMode = 'attached';\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n    this.skeleton = source.skeleton;\n    return this;\n  }\n\n  bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n\n    if (bindMatrix === undefined) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.copy(bindMatrix).invert();\n  }\n\n  pose() {\n    this.skeleton.pose();\n  }\n\n  normalizeSkinWeights() {\n    const vector = new Vector4();\n    const skinWeight = this.geometry.attributes.skinWeight;\n\n    for (let i = 0, l = skinWeight.count; i < l; i++) {\n      vector.x = skinWeight.getX(i);\n      vector.y = skinWeight.getY(i);\n      vector.z = skinWeight.getZ(i);\n      vector.w = skinWeight.getW(i);\n      const scale = 1.0 / vector.manhattanLength();\n\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0); // do something reasonable\n      }\n\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.bindMode === 'attached') {\n      this.bindMatrixInverse.copy(this.matrixWorld).invert();\n    } else if (this.bindMode === 'detached') {\n      this.bindMatrixInverse.copy(this.bindMatrix).invert();\n    } else {\n      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n    }\n  }\n\n  boneTransform(index, target) {\n    const skeleton = this.skeleton;\n    const geometry = this.geometry;\n\n    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);\n\n    target.set(0, 0, 0);\n\n    for (let i = 0; i < 4; i++) {\n      const weight = _skinWeight.getComponent(i);\n\n      if (weight !== 0) {\n        const boneIndex = _skinIndex.getComponent(i);\n\n        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);\n      }\n    }\n\n    return target.applyMatrix4(this.bindMatrixInverse);\n  }\n\n}\n\nSkinnedMesh.prototype.isSkinnedMesh = true;\n\nclass Bone extends Object3D {\n  constructor() {\n    super();\n    this.type = 'Bone';\n  }\n\n}\n\nBone.prototype.isBone = true;\n\nclass DataTexture extends Texture$1 {\n  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    this.image = {\n      data: data,\n      width: width,\n      height: height\n    };\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n  }\n\n}\n\nDataTexture.prototype.isDataTexture = true;\n\nconst _offsetMatrix = /*@__PURE__*/new Matrix4();\n\nconst _identityMatrix = /*@__PURE__*/new Matrix4();\n\nclass Skeleton {\n  constructor(bones = [], boneInverses = []) {\n    this.uuid = generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n    this.frame = -1;\n    this.init();\n  }\n\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      // handle special case\n      if (bones.length !== boneInverses.length) {\n        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n        this.boneInverses = [];\n\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n\n  calculateInverses() {\n    this.boneInverses.length = 0;\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n\n      this.boneInverses.push(inverse);\n    }\n  }\n\n  pose() {\n    // recover the bind-time world matrices\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    } // compute the local matrices, positions, rotations and scales\n\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture; // flatten bone matrices to array\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n\n  computeBoneTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n    size = ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n    boneMatrices.set(this.boneMatrices); // copy current values\n\n    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    this.boneTextureSize = size;\n    return this;\n  }\n\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n\n    return undefined;\n  }\n\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n\n      if (bone === undefined) {\n        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n        bone = new Bone();\n      }\n\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n\n    this.init();\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Skeleton',\n        generator: 'Skeleton.toJSON'\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n\n    return data;\n  }\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\nconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh$1 = /*@__PURE__*/new Mesh();\n\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.count = count;\n    this.frustumCulled = false;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    return this;\n  }\n\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n\n  raycast(raycaster, intersects) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh$1.geometry = this.geometry;\n    _mesh$1.material = this.material;\n    if (_mesh$1.material === undefined) return;\n\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n      _mesh$1.matrixWorld = _instanceWorldMatrix;\n\n      _mesh$1.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n\n      _instanceIntersects.length = 0;\n    }\n  }\n\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new BufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);\n    }\n\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n\n  updateMorphTargets() {}\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nInstancedMesh.prototype.isInstancedMesh = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nclass LineBasicMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'LineBasicMaterial';\n    this.color = new Color(0xffffff);\n    this.linewidth = 1;\n    this.linecap = 'round';\n    this.linejoin = 'round';\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n    return this;\n  }\n\n}\n\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\nconst _start$1 = /*@__PURE__*/new Vector3();\n\nconst _end$1 = /*@__PURE__*/new Vector3();\n\nconst _inverseMatrix$1 = /*@__PURE__*/new Matrix4();\n\nconst _ray$1 = /*@__PURE__*/new Ray();\n\nconst _sphere$1 = /*@__PURE__*/new Sphere();\n\nclass Line extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n    super();\n    this.type = 'Line';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [0];\n\n        for (let i = 1, l = positionAttribute.count; i < l; i++) {\n          _start$1.fromBufferAttribute(positionAttribute, i - 1);\n\n          _end$1.fromBufferAttribute(positionAttribute, i);\n\n          lineDistances[i] = lineDistances[i - 1];\n          lineDistances[i] += _start$1.distanceTo(_end$1);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere$1.copy(geometry.boundingSphere);\n\n    _sphere$1.applyMatrix4(matrixWorld);\n\n    _sphere$1.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //\n\n    _inverseMatrix$1.copy(matrixWorld).invert();\n\n    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const vStart = new Vector3();\n    const vEnd = new Vector3();\n    const interSegment = new Vector3();\n    const interRay = new Vector3();\n    const step = this.isLineSegments ? 2 : 1;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end - 1; i < l; i += step) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          vStart.fromBufferAttribute(positionAttribute, a);\n          vEnd.fromBufferAttribute(positionAttribute, b);\n\n          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end - 1; i < l; i += step) {\n          vStart.fromBufferAttribute(positionAttribute, i);\n          vEnd.fromBufferAttribute(positionAttribute, i + 1);\n\n          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n}\n\nLine.prototype.isLine = true;\n\nconst _start = /*@__PURE__*/new Vector3();\n\nconst _end = /*@__PURE__*/new Vector3();\n\nclass LineSegments extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = 'LineSegments';\n  }\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [];\n\n        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n          _start.fromBufferAttribute(positionAttribute, i);\n\n          _end.fromBufferAttribute(positionAttribute, i + 1);\n\n          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n\n    return this;\n  }\n\n}\n\nLineSegments.prototype.isLineSegments = true;\n\nclass LineLoop extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = 'LineLoop';\n  }\n\n}\n\nLineLoop.prototype.isLineLoop = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n * }\n */\n\nclass PointsMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'PointsMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.alphaMap = null;\n    this.size = 1;\n    this.sizeAttenuation = true;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.size = source.size;\n    this.sizeAttenuation = source.sizeAttenuation;\n    return this;\n  }\n\n}\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nconst _ray = /*@__PURE__*/new Ray();\n\nconst _sphere = /*@__PURE__*/new Sphere();\n\nconst _position$2 = /*@__PURE__*/new Vector3();\n\nclass Points extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n    super();\n    this.type = 'Points';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i = start, il = end; i < il; i++) {\n          const a = index.getX(i);\n\n          _position$2.fromBufferAttribute(positionAttribute, a);\n\n          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end; i < l; i++) {\n          _position$2.fromBufferAttribute(positionAttribute, i);\n\n          testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      }\n    } else {\n      console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n}\n\nPoints.prototype.isPoints = true;\n\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  const rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n\n    _ray.closestPointToPoint(point, intersectPoint);\n\n    intersectPoint.applyMatrix4(matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object\n    });\n  }\n}\n\nclass VideoTexture extends Texture$1 {\n  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.format = format !== undefined ? format : RGBFormat;\n    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n    this.generateMipmaps = false;\n    const scope = this;\n\n    function updateVideo() {\n      scope.needsUpdate = true;\n      video.requestVideoFrameCallback(updateVideo);\n    }\n\n    if ('requestVideoFrameCallback' in video) {\n      video.requestVideoFrameCallback(updateVideo);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.image).copy(this);\n  }\n\n  update() {\n    const video = this.image;\n    const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);\n\n    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n      this.needsUpdate = true;\n    }\n  }\n\n}\n\nVideoTexture.prototype.isVideoTexture = true;\n\nclass CompressedTexture extends Texture$1 {\n  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    this.image = {\n      width: width,\n      height: height\n    };\n    this.mipmaps = mipmaps; // no flipping for cube textures\n    // (also flipping doesn't work for compressed textures )\n\n    this.flipY = false; // can't generate mipmaps for compressed textures\n    // mips must be embedded in DDS files\n\n    this.generateMipmaps = false;\n  }\n\n}\n\nCompressedTexture.prototype.isCompressedTexture = true;\n\nclass CanvasTexture extends Texture$1 {\n  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.needsUpdate = true;\n  }\n\n}\n\nCanvasTexture.prototype.isCanvasTexture = true;\n\nclass DepthTexture extends Texture$1 {\n  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\n    format = format !== undefined ? format : DepthFormat;\n\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\n      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\n    }\n\n    if (type === undefined && format === DepthFormat) type = UnsignedShortType;\n    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.image = {\n      width: width,\n      height: height\n    };\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n    this.flipY = false;\n    this.generateMipmaps = false;\n  }\n\n}\n\nDepthTexture.prototype.isDepthTexture = true;\nnew Vector3();\nnew Vector3();\nnew Vector3();\nnew Triangle();\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n  constructor() {\n    this.type = 'Curve';\n    this.arcLengthDivisions = 200;\n  } // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n\n\n  getPoint()\n  /* t, optionalTarget */\n  {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  } // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n\n  getPointAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  } // Get sequence of points using getPoint( t )\n\n\n  getPoints(divisions = 5) {\n    const points = [];\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n\n    return points;\n  } // Get sequence of points using getPointAt( u )\n\n\n  getSpacedPoints(divisions = 5) {\n    const points = [];\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n\n    return points;\n  } // Get total curve arc length\n\n\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  } // Get list of cumulative segment lengths\n\n\n  getLengths(divisions = this.arcLengthDivisions) {\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n    const cache = [];\n    let current,\n        last = this.getPoint(0);\n    let sum = 0;\n    cache.push(0);\n\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  }\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n    let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    } // binary search for the index with largest value smaller than target u distance\n\n\n    let low = 0,\n        high = il - 1,\n        comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break; // DONE\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n    const t = (i + segmentFraction) / (il - 1);\n    return t;\n  } // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n\n\n  getTangent(t, optionalTarget) {\n    const delta = 0.0001;\n    let t1 = t - delta;\n    let t2 = t + delta; // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t2);\n    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n\n  getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  }\n\n  computeFrenetFrames(segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n    const normal = new Vector3();\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n    const vec = new Vector3();\n    const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n      tangents[i].normalize();\n    } // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        const theta = Math.acos(clamp$1(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n    if (closed === true) {\n      let theta = Math.acos(clamp$1(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n\n      for (let i = 1; i <= segments; i++) {\n        // twist a little...\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals\n    };\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Curve',\n        generator: 'Curve.toJSON'\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n\n}\n\nclass EllipseCurve extends Curve {\n  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n    super();\n    this.type = 'EllipseCurve';\n    this.aX = aX;\n    this.aY = aY;\n    this.xRadius = xRadius;\n    this.yRadius = yRadius;\n    this.aStartAngle = aStartAngle;\n    this.aEndAngle = aEndAngle;\n    this.aClockwise = aClockwise;\n    this.aRotation = aRotation;\n  }\n\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector2();\n    const twoPi = Math.PI * 2;\n    let deltaAngle = this.aEndAngle - this.aStartAngle;\n    const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n    while (deltaAngle < 0) deltaAngle += twoPi;\n\n    while (deltaAngle > twoPi) deltaAngle -= twoPi;\n\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n        deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    }\n\n    if (this.aClockwise === true && !samePoints) {\n      if (deltaAngle === twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        deltaAngle = deltaAngle - twoPi;\n      }\n    }\n\n    const angle = this.aStartAngle + t * deltaAngle;\n    let x = this.aX + this.xRadius * Math.cos(angle);\n    let y = this.aY + this.yRadius * Math.sin(angle);\n\n    if (this.aRotation !== 0) {\n      const cos = Math.cos(this.aRotation);\n      const sin = Math.sin(this.aRotation);\n      const tx = x - this.aX;\n      const ty = y - this.aY; // Rotate the point about the center of the ellipse.\n\n      x = tx * cos - ty * sin + this.aX;\n      y = tx * sin + ty * cos + this.aY;\n    }\n\n    return point.set(x, y);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.aX = source.aX;\n    this.aY = source.aY;\n    this.xRadius = source.xRadius;\n    this.yRadius = source.yRadius;\n    this.aStartAngle = source.aStartAngle;\n    this.aEndAngle = source.aEndAngle;\n    this.aClockwise = source.aClockwise;\n    this.aRotation = source.aRotation;\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.aX = this.aX;\n    data.aY = this.aY;\n    data.xRadius = this.xRadius;\n    data.yRadius = this.yRadius;\n    data.aStartAngle = this.aStartAngle;\n    data.aEndAngle = this.aEndAngle;\n    data.aClockwise = this.aClockwise;\n    data.aRotation = this.aRotation;\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.aX = json.aX;\n    this.aY = json.aY;\n    this.xRadius = json.xRadius;\n    this.yRadius = json.yRadius;\n    this.aStartAngle = json.aStartAngle;\n    this.aEndAngle = json.aEndAngle;\n    this.aClockwise = json.aClockwise;\n    this.aRotation = json.aRotation;\n    return this;\n  }\n\n}\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nclass ArcCurve extends EllipseCurve {\n  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    this.type = 'ArcCurve';\n  }\n\n}\n\nArcCurve.prototype.isArcCurve = true;\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n  let c0 = 0,\n      c1 = 0,\n      c2 = 0,\n      c3 = 0;\n  /*\n   * Compute coefficients for a cubic polynomial\n   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n   * such that\n   *   p(0) = x0, p(1) = x1\n   *  and\n   *   p'(0) = t0, p'(1) = t1.\n   */\n\n  function init(x0, x1, t0, t1) {\n    c0 = x0;\n    c1 = t0;\n    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n    c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  }\n\n  return {\n    initCatmullRom: function (x0, x1, x2, x3, tension) {\n      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n    },\n    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\n      // compute tangents when parameterized in [t1,t2]\n      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]\n\n      t1 *= dt1;\n      t2 *= dt1;\n      init(x1, x2, t1, t2);\n    },\n    calc: function (t) {\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return c0 + c1 * t + c2 * t2 + c3 * t3;\n    }\n  };\n} //\n\n\nconst tmp = new Vector3();\nconst px = new CubicPoly(),\n      py = new CubicPoly(),\n      pz = new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n  constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {\n    super();\n    this.type = 'CatmullRomCurve3';\n    this.points = points;\n    this.closed = closed;\n    this.curveType = curveType;\n    this.tension = tension;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const points = this.points;\n    const l = points.length;\n    const p = (l - (this.closed ? 0 : 1)) * t;\n    let intPoint = Math.floor(p);\n    let weight = p - intPoint;\n\n    if (this.closed) {\n      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n    } else if (weight === 0 && intPoint === l - 1) {\n      intPoint = l - 2;\n      weight = 1;\n    }\n\n    let p0, p3; // 4 points (p1 & p2 defined below)\n\n    if (this.closed || intPoint > 0) {\n      p0 = points[(intPoint - 1) % l];\n    } else {\n      // extrapolate first point\n      tmp.subVectors(points[0], points[1]).add(points[0]);\n      p0 = tmp;\n    }\n\n    const p1 = points[intPoint % l];\n    const p2 = points[(intPoint + 1) % l];\n\n    if (this.closed || intPoint + 2 < l) {\n      p3 = points[(intPoint + 2) % l];\n    } else {\n      // extrapolate last point\n      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n      p3 = tmp;\n    }\n\n    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n      // init Centripetal / Chordal Catmull-Rom\n      const pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n      let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points\n\n      if (dt1 < 1e-4) dt1 = 1.0;\n      if (dt0 < 1e-4) dt0 = dt1;\n      if (dt2 < 1e-4) dt2 = dt1;\n      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n    } else if (this.curveType === 'catmullrom') {\n      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n    }\n\n    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.points = [];\n\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n      this.points.push(point.clone());\n    }\n\n    this.closed = source.closed;\n    this.curveType = source.curveType;\n    this.tension = source.tension;\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n\n    data.closed = this.closed;\n    data.curveType = this.curveType;\n    data.tension = this.tension;\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = [];\n\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector3().fromArray(point));\n    }\n\n    this.closed = json.closed;\n    this.curveType = json.curveType;\n    this.tension = json.tension;\n    return this;\n  }\n\n}\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n/**\n * Bezier Curves formulas obtained from\n * http://en.wikipedia.org/wiki/Bzier_curve\n */\n\nfunction CatmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n} //\n\n\nfunction QuadraticBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * p;\n}\n\nfunction QuadraticBezierP1(t, p) {\n  return 2 * (1 - t) * t * p;\n}\n\nfunction QuadraticBezierP2(t, p) {\n  return t * t * p;\n}\n\nfunction QuadraticBezier(t, p0, p1, p2) {\n  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n} //\n\n\nfunction CubicBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * k * p;\n}\n\nfunction CubicBezierP1(t, p) {\n  const k = 1 - t;\n  return 3 * k * k * t * p;\n}\n\nfunction CubicBezierP2(t, p) {\n  return 3 * (1 - t) * t * t * p;\n}\n\nfunction CubicBezierP3(t, p) {\n  return t * t * t * p;\n}\n\nfunction CubicBezier(t, p0, p1, p2, p3) {\n  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n}\n\nclass CubicBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n    super();\n    this.type = 'CubicBezierCurve';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2,\n          v3 = this.v3;\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n    return this;\n  }\n\n}\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nclass CubicBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n    super();\n    this.type = 'CubicBezierCurve3';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2,\n          v3 = this.v3;\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n    return this;\n  }\n\n}\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nclass LineCurve extends Curve {\n  constructor(v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n    this.type = 'LineCurve';\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n\n    return point;\n  } // Line curve is linear, so we can overwrite default getPointAt\n\n\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector2();\n    tangent.copy(this.v2).sub(this.v1).normalize();\n    return tangent;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n\n}\n\nLineCurve.prototype.isLineCurve = true;\n\nclass LineCurve3 extends Curve {\n  constructor(v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n    this.type = 'LineCurve3';\n    this.isLineCurve3 = true;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n\n    return point;\n  } // Line curve is linear, so we can overwrite default getPointAt\n\n\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n    this.type = 'QuadraticBezierCurve';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2;\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n\n}\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nclass QuadraticBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n    this.type = 'QuadraticBezierCurve3';\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2;\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n\n}\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nclass SplineCurve extends Curve {\n  constructor(points = []) {\n    super();\n    this.type = 'SplineCurve';\n    this.points = points;\n  }\n\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const points = this.points;\n    const p = (points.length - 1) * t;\n    const intPoint = Math.floor(p);\n    const weight = p - intPoint;\n    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    const p1 = points[intPoint];\n    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n    return point;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.points = [];\n\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n      this.points.push(point.clone());\n    }\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = [];\n\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector2().fromArray(point));\n    }\n\n    return this;\n  }\n\n}\n\nSplineCurve.prototype.isSplineCurve = true;\nvar Curves = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArcCurve: ArcCurve,\n  CatmullRomCurve3: CatmullRomCurve3,\n  CubicBezierCurve: CubicBezierCurve,\n  CubicBezierCurve3: CubicBezierCurve3,\n  EllipseCurve: EllipseCurve,\n  LineCurve: LineCurve,\n  LineCurve3: LineCurve3,\n  QuadraticBezierCurve: QuadraticBezierCurve,\n  QuadraticBezierCurve3: QuadraticBezierCurve3,\n  SplineCurve: SplineCurve\n});\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.2)\n */\n\nconst Earcut = {\n  triangulate: function (data, holeIndices, dim = 2) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    let minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n\n      for (let i = dim; i < outerLen; i += dim) {\n        x = data[i];\n        y = data[i + 1];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n    return triangles;\n  }\n}; // create a circular doubly linked list from polygon points in the specified winding order\n\nfunction linkedList(data, start, end, dim, clockwise) {\n  let i, last;\n\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n} // eliminate colinear or duplicate points\n\n\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start,\n      again;\n\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n} // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return; // interlink polygon nodes in z-order\n\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear,\n      prev,\n      next; // iterate through ears, slicing them one by one\n\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear); // skipping the next vertex leads to less sliver triangles\n\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n\n    ear = next; // if we looped through the whole remaining polygon and can't find any more ears\n\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n} // check whether a polygon node forms a valid ear with adjacent nodes\n\n\nfunction isEar(ear) {\n  const a = ear.prev,\n        b = ear,\n        c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n  // now make sure we don't have other points inside the potential ear\n\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev,\n        b = ear,\n        c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n  // triangle bbox; min & max are calculated like this for speed\n\n  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;\n\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  let p = ear.prevZ,\n      n = ear.nextZ; // look for points inside the triangle in both directions\n\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  } // look for remaining points in decreasing z-order\n\n\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  } // look for remaining points in increasing z-order\n\n\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  return true;\n} // go through all polygon nodes and cure small local self-intersections\n\n\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n\n  do {\n    const a = p.prev,\n          b = p.next.next;\n\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim); // remove two nodes involved\n\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n} // try splitting polygon into two and triangulate them independently\n\n\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n\n  do {\n    let b = a.next.next;\n\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b); // filter colinear points around the cuts\n\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next); // run earcut on each half\n\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n} // link every hole into the outer loop, producing a single-ring polygon without holes\n\n\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  let i, len, start, end, list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX); // process holes from left to right\n\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n} // find a bridge between vertices that connects hole with an outer ring and and link it\n\n\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts\n\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n} // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity,\n      m; // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n      if (x <= hx && x > qx) {\n        qx = x;\n\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m,\n        mx = m.x,\n        my = m.y;\n  let tanMin = Infinity,\n      tan;\n  p = m;\n\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n} // whether sector in vertex m contains sector in vertex p in the same coordinates\n\n\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n} // interlink polygon nodes in z-order\n\n\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n} // Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\nfunction sortLinked(list) {\n  let i,\n      p,\n      q,\n      e,\n      tail,\n      numMerges,\n      pSize,\n      qSize,\n      inSize = 1;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n} // z-order of a point given coords and inverse of the longer side of data bbox\n\n\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 0x00FF00FF;\n  x = (x | x << 4) & 0x0F0F0F0F;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00FF00FF;\n  y = (y | y << 4) & 0x0F0F0F0F;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n} // find the leftmost node of a polygon ring\n\n\nfunction getLeftmost(start) {\n  let p = start,\n      leftmost = start;\n\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n} // check if a point lies within a convex triangle\n\n\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n} // signed area of a triangle\n\n\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n} // check if two points are equal\n\n\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n} // check if two segments intersect\n\n\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n} // for collinear points p, q, r, check if point q lies on segment pr\n\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n} // check if a polygon diagonal intersects any polygon segments\n\n\nfunction intersectsPolygon(a, b) {\n  let p = a;\n\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n} // check if a polygon diagonal is locally inside the polygon\n\n\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n} // check if the middle point of a polygon diagonal is inside the polygon\n\n\nfunction middleInside(a, b) {\n  let p = a,\n      inside = false;\n  const px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\nfunction splitPolygon(a, b) {\n  const a2 = new Node$1(a.i, a.x, a.y),\n        b2 = new Node$1(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n} // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\nfunction insertNode(i, x, y, last) {\n  const p = new Node$1(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node$1(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i; // vertex coordinates\n\n  this.x = x;\n  this.y = y; // previous and next vertex nodes in a polygon ring\n\n  this.prev = null;\n  this.next = null; // z-order curve value\n\n  this.z = null; // previous and next nodes in z-order\n\n  this.prevZ = null;\n  this.nextZ = null; // indicates whether this is a steiner point\n\n  this.steiner = false;\n}\n\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n\n  return sum;\n}\n\nclass ShapeUtils {\n  // calculate area of the contour polygon\n  static area(contour) {\n    const n = contour.length;\n    let a = 0.0;\n\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n    }\n\n    return a * 0.5;\n  }\n\n  static isClockWise(pts) {\n    return ShapeUtils.area(pts) < 0;\n  }\n\n  static triangulateShape(contour, holes) {\n    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\n    const holeIndices = []; // array of hole indices\n\n    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n    removeDupEndPts(contour);\n    addContour(vertices, contour); //\n\n    let holeIndex = contour.length;\n    holes.forEach(removeDupEndPts);\n\n    for (let i = 0; i < holes.length; i++) {\n      holeIndices.push(holeIndex);\n      holeIndex += holes[i].length;\n      addContour(vertices, holes[i]);\n    } //\n\n\n    const triangles = Earcut.triangulate(vertices, holeIndices); //\n\n    for (let i = 0; i < triangles.length; i += 3) {\n      faces.push(triangles.slice(i, i + 3));\n    }\n\n    return faces;\n  }\n\n}\n\nfunction removeDupEndPts(points) {\n  const l = points.length;\n\n  if (l > 2 && points[l - 1].equals(points[0])) {\n    points.pop();\n  }\n}\n\nfunction addContour(vertices, contour) {\n  for (let i = 0; i < contour.length; i++) {\n    vertices.push(contour[i].x);\n    vertices.push(contour[i].y);\n  }\n}\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n  constructor(shapes, options) {\n    super();\n    this.type = 'ExtrudeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n    const scope = this;\n    const verticesArray = [];\n    const uvArray = [];\n\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      addShape(shape);\n    } // build geometry\n\n\n    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n    this.computeVertexNormals(); // functions\n\n    function addShape(shape) {\n      const placeholder = []; // options\n\n      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n      const steps = options.steps !== undefined ? options.steps : 1;\n      let depth = options.depth !== undefined ? options.depth : 100;\n      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n      const extrudePath = options.extrudePath;\n      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n      if (options.amount !== undefined) {\n        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n        depth = options.amount;\n      } //\n\n\n      let extrudePts,\n          extrudeByPath = false;\n      let splineTube, binormal, normal, position2;\n\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n        // SETUP TNB variables\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      } // Safeguards if bevels are not enabled\n\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      } // Variables initialization\n\n\n      const shapePoints = shape.extractPoints(curveSegments);\n      let vertices = shapePoints.shape;\n      const holes = shapePoints.holes;\n      const reverse = !ShapeUtils.isClockWise(vertices);\n\n      if (reverse) {\n        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n\n      const faces = ShapeUtils.triangulateShape(vertices, holes);\n      /* Vertices */\n\n      const contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        vertices = vertices.concat(ahole);\n      }\n\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n\n      const vlen = vertices.length,\n            flen = faces.length; // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        const v_prev_x = inPt.x - inPrev.x,\n              v_prev_y = inPt.y - inPrev.y;\n        const v_next_x = inNext.x - inPt.x,\n              v_next_y = inNext.y - inPt.y;\n        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n          // length of vectors for normalizing\n          const v_prev_len = Math.sqrt(v_prev_lensq);\n          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          const ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n\n          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n          let direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n\n          if (direction_eq) {\n            // console.log(\"Warning: lines are a straight sequence\");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log(\"Warning: lines are a straight spike\");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n\n      const contourMovements = [];\n\n      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0; //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n      }\n\n      const holesMovements = [];\n      let oneHoleMovements,\n          verticesMovements = contourMovements.concat();\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        oneHoleMovements = [];\n\n        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n          if (j === il) j = 0;\n          if (k === il) k = 0; //  (j)---(i)---(k)\n\n          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      } // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n      for (let b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, -z);\n        } // expand holes\n\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n            v(vert.x, vert.y, -z);\n          }\n        }\n      }\n\n      const bs = bevelSize + bevelOffset; // Back facing vertices\n\n      for (let i = 0; i < vlen; i++) {\n        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      } // Add stepped vertices...\n      // Including front facing vertices\n\n\n      for (let s = 1; s <= steps; s++) {\n        for (let i = 0; i < vlen; i++) {\n          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, depth / steps * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      } // Add bevel segments planes\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n      for (let b = bevelSegments - 1; b >= 0; b--) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, depth + z);\n        } // expand holes\n\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n            if (!extrudeByPath) {\n              v(vert.x, vert.y, depth + z);\n            } else {\n              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n            }\n          }\n        }\n      }\n      /* Faces */\n      // Top and bottom faces\n\n\n      buildLidFaces(); // Sides faces\n\n      buildSideFaces(); /////  Internal functions\n\n      function buildLidFaces() {\n        const start = verticesArray.length / 3;\n\n        if (bevelEnabled) {\n          let layer = 0; // steps + 1\n\n          let offset = vlen * layer; // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer; // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + offset, face[1] + offset, face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2], face[1], face[0]);\n          } // Top faces\n\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n          }\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      } // Create faces for the z-sides of the shape\n\n\n      function buildSideFaces() {\n        const start = verticesArray.length / 3;\n        let layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          sidewalls(ahole, layeroffset); //, true\n\n          layeroffset += ahole.length;\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n\n      function sidewalls(contour, layeroffset) {\n        let i = contour.length;\n\n        while (--i >= 0) {\n          const j = i;\n          let k = i - 1;\n          if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n            const slen1 = vlen * s;\n            const slen2 = vlen * (s + 1);\n            const a = layeroffset + j + slen1,\n                  b = layeroffset + k + slen1,\n                  c = layeroffset + k + slen2,\n                  d = layeroffset + j + slen2;\n            f4(a, b, c, d);\n          }\n        }\n      }\n\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    const options = this.parameters.options;\n    return toJSON$1(shapes, options, data);\n  }\n\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n\n    const extrudePath = data.options.extrudePath;\n\n    if (extrudePath !== undefined) {\n      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n    }\n\n    return new ExtrudeGeometry(geometryShapes, data.options);\n  }\n\n}\n\nconst WorldUVGenerator = {\n  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const a_z = vertices[indexA * 3 + 2];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const b_z = vertices[indexB * 3 + 2];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    const c_z = vertices[indexC * 3 + 2];\n    const d_x = vertices[indexD * 3];\n    const d_y = vertices[indexD * 3 + 1];\n    const d_z = vertices[indexD * 3 + 2];\n\n    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\n\nfunction toJSON$1(shapes, options, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\n\nclass ShapeGeometry extends BufferGeometry {\n  constructor(shapes, curveSegments = 12) {\n    super();\n    this.type = 'ShapeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    }; // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    let groupStart = 0;\n    let groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (let i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n    function addShape(shape) {\n      const indexOffset = vertices.length / 3;\n      const points = shape.extractPoints(curveSegments);\n      let shapeVertices = points.shape;\n      const shapeHoles = points.holes; // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[i] = shapeHole.reverse();\n        }\n      }\n\n      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        shapeVertices = shapeVertices.concat(shapeHole);\n      } // vertices, normals, uvs\n\n\n      for (let i = 0, l = shapeVertices.length; i < l; i++) {\n        const vertex = shapeVertices[i];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      } // incides\n\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const a = face[0] + indexOffset;\n        const b = face[1] + indexOffset;\n        const c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    return toJSON(shapes, data);\n  }\n\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n\n    return new ShapeGeometry(geometryShapes, data.curveSegments);\n  }\n\n}\n\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n/**\n * parameters = {\n *  color: <THREE.Color>\n * }\n */\n\n\nclass ShadowMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'ShadowMaterial';\n    this.color = new Color(0x000000);\n    this.transparent = true;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    return this;\n  }\n\n}\n\nShadowMaterial.prototype.isShadowMaterial = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshStandardMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.defines = {\n      'STANDARD': ''\n    };\n    this.type = 'MeshStandardMaterial';\n    this.color = new Color(0xffffff); // diffuse\n\n    this.roughness = 1.0;\n    this.metalness = 0.0;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.roughnessMap = null;\n    this.metalnessMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapIntensity = 1.0;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      'STANDARD': ''\n    };\n    this.color.copy(source.color);\n    this.roughness = source.roughness;\n    this.metalness = source.metalness;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.roughnessMap = source.roughnessMap;\n    this.metalnessMap = source.metalnessMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapIntensity = source.envMapIntensity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n\n}\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n/**\n * parameters = {\n *  clearcoat: <float>,\n *  clearcoatMap: new THREE.Texture( <Image> ),\n *  clearcoatRoughness: <float>,\n *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),\n *  clearcoatNormalScale: <Vector2>,\n *  clearcoatNormalMap: new THREE.Texture( <Image> ),\n *\n *  reflectivity: <float>,\n *  ior: <float>,\n *\n *  sheen: <Color>,\n *\n *  transmission: <float>,\n *  transmissionMap: new THREE.Texture( <Image> ),\n *\n *  thickness: <float>,\n *  thicknessMap: new THREE.Texture( <Image> ),\n *  attenuationDistance: <float>,\n *  attenuationTint: <Color>,\n *\n *  specularIntensity: <float>,\n *  specularIntensityhMap: new THREE.Texture( <Image> ),\n *  specularTint: <Color>,\n *  specularTintMap: new THREE.Texture( <Image> )\n * }\n */\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n  constructor(parameters) {\n    super();\n    this.defines = {\n      'STANDARD': '',\n      'PHYSICAL': ''\n    };\n    this.type = 'MeshPhysicalMaterial';\n    this.clearcoat = 0.0;\n    this.clearcoatMap = null;\n    this.clearcoatRoughness = 0.0;\n    this.clearcoatRoughnessMap = null;\n    this.clearcoatNormalScale = new Vector2(1, 1);\n    this.clearcoatNormalMap = null;\n    this.reflectivity = 0.5; // maps to F0 = 0.04\n\n    Object.defineProperty(this, 'ior', {\n      get: function () {\n        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);\n      },\n      set: function (ior) {\n        this.reflectivity = clamp$1(2.5 * (ior - 1) / (ior + 1), 0, 1);\n      }\n    });\n    this.sheen = null; // null will disable sheen bsdf\n\n    this.transmission = 0.0;\n    this.transmissionMap = null;\n    this.thickness = 0.01;\n    this.thicknessMap = null;\n    this.attenuationDistance = 0.0;\n    this.attenuationTint = new Color(1, 1, 1);\n    this.specularIntensity = 1.0;\n    this.specularIntensityMap = null;\n    this.specularTint = new Color(1, 1, 1);\n    this.specularTintMap = null;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      'STANDARD': '',\n      'PHYSICAL': ''\n    };\n    this.clearcoat = source.clearcoat;\n    this.clearcoatMap = source.clearcoatMap;\n    this.clearcoatRoughness = source.clearcoatRoughness;\n    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n    this.clearcoatNormalMap = source.clearcoatNormalMap;\n    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n    this.reflectivity = source.reflectivity;\n\n    if (source.sheen) {\n      this.sheen = (this.sheen || new Color()).copy(source.sheen);\n    } else {\n      this.sheen = null;\n    }\n\n    this.transmission = source.transmission;\n    this.transmissionMap = source.transmissionMap;\n    this.thickness = source.thickness;\n    this.thicknessMap = source.thicknessMap;\n    this.attenuationDistance = source.attenuationDistance;\n    this.attenuationTint.copy(source.attenuationTint);\n    this.specularIntensity = source.specularIntensity;\n    this.specularIntensityMap = source.specularIntensityMap;\n    this.specularTint.copy(source.specularTint);\n    this.specularTintMap = source.specularTintMap;\n    return this;\n  }\n\n}\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.MultiplyOperation,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshPhongMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'MeshPhongMaterial';\n    this.color = new Color(0xffffff); // diffuse\n\n    this.specular = new Color(0x111111);\n    this.shininess = 30;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.specular.copy(source.specular);\n    this.shininess = source.shininess;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n\n}\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n/**\n * parameters = {\n *  color: <hex>,\n *\n *  map: new THREE.Texture( <Image> ),\n *  gradientMap: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n * }\n */\n\nclass MeshToonMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.defines = {\n      'TOON': ''\n    };\n    this.type = 'MeshToonMaterial';\n    this.color = new Color(0xffffff);\n    this.map = null;\n    this.gradientMap = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.alphaMap = null;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.gradientMap = source.gradientMap;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    return this;\n  }\n\n}\n\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\n/**\n * parameters = {\n *  opacity: <float>,\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshNormalMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'MeshNormalMaterial';\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n\n}\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n * }\n */\n\nclass MeshLambertMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.type = 'MeshLambertMaterial';\n    this.color = new Color(0xffffff); // diffuse\n\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n    this.emissive = new Color(0x000000);\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    return this;\n  }\n\n}\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  matcap: new THREE.Texture( <Image> ),\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  flatShading: <bool>\n * }\n */\n\nclass MeshMatcapMaterial extends Material$1 {\n  constructor(parameters) {\n    super();\n    this.defines = {\n      'MATCAP': ''\n    };\n    this.type = 'MeshMatcapMaterial';\n    this.color = new Color(0xffffff); // diffuse\n\n    this.matcap = null;\n    this.map = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.alphaMap = null;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      'MATCAP': ''\n    };\n    this.color.copy(source.color);\n    this.matcap = source.matcap;\n    this.map = source.map;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n\n}\n\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n/**\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nclass LineDashedMaterial extends LineBasicMaterial {\n  constructor(parameters) {\n    super();\n    this.type = 'LineDashedMaterial';\n    this.scale = 1;\n    this.dashSize = 3;\n    this.gapSize = 1;\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.scale = source.scale;\n    this.dashSize = source.dashSize;\n    this.gapSize = source.gapSize;\n    return this;\n  }\n\n}\n\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\nconst AnimationUtils = {\n  // same as Array.prototype.slice, but also works on typed arrays\n  arraySlice: function (array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      // in ios9 array.subarray(from, undefined) will return empty array\n      // but array.subarray(from) or array.subarray(from, len) is correct\n      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n    }\n\n    return array.slice(from, to);\n  },\n  // converts an array to a specific type\n  convertArray: function (array, type, forceClone) {\n    if (!array || // let 'undefined' and 'null' pass\n    !forceClone && array.constructor === type) return array;\n\n    if (typeof type.BYTES_PER_ELEMENT === 'number') {\n      return new type(array); // create typed array\n    }\n\n    return Array.prototype.slice.call(array); // create Array\n  },\n  isTypedArray: function (object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n  // returns an array by which times and values can be sorted\n  getKeyframeOrder: function (times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n\n    const n = times.length;\n    const result = new Array(n);\n\n    for (let i = 0; i !== n; ++i) result[i] = i;\n\n    result.sort(compareTime);\n    return result;\n  },\n  // uses the array previously returned by 'getKeyframeOrder' to sort data\n  sortedArray: function (values, stride, order) {\n    const nValues = values.length;\n    const result = new values.constructor(nValues);\n\n    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n      const srcOffset = order[i] * stride;\n\n      for (let j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n\n    return result;\n  },\n  // function for parsing AOS keyframe formats\n  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n    let i = 1,\n        key = jsonKeys[0];\n\n    while (key !== undefined && key[valuePropertyName] === undefined) {\n      key = jsonKeys[i++];\n    }\n\n    if (key === undefined) return; // no data\n\n    let value = key[valuePropertyName];\n    if (value === undefined) return; // no data\n\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push.apply(values, value); // push all elements\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else if (value.toArray !== undefined) {\n      // ...assume THREE.Math-ish\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else {\n      // otherwise push as-is\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push(value);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    }\n  },\n  subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {\n    const clip = sourceClip.clone();\n    clip.name = name;\n    const tracks = [];\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      const track = clip.tracks[i];\n      const valueSize = track.getValueSize();\n      const times = [];\n      const values = [];\n\n      for (let j = 0; j < track.times.length; ++j) {\n        const frame = track.times[j] * fps;\n        if (frame < startFrame || frame >= endFrame) continue;\n        times.push(track.times[j]);\n\n        for (let k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n\n      if (times.length === 0) continue;\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(values, track.values.constructor);\n      tracks.push(track);\n    }\n\n    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n    let minStartTime = Infinity;\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      if (minStartTime > clip.tracks[i].times[0]) {\n        minStartTime = clip.tracks[i].times[0];\n      }\n    } // shift all tracks such that clip begins at t=0\n\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      clip.tracks[i].shift(-1 * minStartTime);\n    }\n\n    clip.resetDuration();\n    return clip;\n  },\n  makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n    if (fps <= 0) fps = 30;\n    const numTracks = referenceClip.tracks.length;\n    const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n    for (let i = 0; i < numTracks; ++i) {\n      const referenceTrack = referenceClip.tracks[i];\n      const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track\n\n      const targetTrack = targetClip.tracks.find(function (track) {\n        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n      });\n      if (targetTrack === undefined) continue;\n      let referenceOffset = 0;\n      const referenceValueSize = referenceTrack.getValueSize();\n\n      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        referenceOffset = referenceValueSize / 3;\n      }\n\n      let targetOffset = 0;\n      const targetValueSize = targetTrack.getValueSize();\n\n      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        targetOffset = targetValueSize / 3;\n      }\n\n      const lastIndex = referenceTrack.times.length - 1;\n      let referenceValue; // Find the value to subtract out of the track\n\n      if (referenceTime <= referenceTrack.times[0]) {\n        // Reference frame is earlier than the first keyframe, so just use the first keyframe\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        // Reference frame is after the last keyframe, so just use the last keyframe\n        const startIndex = lastIndex * referenceValueSize + referenceOffset;\n        const endIndex = startIndex + referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else {\n        // Interpolate to the reference value\n        const interpolant = referenceTrack.createInterpolant();\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n      } // Conjugate the quaternion\n\n\n      if (referenceTrackType === 'quaternion') {\n        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n        referenceQuat.toArray(referenceValue);\n      } // Subtract the reference value from all of the track values\n\n\n      const numTimes = targetTrack.times.length;\n\n      for (let j = 0; j < numTimes; ++j) {\n        const valueStart = j * targetValueSize + targetOffset;\n\n        if (referenceTrackType === 'quaternion') {\n          // Multiply the conjugate for quaternion track types\n          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n        } else {\n          const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n          for (let k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    }\n\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n    return targetClip;\n  }\n};\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n\n  evaluate(t) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex,\n        t1 = pp[i1],\n        t0 = pp[i1 - 1];\n\n    validate_interval: {\n      seek: {\n        let right;\n\n        linear_scan: {\n          //- See http://jsperf.com/comparison-to-undefined/3\n          //- slower code:\n          //-\n          //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n          forward_scan: if (!(t < t1)) {\n            for (let giveUpAt = i1 + 2;;) {\n              if (t1 === undefined) {\n                if (t < t0) break forward_scan; // after end\n\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.afterEnd_(i1 - 1, t, t0);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t0 = t1;\n              t1 = pp[++i1];\n\n              if (t < t1) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            } // prepare binary search on the right side of the index\n\n\n            right = pp.length;\n            break linear_scan;\n          } //- slower code:\n          //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n          if (!(t >= t0)) {\n            // looping?\n            const t1global = pp[1];\n\n            if (t < t1global) {\n              i1 = 2; // + 1, using the scan for the details\n\n              t0 = t1global;\n            } // linear reverse scan\n\n\n            for (let giveUpAt = i1 - 2;;) {\n              if (t0 === undefined) {\n                // before start\n                this._cachedIndex = 0;\n                return this.beforeStart_(0, t, t1);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n\n              if (t >= t0) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            } // prepare binary search on the left side of the index\n\n\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          } // the interval is valid\n\n\n          break validate_interval;\n        } // linear scan\n        // binary search\n\n\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n\n        t1 = pp[i1];\n        t0 = pp[i1 - 1]; // check boundary cases, again\n\n        if (t0 === undefined) {\n          this._cachedIndex = 0;\n          return this.beforeStart_(0, t, t1);\n        }\n\n        if (t1 === undefined) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.afterEnd_(i1 - 1, t0, t);\n        }\n      } // seek\n\n\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    } // validate_interval\n\n\n    return this.interpolate_(i1, t0, t, t1);\n  }\n\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n\n  copySampleValue_(index) {\n    // copies a sample value to the result buffer\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          offset = index * stride;\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  } // Template methods for derived classes:\n\n\n  interpolate_()\n  /* i1, t0, t, t1 */\n  {\n    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer\n  }\n\n  intervalChanged_()\n  /* i1, t0, t1 */\n  {// empty\n  }\n\n} // ALIAS DEFINITIONS\n\n\nInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\nInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = -0;\n    this._offsetNext = -0;\n    this.DefaultSettings_ = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n  }\n\n  intervalChanged_(i1, t0, t1) {\n    const pp = this.parameterPositions;\n    let iPrev = i1 - 2,\n        iNext = i1 + 1,\n        tPrev = pp[iPrev],\n        tNext = pp[iNext];\n\n    if (tPrev === undefined) {\n      switch (this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          // f'(t0) = 0\n          iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iPrev = pp.length - 2;\n          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n          break;\n\n        default:\n          // ZeroCurvatureEnding\n          // f''(t0) = 0 a.k.a. Natural Spline\n          iPrev = i1;\n          tPrev = t1;\n      }\n    }\n\n    if (tNext === undefined) {\n      switch (this.getSettings_().endingEnd) {\n        case ZeroSlopeEnding:\n          // f'(tN) = 0\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n          break;\n\n        case WrapAroundEnding:\n          // use the other end of the curve\n          iNext = 1;\n          tNext = t1 + pp[1] - pp[0];\n          break;\n\n        default:\n          // ZeroCurvatureEnding\n          // f''(tN) = 0, a.k.a. Natural Spline\n          iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n\n    const halfDt = (t1 - t0) * 0.5,\n          stride = this.valueSize;\n    this._weightPrev = halfDt / (t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          o1 = i1 * stride,\n          o0 = o1 - stride,\n          oP = this._offsetPrev,\n          oN = this._offsetNext,\n          wP = this._weightPrev,\n          wN = this._weightNext,\n          p = (t - t0) / (t1 - t0),\n          pp = p * p,\n          ppp = pp * p; // evaluate polynomials\n\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - wN * pp; // combine data linearly\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n    }\n\n    return result;\n  }\n\n}\n\nclass LinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          offset1 = i1 * stride,\n          offset0 = offset1 - stride,\n          weight1 = (t - t0) / (t1 - t0),\n          weight0 = 1 - weight1;\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n    }\n\n    return result;\n  }\n\n}\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n */\n\n\nclass DiscreteInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  interpolate_(i1\n  /*, t0, t, t1 */\n  ) {\n    return this.copySampleValue_(i1 - 1);\n  }\n\n}\n\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n    this.name = name;\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  } // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n\n\n  static toJSON(track) {\n    const trackType = track.constructor;\n    let json; // derived classes can define a static toJSON method\n\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      // by default, we assume the data can be serialized as-is\n      json = {\n        'name': track.name,\n        'times': AnimationUtils.convertArray(track.times, Array),\n        'values': AnimationUtils.convertArray(track.values, Array)\n      };\n      const interpolation = track.getInterpolation();\n\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n\n    json.type = track.ValueTypeName; // mandatory\n\n    return json;\n  }\n\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n  setInterpolation(interpolation) {\n    let factoryMethod;\n\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n\n    if (factoryMethod === undefined) {\n      const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n\n      if (this.createInterpolant === undefined) {\n        // fall back to default, unless the default itself is messed up\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message); // fatal, in this case\n        }\n      }\n\n      console.warn('THREE.KeyframeTrack:', message);\n      return this;\n    }\n\n    this.createInterpolant = factoryMethod;\n    return this;\n  }\n\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n\n  getValueSize() {\n    return this.values.length / this.times.length;\n  } // move all keyframes either forwards or backwards in time\n\n\n  shift(timeOffset) {\n    if (timeOffset !== 0.0) {\n      const times = this.times;\n\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n\n    return this;\n  } // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\n\n  scale(timeScale) {\n    if (timeScale !== 1.0) {\n      const times = this.times;\n\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n\n    return this;\n  } // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\n\n  trim(startTime, endTime) {\n    const times = this.times,\n          nKeys = times.length;\n    let from = 0,\n        to = nKeys - 1;\n\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n\n    ++to; // inclusive -> exclusive bound\n\n    if (from !== 0 || to !== nKeys) {\n      // empty tracks are forbidden, so keep at least one keyframe\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n\n      const stride = this.getValueSize();\n      this.times = AnimationUtils.arraySlice(times, from, to);\n      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n    }\n\n    return this;\n  } // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\n\n  validate() {\n    let valid = true;\n    const valueSize = this.getValueSize();\n\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n      valid = false;\n    }\n\n    const times = this.times,\n          values = this.values,\n          nKeys = times.length;\n\n    if (nKeys === 0) {\n      console.error('THREE.KeyframeTrack: Track is empty.', this);\n      valid = false;\n    }\n\n    let prevTime = null;\n\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n\n      if (typeof currTime === 'number' && isNaN(currTime)) {\n        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n        valid = false;\n        break;\n      }\n\n      if (prevTime !== null && prevTime > currTime) {\n        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n\n      prevTime = currTime;\n    }\n\n    if (values !== undefined) {\n      if (AnimationUtils.isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n\n          if (isNaN(value)) {\n            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n\n    return valid;\n  } // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\n\n  optimize() {\n    // times or values may be shared with other tracks, so overwriting is unsafe\n    const times = AnimationUtils.arraySlice(this.times),\n          values = AnimationUtils.arraySlice(this.values),\n          stride = this.getValueSize(),\n          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n          lastIndex = times.length - 1;\n    let writeIndex = 1;\n\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const time = times[i];\n      const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time\n\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          // remove unnecessary keyframes same as their neighbors\n          const offset = i * stride,\n                offsetP = offset - stride,\n                offsetN = offset + stride;\n\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      } // in-place compaction\n\n\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          const readOffset = i * stride,\n                writeOffset = writeIndex * stride;\n\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n\n        ++writeIndex;\n      }\n    } // flush last keyframe (compaction looks ahead)\n\n\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n\n      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n\n      ++writeIndex;\n    }\n\n    if (writeIndex !== times.length) {\n      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n\n    return this;\n  }\n\n  clone() {\n    const times = AnimationUtils.arraySlice(this.times, 0);\n    const values = AnimationUtils.arraySlice(this.values, 0);\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n/**\n * A Track of Boolean keyframe values.\n */\n\nclass BooleanKeyframeTrack extends KeyframeTrack {}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n/**\n * A Track of keyframe values that represent color.\n */\n\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n/**\n * A Track of numeric keyframe values.\n */\n\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          alpha = (t - t0) / (t1 - t0);\n    let offset = i1 * stride;\n\n    for (let end = offset + stride; offset !== end; offset += 4) {\n      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n    }\n\n    return result;\n  }\n\n}\n/**\n * A Track of quaternion keyframe values.\n */\n\n\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n  InterpolantFactoryMethodLinear(result) {\n    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited\n\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n/**\n * A Track that interpolates Strings\n */\n\nclass StringKeyframeTrack extends KeyframeTrack {}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n/**\n * A Track of vectored keyframe values.\n */\n\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n\n  static parse(json) {\n    const tracks = [],\n          jsonTracks = json.tracks,\n          frameTime = 1.0 / (json.fps || 1.0);\n\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n    return clip;\n  }\n\n  static toJSON(clip) {\n    const tracks = [],\n          clipTracks = clip.tracks;\n    const json = {\n      'name': clip.name,\n      'duration': clip.duration,\n      'tracks': tracks,\n      'uuid': clip.uuid,\n      'blendMode': clip.blendMode\n    };\n\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n\n    return json;\n  }\n\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      const order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n    }\n\n    return new this(name, -1, tracks);\n  }\n\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n\n    return null;\n  }\n\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n    const pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n        let animationMorphTargets = animationToMorphTargets[name];\n\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n\n    const clips = [];\n\n    for (const name in animationToMorphTargets) {\n      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n\n    return clips;\n  } // parse the animation.hierarchy format\n\n\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n\n    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n\n    const tracks = [];\n    const clipName = animation.name || 'default';\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n    let duration = animation.length || -1;\n    const hierarchyTracks = animation.hierarchy || [];\n\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        const morphTargetNames = {};\n        let k;\n\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        } // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n\n\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n\n          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n        }\n\n        duration = morphTargetNames.length * (fps || 1.0);\n      } else {\n        // ...assume skeletal animation\n        const boneName = '.bones[' + bones[h].name + ']';\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n      }\n    }\n\n    if (tracks.length === 0) {\n      return null;\n    }\n\n    const clip = new this(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n\n    this.duration = duration;\n    return this;\n  }\n\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n\n    return this;\n  }\n\n  validate() {\n    let valid = true;\n\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n\n    return valid;\n  }\n\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n\n    return this;\n  }\n\n  clone() {\n    const tracks = [];\n\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n\n    return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n  }\n\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n\n}\n\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n\n    case 'color':\n      return ColorKeyframeTrack;\n\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n\n    case 'string':\n      return StringKeyframeTrack;\n  }\n\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\n\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n\n  const trackType = getTrackTypeForValueTypeName(json.type);\n\n  if (json.times === undefined) {\n    const times = [],\n          values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, 'value');\n    json.times = times;\n    json.values = values;\n  } // derived classes can define a static parse method\n\n\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\n\nconst Cache = {\n  enabled: false,\n  files: {},\n  add: function (key, file) {\n    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );\n\n    this.files[key] = file;\n  },\n  get: function (key) {\n    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );\n\n    return this.files[key];\n  },\n  remove: function (key) {\n    delete this.files[key];\n  },\n  clear: function () {\n    this.files = {};\n  }\n};\n\nclass LoadingManager {\n  constructor(onLoad, onProgress, onError) {\n    const scope = this;\n    let isLoading = false;\n    let itemsLoaded = 0;\n    let itemsTotal = 0;\n    let urlModifier = undefined;\n    const handlers = []; // Refer to #5689 for the reason why we don't set .onStart\n    // in the constructor\n\n    this.onStart = undefined;\n    this.onLoad = onLoad;\n    this.onProgress = onProgress;\n    this.onError = onError;\n\n    this.itemStart = function (url) {\n      itemsTotal++;\n\n      if (isLoading === false) {\n        if (scope.onStart !== undefined) {\n          scope.onStart(url, itemsLoaded, itemsTotal);\n        }\n      }\n\n      isLoading = true;\n    };\n\n    this.itemEnd = function (url) {\n      itemsLoaded++;\n\n      if (scope.onProgress !== undefined) {\n        scope.onProgress(url, itemsLoaded, itemsTotal);\n      }\n\n      if (itemsLoaded === itemsTotal) {\n        isLoading = false;\n\n        if (scope.onLoad !== undefined) {\n          scope.onLoad();\n        }\n      }\n    };\n\n    this.itemError = function (url) {\n      if (scope.onError !== undefined) {\n        scope.onError(url);\n      }\n    };\n\n    this.resolveURL = function (url) {\n      if (urlModifier) {\n        return urlModifier(url);\n      }\n\n      return url;\n    };\n\n    this.setURLModifier = function (transform) {\n      urlModifier = transform;\n      return this;\n    };\n\n    this.addHandler = function (regex, loader) {\n      handlers.push(regex, loader);\n      return this;\n    };\n\n    this.removeHandler = function (regex) {\n      const index = handlers.indexOf(regex);\n\n      if (index !== -1) {\n        handlers.splice(index, 2);\n      }\n\n      return this;\n    };\n\n    this.getHandler = function (file) {\n      for (let i = 0, l = handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n        const loader = handlers[i + 1];\n        if (regex.global) regex.lastIndex = 0; // see #17920\n\n        if (regex.test(file)) {\n          return loader;\n        }\n      }\n\n      return null;\n    };\n  }\n\n}\n\nconst DefaultLoadingManager = new LoadingManager();\n\nclass Loader {\n  constructor(manager) {\n    this.manager = manager !== undefined ? manager : DefaultLoadingManager;\n    this.crossOrigin = 'anonymous';\n    this.withCredentials = false;\n    this.path = '';\n    this.resourcePath = '';\n    this.requestHeader = {};\n  }\n\n  load()\n  /* url, onLoad, onProgress, onError */\n  {}\n\n  loadAsync(url, onProgress) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.load(url, resolve, onProgress, reject);\n    });\n  }\n\n  parse()\n  /* data */\n  {}\n\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n\n  setWithCredentials(value) {\n    this.withCredentials = value;\n    return this;\n  }\n\n  setPath(path) {\n    this.path = path;\n    return this;\n  }\n\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n\n  setRequestHeader(requestHeader) {\n    this.requestHeader = requestHeader;\n    return this;\n  }\n\n}\n\nconst loading = {};\n\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    } // Check if request is duplicate\n\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      return;\n    } // Check for data: URI\n\n\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = url.match(dataUriRegex);\n    let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually\n\n    if (dataUriRegexResult) {\n      const mimeType = dataUriRegexResult[1];\n      const isBase64 = !!dataUriRegexResult[2];\n      let data = dataUriRegexResult[3];\n      data = decodeURIComponent(data);\n      if (isBase64) data = atob(data);\n\n      try {\n        let response;\n        const responseType = (this.responseType || '').toLowerCase();\n\n        switch (responseType) {\n          case 'arraybuffer':\n          case 'blob':\n            const view = new Uint8Array(data.length);\n\n            for (let i = 0; i < data.length; i++) {\n              view[i] = data.charCodeAt(i);\n            }\n\n            if (responseType === 'blob') {\n              response = new Blob([view.buffer], {\n                type: mimeType\n              });\n            } else {\n              response = view.buffer;\n            }\n\n            break;\n\n          case 'document':\n            const parser = new DOMParser();\n            response = parser.parseFromString(data, mimeType);\n            break;\n\n          case 'json':\n            response = JSON.parse(data);\n            break;\n\n          default:\n            // 'text' or other\n            response = data;\n            break;\n        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\n\n        setTimeout(function () {\n          if (onLoad) onLoad(response);\n          scope.manager.itemEnd(url);\n        }, 0);\n      } catch (error) {\n        // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n        setTimeout(function () {\n          if (onError) onError(error);\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }, 0);\n      }\n    } else {\n      // Initialise array for duplicate requests\n      loading[url] = [];\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      request = new XMLHttpRequest();\n      request.open('GET', url, true);\n      request.addEventListener('load', function (event) {\n        const response = this.response;\n        const callbacks = loading[url];\n        delete loading[url];\n\n        if (this.status === 200 || this.status === 0) {\n          // Some browsers return HTTP Status 0 when using non-http protocol\n          // e.g. 'file://' or 'data://'. Handle as success.\n          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache\n          // error response bodies as proper responses to requests.\n\n          Cache.add(url, response);\n\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onLoad) callback.onLoad(response);\n          }\n\n          scope.manager.itemEnd(url);\n        } else {\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onError) callback.onError(event);\n          }\n\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }\n      }, false);\n      request.addEventListener('progress', function (event) {\n        const callbacks = loading[url];\n\n        for (let i = 0, il = callbacks.length; i < il; i++) {\n          const callback = callbacks[i];\n          if (callback.onProgress) callback.onProgress(event);\n        }\n      }, false);\n      request.addEventListener('error', function (event) {\n        const callbacks = loading[url];\n        delete loading[url];\n\n        for (let i = 0, il = callbacks.length; i < il; i++) {\n          const callback = callbacks[i];\n          if (callback.onError) callback.onError(event);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }, false);\n      request.addEventListener('abort', function (event) {\n        const callbacks = loading[url];\n        delete loading[url];\n\n        for (let i = 0, il = callbacks.length; i < il; i++) {\n          const callback = callbacks[i];\n          if (callback.onError) callback.onError(event);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }, false);\n      if (this.responseType !== undefined) request.responseType = this.responseType;\n      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;\n      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n\n      for (const header in this.requestHeader) {\n        request.setRequestHeader(header, this.requestHeader[header]);\n      }\n\n      request.send(null);\n    }\n\n    scope.manager.itemStart(url);\n    return request;\n  }\n\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n\n}\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\n\nclass CompressedTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const images = [];\n    const texture = new CompressedTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    let loaded = 0;\n\n    function loadTexture(i) {\n      loader.load(url[i], function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n          texture.image = images;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n\n    if (Array.isArray(url)) {\n      for (let i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n      loader.load(url, function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n\n        if (texDatas.isCubemap) {\n          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n          for (let f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n\n            for (let i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n\n          texture.image = images;\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n\n    return texture;\n  }\n\n}\n\nclass ImageLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n\n    const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');\n\n    function onImageLoad() {\n      image.removeEventListener('load', onImageLoad, false);\n      image.removeEventListener('error', onImageError, false);\n      Cache.add(url, this);\n      if (onLoad) onLoad(this);\n      scope.manager.itemEnd(url);\n    }\n\n    function onImageError(event) {\n      image.removeEventListener('load', onImageLoad, false);\n      image.removeEventListener('error', onImageError, false);\n      if (onError) onError(event);\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    }\n\n    image.addEventListener('load', onImageLoad, false);\n    image.addEventListener('error', onImageError, false);\n\n    if (url.substr(0, 5) !== 'data:') {\n      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n    }\n\n    scope.manager.itemStart(url);\n    image.src = url;\n    return image;\n  }\n\n}\n\nclass CubeTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture();\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    let loaded = 0;\n\n    function loadTexture(i) {\n      loader.load(urls[i], function (image) {\n        texture.images[i] = image;\n        loaded++;\n\n        if (loaded === 6) {\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, undefined, onError);\n    }\n\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i);\n    }\n\n    return texture;\n  }\n\n}\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\n\nclass DataTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const texture = new DataTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      const texData = scope.parse(buffer);\n      if (!texData) return;\n\n      if (texData.image !== undefined) {\n        texture.image = texData.image;\n      } else if (texData.data !== undefined) {\n        texture.image.width = texData.width;\n        texture.image.height = texData.height;\n        texture.image.data = texData.data;\n      }\n\n      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n      if (texData.encoding !== undefined) {\n        texture.encoding = texData.encoding;\n      }\n\n      if (texData.flipY !== undefined) {\n        texture.flipY = texData.flipY;\n      }\n\n      if (texData.format !== undefined) {\n        texture.format = texData.format;\n      }\n\n      if (texData.type !== undefined) {\n        texture.type = texData.type;\n      }\n\n      if (texData.mipmaps !== undefined) {\n        texture.mipmaps = texData.mipmaps;\n        texture.minFilter = LinearMipmapLinearFilter; // presumably...\n      }\n\n      if (texData.mipmapCount === 1) {\n        texture.minFilter = LinearFilter;\n      }\n\n      if (texData.generateMipmaps !== undefined) {\n        texture.generateMipmaps = texData.generateMipmaps;\n      }\n\n      texture.needsUpdate = true;\n      if (onLoad) onLoad(texture, texData);\n    }, onProgress, onError);\n    return texture;\n  }\n\n}\n\nclass TextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const texture = new Texture$1();\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    loader.load(url, function (image) {\n      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\n      const isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n      texture.format = isJPEG ? RGBFormat : RGBAFormat;\n      texture.needsUpdate = true;\n\n      if (onLoad !== undefined) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  }\n\n}\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\n\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n    this.type = 'CurvePath';\n    this.curves = [];\n    this.autoClose = false; // Automatically closes the path\n  }\n\n  add(curve) {\n    this.curves.push(curve);\n  }\n\n  closePath() {\n    // Add a line curve if start and end of lines are not connected\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new LineCurve(endPoint, startPoint));\n    }\n  } // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n\n\n  getPoint(t) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0; // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u);\n      }\n\n      i++;\n    }\n\n    return null; // loop where sum != 0, sum > d , sum+1 <d\n  } // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n\n\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  } // cacheLengths must be recalculated.\n\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  } // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\n  getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    } // Get length of sub-curve\n    // Push sums into cached array\n\n\n    const lengths = [];\n    let sums = 0;\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n\n    this.cacheLengths = lengths;\n    return lengths;\n  }\n\n  getSpacedPoints(divisions = 40) {\n    const points = [];\n\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  getPoints(divisions = 12) {\n    const points = [];\n    let last;\n\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      const pts = curve.getPoints(resolution);\n\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.curves = [];\n\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n\n    this.autoClose = source.autoClose;\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.autoClose = this.autoClose;\n    data.curves = [];\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n\n    return this;\n  }\n\n}\n\nclass Path extends CurvePath {\n  constructor(points) {\n    super();\n    this.type = 'Path';\n    this.currentPoint = new Vector2();\n\n    if (points) {\n      this.setFromPoints(points);\n    }\n  }\n\n  setFromPoints(points) {\n    this.moveTo(points[0].x, points[0].y);\n\n    for (let i = 1, l = points.length; i < l; i++) {\n      this.lineTo(points[i].x, points[i].y);\n    }\n\n    return this;\n  }\n\n  moveTo(x, y) {\n    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n    return this;\n  }\n\n  lineTo(x, y) {\n    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n    this.curves.push(curve);\n    this.currentPoint.set(x, y);\n    return this;\n  }\n\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  }\n\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  }\n\n  splineThru(pts\n  /*Array of Vector*/\n  ) {\n    const npts = [this.currentPoint.clone()].concat(pts);\n    const curve = new SplineCurve(npts);\n    this.curves.push(curve);\n    this.currentPoint.copy(pts[pts.length - 1]);\n    return this;\n  }\n\n  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  }\n\n  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  }\n\n  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n    return this;\n  }\n\n  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n    if (this.curves.length > 0) {\n      // if a previous curve is present, attempt to join\n      const firstPoint = curve.getPoint(0);\n\n      if (!firstPoint.equals(this.currentPoint)) {\n        this.lineTo(firstPoint.x, firstPoint.y);\n      }\n    }\n\n    this.curves.push(curve);\n    const lastPoint = curve.getPoint(1);\n    this.currentPoint.copy(lastPoint);\n    return this;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.currentPoint.copy(source.currentPoint);\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.currentPoint = this.currentPoint.toArray();\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.currentPoint.fromArray(json.currentPoint);\n    return this;\n  }\n\n}\n\nclass Shape extends Path {\n  constructor(points) {\n    super(points);\n    this.uuid = generateUUID();\n    this.type = 'Shape';\n    this.holes = [];\n  }\n\n  getPointsHoles(divisions) {\n    const holesPts = [];\n\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      holesPts[i] = this.holes[i].getPoints(divisions);\n    }\n\n    return holesPts;\n  } // get points of shape and holes (keypoints based on segments parameter)\n\n\n  extractPoints(divisions) {\n    return {\n      shape: this.getPoints(divisions),\n      holes: this.getPointsHoles(divisions)\n    };\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.holes = [];\n\n    for (let i = 0, l = source.holes.length; i < l; i++) {\n      const hole = source.holes[i];\n      this.holes.push(hole.clone());\n    }\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.uuid = this.uuid;\n    data.holes = [];\n\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      const hole = this.holes[i];\n      data.holes.push(hole.toJSON());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.uuid = json.uuid;\n    this.holes = [];\n\n    for (let i = 0, l = json.holes.length; i < l; i++) {\n      const hole = json.holes[i];\n      this.holes.push(new Path().fromJSON(hole));\n    }\n\n    return this;\n  }\n\n}\n\nclass Light extends Object3D {\n  constructor(color, intensity = 1) {\n    super();\n    this.type = 'Light';\n    this.color = new Color(color);\n    this.intensity = intensity;\n  }\n\n  dispose() {// Empty here in base class; some subclasses override.\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.intensity = source.intensity;\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.color = this.color.getHex();\n    data.object.intensity = this.intensity;\n    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();\n    if (this.distance !== undefined) data.object.distance = this.distance;\n    if (this.angle !== undefined) data.object.angle = this.angle;\n    if (this.decay !== undefined) data.object.decay = this.decay;\n    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n    return data;\n  }\n\n}\n\nLight.prototype.isLight = true;\n\nclass HemisphereLight extends Light {\n  constructor(skyColor, groundColor, intensity) {\n    super(skyColor, intensity);\n    this.type = 'HemisphereLight';\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n    this.groundColor = new Color(groundColor);\n  }\n\n  copy(source) {\n    Light.prototype.copy.call(this, source);\n    this.groundColor.copy(source.groundColor);\n    return this;\n  }\n\n}\n\nHemisphereLight.prototype.isHemisphereLight = true;\n\nconst _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();\n\nconst _lightPositionWorld$1 = /*@__PURE__*/new Vector3();\n\nconst _lookTarget$1 = /*@__PURE__*/new Vector3();\n\nclass LightShadow {\n  constructor(camera) {\n    this.camera = camera;\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    this.mapSize = new Vector2(512, 512);\n    this.map = null;\n    this.mapPass = null;\n    this.matrix = new Matrix4();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n    this._viewportCount = 1;\n    this._viewports = [new Vector4(0, 0, 1, 1)];\n  }\n\n  getViewportCount() {\n    return this._viewportCount;\n  }\n\n  getFrustum() {\n    return this._frustum;\n  }\n\n  updateMatrices(light) {\n    const shadowCamera = this.camera;\n    const shadowMatrix = this.matrix;\n\n    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n\n    shadowCamera.position.copy(_lightPositionWorld$1);\n\n    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n\n    shadowCamera.lookAt(_lookTarget$1);\n    shadowCamera.updateMatrixWorld();\n\n    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n\n    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    shadowMatrix.multiply(shadowCamera.projectionMatrix);\n    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n  }\n\n  getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  }\n\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n\n  dispose() {\n    if (this.map) {\n      this.map.dispose();\n    }\n\n    if (this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n\n  copy(source) {\n    this.camera = source.camera.clone();\n    this.bias = source.bias;\n    this.radius = source.radius;\n    this.mapSize.copy(source.mapSize);\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  toJSON() {\n    const object = {};\n    if (this.bias !== 0) object.bias = this.bias;\n    if (this.normalBias !== 0) object.normalBias = this.normalBias;\n    if (this.radius !== 1) object.radius = this.radius;\n    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n    object.camera = this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n    return object;\n  }\n\n}\n\nclass SpotLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(50, 1, 0.5, 500));\n    this.focus = 1;\n  }\n\n  updateMatrices(light) {\n    const camera = this.camera;\n    const fov = RAD2DEG * 2 * light.angle * this.focus;\n    const aspect = this.mapSize.width / this.mapSize.height;\n    const far = light.distance || camera.far;\n\n    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n      camera.fov = fov;\n      camera.aspect = aspect;\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n\n    super.updateMatrices(light);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.focus = source.focus;\n    return this;\n  }\n\n}\n\nSpotLightShadow.prototype.isSpotLightShadow = true;\n\nclass SpotLight extends Light {\n  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {\n    super(color, intensity);\n    this.type = 'SpotLight';\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.distance = distance;\n    this.angle = angle;\n    this.penumbra = penumbra;\n    this.decay = decay; // for physically correct lights, should be 2.\n\n    this.shadow = new SpotLightShadow();\n  }\n\n  get power() {\n    // intensity = power per solid angle.\n    // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    return this.intensity * Math.PI;\n  }\n\n  set power(power) {\n    // intensity = power per solid angle.\n    // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    this.intensity = power / Math.PI;\n  }\n\n  dispose() {\n    this.shadow.dispose();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.distance = source.distance;\n    this.angle = source.angle;\n    this.penumbra = source.penumbra;\n    this.decay = source.decay;\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n\n}\n\nSpotLight.prototype.isSpotLight = true;\n\nconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\n\nconst _lightPositionWorld = /*@__PURE__*/new Vector3();\n\nconst _lookTarget = /*@__PURE__*/new Vector3();\n\nclass PointLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(90, 1, 0.5, 500));\n    this._frameExtents = new Vector2(4, 2);\n    this._viewportCount = 6;\n    this._viewports = [// These viewports map a cube-map onto a 2D texture with the\n    // following orientation:\n    //\n    //  xzXZ\n    //   y Y\n    //\n    // X - Positive x direction\n    // x - Negative x direction\n    // Y - Positive y direction\n    // y - Negative y direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    // positive X\n    new Vector4(2, 1, 1, 1), // negative X\n    new Vector4(0, 1, 1, 1), // positive Z\n    new Vector4(3, 1, 1, 1), // negative Z\n    new Vector4(1, 1, 1, 1), // positive Y\n    new Vector4(3, 0, 1, 1), // negative Y\n    new Vector4(1, 0, 1, 1)];\n    this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];\n    this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];\n  }\n\n  updateMatrices(light, viewportIndex = 0) {\n    const camera = this.camera;\n    const shadowMatrix = this.matrix;\n    const far = light.distance || camera.far;\n\n    if (far !== camera.far) {\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n\n    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n\n    camera.position.copy(_lightPositionWorld);\n\n    _lookTarget.copy(camera.position);\n\n    _lookTarget.add(this._cubeDirections[viewportIndex]);\n\n    camera.up.copy(this._cubeUps[viewportIndex]);\n    camera.lookAt(_lookTarget);\n    camera.updateMatrixWorld();\n    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n  }\n\n}\n\nPointLightShadow.prototype.isPointLightShadow = true;\n\nclass PointLight extends Light {\n  constructor(color, intensity, distance = 0, decay = 1) {\n    super(color, intensity);\n    this.type = 'PointLight';\n    this.distance = distance;\n    this.decay = decay; // for physically correct lights, should be 2.\n\n    this.shadow = new PointLightShadow();\n  }\n\n  get power() {\n    // intensity = power per solid angle.\n    // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    return this.intensity * 4 * Math.PI;\n  }\n\n  set power(power) {\n    // intensity = power per solid angle.\n    // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    this.intensity = power / (4 * Math.PI);\n  }\n\n  dispose() {\n    this.shadow.dispose();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.distance = source.distance;\n    this.decay = source.decay;\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n\n}\n\nPointLight.prototype.isPointLight = true;\n\nclass DirectionalLightShadow extends LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n  }\n\n}\n\nDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\nclass DirectionalLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.type = 'DirectionalLight';\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.shadow = new DirectionalLightShadow();\n  }\n\n  dispose() {\n    this.shadow.dispose();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n\n}\n\nDirectionalLight.prototype.isDirectionalLight = true;\n\nclass AmbientLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.type = 'AmbientLight';\n  }\n\n}\n\nAmbientLight.prototype.isAmbientLight = true;\n\nclass RectAreaLight extends Light {\n  constructor(color, intensity, width = 10, height = 10) {\n    super(color, intensity);\n    this.type = 'RectAreaLight';\n    this.width = width;\n    this.height = height;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.width = source.width;\n    this.height = source.height;\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.width = this.width;\n    data.object.height = this.height;\n    return data;\n  }\n\n}\n\nRectAreaLight.prototype.isRectAreaLight = true;\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n  constructor() {\n    this.coefficients = [];\n\n    for (let i = 0; i < 9; i++) {\n      this.coefficients.push(new Vector3());\n    }\n  }\n\n  set(coefficients) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].copy(coefficients[i]);\n    }\n\n    return this;\n  }\n\n  zero() {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].set(0, 0, 0);\n    }\n\n    return this;\n  } // get the radiance in the direction of the normal\n  // target is a Vector3\n\n\n  getAt(normal, target) {\n    // normal is assumed to be unit length\n    const x = normal.x,\n          y = normal.y,\n          z = normal.z;\n    const coeff = this.coefficients; // band 0\n\n    target.copy(coeff[0]).multiplyScalar(0.282095); // band 1\n\n    target.addScaledVector(coeff[1], 0.488603 * y);\n    target.addScaledVector(coeff[2], 0.488603 * z);\n    target.addScaledVector(coeff[3], 0.488603 * x); // band 2\n\n    target.addScaledVector(coeff[4], 1.092548 * (x * y));\n    target.addScaledVector(coeff[5], 1.092548 * (y * z));\n    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n    target.addScaledVector(coeff[7], 1.092548 * (x * z));\n    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n    return target;\n  } // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n  // target is a Vector3\n  // https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n\n  getIrradianceAt(normal, target) {\n    // normal is assumed to be unit length\n    const x = normal.x,\n          y = normal.y,\n          z = normal.z;\n    const coeff = this.coefficients; // band 0\n\n    target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095\n    // band 1\n\n    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603\n\n    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2\n\n    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548\n\n    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3\n\n    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274\n\n    return target;\n  }\n\n  add(sh) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].add(sh.coefficients[i]);\n    }\n\n    return this;\n  }\n\n  addScaledSH(sh, s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].addScaledVector(sh.coefficients[i], s);\n    }\n\n    return this;\n  }\n\n  scale(s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].multiplyScalar(s);\n    }\n\n    return this;\n  }\n\n  lerp(sh, alpha) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].lerp(sh.coefficients[i], alpha);\n    }\n\n    return this;\n  }\n\n  equals(sh) {\n    for (let i = 0; i < 9; i++) {\n      if (!this.coefficients[i].equals(sh.coefficients[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  copy(sh) {\n    return this.set(sh.coefficients);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(array, offset = 0) {\n    const coefficients = this.coefficients;\n\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].fromArray(array, offset + i * 3);\n    }\n\n    return this;\n  }\n\n  toArray(array = [], offset = 0) {\n    const coefficients = this.coefficients;\n\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].toArray(array, offset + i * 3);\n    }\n\n    return array;\n  } // evaluate the basis functions\n  // shBasis is an Array[ 9 ]\n\n\n  static getBasisAt(normal, shBasis) {\n    // normal is assumed to be unit length\n    const x = normal.x,\n          y = normal.y,\n          z = normal.z; // band 0\n\n    shBasis[0] = 0.282095; // band 1\n\n    shBasis[1] = 0.488603 * y;\n    shBasis[2] = 0.488603 * z;\n    shBasis[3] = 0.488603 * x; // band 2\n\n    shBasis[4] = 1.092548 * x * y;\n    shBasis[5] = 1.092548 * y * z;\n    shBasis[6] = 0.315392 * (3 * z * z - 1);\n    shBasis[7] = 1.092548 * x * z;\n    shBasis[8] = 0.546274 * (x * x - y * y);\n  }\n\n}\n\nSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\nclass LightProbe extends Light {\n  constructor(sh = new SphericalHarmonics3(), intensity = 1) {\n    super(undefined, intensity);\n    this.sh = sh;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.sh.copy(source.sh);\n    return this;\n  }\n\n  fromJSON(json) {\n    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\n    this.sh.fromArray(json.sh);\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.sh = this.sh.toArray();\n    return data;\n  }\n\n}\n\nLightProbe.prototype.isLightProbe = true;\n\nclass LoaderUtils {\n  static decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n      return new TextDecoder().decode(array);\n    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n    // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\n    let s = '';\n\n    for (let i = 0, il = array.length; i < il; i++) {\n      // Implicitly assumes little-endian.\n      s += String.fromCharCode(array[i]);\n    }\n\n    try {\n      // merges multi-byte utf-8 characters.\n      return decodeURIComponent(escape(s));\n    } catch (e) {\n      // see #16358\n      return s;\n    }\n  }\n\n  static extractUrlBase(url) {\n    const index = url.lastIndexOf('/');\n    if (index === -1) return './';\n    return url.substr(0, index + 1);\n  }\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n  constructor() {\n    super();\n    this.type = 'InstancedBufferGeometry';\n    this.instanceCount = Infinity;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.instanceCount = source.instanceCount;\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  toJSON() {\n    const data = super.toJSON(this);\n    data.instanceCount = this.instanceCount;\n    data.isInstancedBufferGeometry = true;\n    return data;\n  }\n\n}\n\nInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\nclass InstancedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized, meshPerAttribute = 1) {\n    if (typeof normalized === 'number') {\n      meshPerAttribute = normalized;\n      normalized = false;\n      console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');\n    }\n\n    super(array, itemSize, normalized);\n    this.meshPerAttribute = meshPerAttribute;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.meshPerAttribute = this.meshPerAttribute;\n    data.isInstancedBufferAttribute = true;\n    return data;\n  }\n\n}\n\nInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\nclass ImageBitmapLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n\n    if (typeof createImageBitmap === 'undefined') {\n      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');\n    }\n\n    if (typeof fetch === 'undefined') {\n      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');\n    }\n\n    this.options = {\n      premultiplyAlpha: 'none'\n    };\n  }\n\n  setOptions(options) {\n    this.options = options;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n\n    const fetchOptions = {};\n    fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';\n    fetchOptions.headers = this.requestHeader;\n    fetch(url, fetchOptions).then(function (res) {\n      return res.blob();\n    }).then(function (blob) {\n      return createImageBitmap(blob, Object.assign(scope.options, {\n        colorSpaceConversion: 'none'\n      }));\n    }).then(function (imageBitmap) {\n      Cache.add(url, imageBitmap);\n      if (onLoad) onLoad(imageBitmap);\n      scope.manager.itemEnd(url);\n    }).catch(function (e) {\n      if (onError) onError(e);\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    });\n    scope.manager.itemStart(url);\n  }\n\n}\n\nImageBitmapLoader.prototype.isImageBitmapLoader = true;\n\nlet _context;\n\nconst AudioContext = {\n  getContext: function () {\n    if (_context === undefined) {\n      _context = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    return _context;\n  },\n  setContext: function (value) {\n    _context = value;\n  }\n};\n\nclass AudioLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        // Create a copy of the buffer. The `decodeAudioData` method\n        // detaches the buffer when complete, preventing reuse.\n        const bufferCopy = buffer.slice(0);\n        const context = AudioContext.getContext();\n        context.decodeAudioData(bufferCopy, function (audioBuffer) {\n          onLoad(audioBuffer);\n        });\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n}\n\nclass HemisphereLightProbe extends LightProbe {\n  constructor(skyColor, groundColor, intensity = 1) {\n    super(undefined, intensity);\n    const color1 = new Color().set(skyColor);\n    const color2 = new Color().set(groundColor);\n    const sky = new Vector3(color1.r, color1.g, color1.b);\n    const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\n    const c0 = Math.sqrt(Math.PI);\n    const c1 = c0 * Math.sqrt(0.75);\n    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n  }\n\n}\n\nHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\nclass AmbientLightProbe extends LightProbe {\n  constructor(color, intensity = 1) {\n    super(undefined, intensity);\n    const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\n    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\n  }\n\n}\n\nAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\nclass Audio extends Object3D {\n  constructor(listener) {\n    super();\n    this.type = 'Audio';\n    this.listener = listener;\n    this.context = listener.context;\n    this.gain = this.context.createGain();\n    this.gain.connect(listener.getInput());\n    this.autoplay = false;\n    this.buffer = null;\n    this.detune = 0;\n    this.loop = false;\n    this.loopStart = 0;\n    this.loopEnd = 0;\n    this.offset = 0;\n    this.duration = undefined;\n    this.playbackRate = 1;\n    this.isPlaying = false;\n    this.hasPlaybackControl = true;\n    this.source = null;\n    this.sourceType = 'empty';\n    this._startedAt = 0;\n    this._progress = 0;\n    this._connected = false;\n    this.filters = [];\n  }\n\n  getOutput() {\n    return this.gain;\n  }\n\n  setNodeSource(audioNode) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'audioNode';\n    this.source = audioNode;\n    this.connect();\n    return this;\n  }\n\n  setMediaElementSource(mediaElement) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'mediaNode';\n    this.source = this.context.createMediaElementSource(mediaElement);\n    this.connect();\n    return this;\n  }\n\n  setMediaStreamSource(mediaStream) {\n    this.hasPlaybackControl = false;\n    this.sourceType = 'mediaStreamNode';\n    this.source = this.context.createMediaStreamSource(mediaStream);\n    this.connect();\n    return this;\n  }\n\n  setBuffer(audioBuffer) {\n    this.buffer = audioBuffer;\n    this.sourceType = 'buffer';\n    if (this.autoplay) this.play();\n    return this;\n  }\n\n  play(delay = 0) {\n    if (this.isPlaying === true) {\n      console.warn('THREE.Audio: Audio is already playing.');\n      return;\n    }\n\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this._startedAt = this.context.currentTime + delay;\n    const source = this.context.createBufferSource();\n    source.buffer = this.buffer;\n    source.loop = this.loop;\n    source.loopStart = this.loopStart;\n    source.loopEnd = this.loopEnd;\n    source.onended = this.onEnded.bind(this);\n    source.start(this._startedAt, this._progress + this.offset, this.duration);\n    this.isPlaying = true;\n    this.source = source;\n    this.setDetune(this.detune);\n    this.setPlaybackRate(this.playbackRate);\n    return this.connect();\n  }\n\n  pause() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    if (this.isPlaying === true) {\n      // update current progress\n      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n\n      if (this.loop === true) {\n        // ensure _progress does not exceed duration with looped audios\n        this._progress = this._progress % (this.duration || this.buffer.duration);\n      }\n\n      this.source.stop();\n      this.source.onended = null;\n      this.isPlaying = false;\n    }\n\n    return this;\n  }\n\n  stop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this._progress = 0;\n    this.source.stop();\n    this.source.onended = null;\n    this.isPlaying = false;\n    return this;\n  }\n\n  connect() {\n    if (this.filters.length > 0) {\n      this.source.connect(this.filters[0]);\n\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].connect(this.filters[i]);\n      }\n\n      this.filters[this.filters.length - 1].connect(this.getOutput());\n    } else {\n      this.source.connect(this.getOutput());\n    }\n\n    this._connected = true;\n    return this;\n  }\n\n  disconnect() {\n    if (this.filters.length > 0) {\n      this.source.disconnect(this.filters[0]);\n\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].disconnect(this.filters[i]);\n      }\n\n      this.filters[this.filters.length - 1].disconnect(this.getOutput());\n    } else {\n      this.source.disconnect(this.getOutput());\n    }\n\n    this._connected = false;\n    return this;\n  }\n\n  getFilters() {\n    return this.filters;\n  }\n\n  setFilters(value) {\n    if (!value) value = [];\n\n    if (this._connected === true) {\n      this.disconnect();\n      this.filters = value.slice();\n      this.connect();\n    } else {\n      this.filters = value.slice();\n    }\n\n    return this;\n  }\n\n  setDetune(value) {\n    this.detune = value;\n    if (this.source.detune === undefined) return; // only set detune when available\n\n    if (this.isPlaying === true) {\n      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n    }\n\n    return this;\n  }\n\n  getDetune() {\n    return this.detune;\n  }\n\n  getFilter() {\n    return this.getFilters()[0];\n  }\n\n  setFilter(filter) {\n    return this.setFilters(filter ? [filter] : []);\n  }\n\n  setPlaybackRate(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this.playbackRate = value;\n\n    if (this.isPlaying === true) {\n      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n    }\n\n    return this;\n  }\n\n  getPlaybackRate() {\n    return this.playbackRate;\n  }\n\n  onEnded() {\n    this.isPlaying = false;\n  }\n\n  getLoop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return false;\n    }\n\n    return this.loop;\n  }\n\n  setLoop(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn('THREE.Audio: this Audio has no playback control.');\n      return;\n    }\n\n    this.loop = value;\n\n    if (this.isPlaying === true) {\n      this.source.loop = this.loop;\n    }\n\n    return this;\n  }\n\n  setLoopStart(value) {\n    this.loopStart = value;\n    return this;\n  }\n\n  setLoopEnd(value) {\n    this.loopEnd = value;\n    return this;\n  }\n\n  getVolume() {\n    return this.gain.gain.value;\n  }\n\n  setVolume(value) {\n    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n    return this;\n  }\n\n}\n\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n    let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to 'incoming'\n    //\n    // 'accu0' and 'accu1' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // 'orig' stores the original state of the property\n    //\n    // 'add' is used for additive cumulative results\n    //\n    // 'work' is optional and is only present for quaternion types. It is used\n    // to store intermediate quaternion multiplication results\n\n    switch (typeName) {\n      case 'quaternion':\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n\n      case 'string':\n      case 'bool':\n        mixFunction = this._select; // Use the regular mix function and for additive on these types,\n        // additive is not relevant for non-numeric types\n\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  } // accumulate data in the 'incoming' region into 'accu<i>'\n\n\n  accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n    const buffer = this.buffer,\n          stride = this.valueSize,\n          offset = accuIndex * stride + stride;\n    let currentWeight = this.cumulativeWeight;\n\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n\n    this.cumulativeWeight = currentWeight;\n  } // accumulate data in the 'incoming' region into 'add'\n\n\n  accumulateAdditive(weight) {\n    const buffer = this.buffer,\n          stride = this.valueSize,\n          offset = stride * this._addIndex;\n\n    if (this.cumulativeWeightAdditive === 0) {\n      // add = identity\n      this._setIdentity();\n    } // add := add + incoming * weight\n\n\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n    this.cumulativeWeightAdditive += weight;\n  } // apply the state of 'accu<i>' to the binding when accus differ\n\n\n  apply(accuIndex) {\n    const stride = this.valueSize,\n          buffer = this.buffer,\n          offset = accuIndex * stride + stride,\n          weight = this.cumulativeWeight,\n          weightAdditive = this.cumulativeWeightAdditive,\n          binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n      const originalValueOffset = stride * this._origIndex;\n\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n\n    if (weightAdditive > 0) {\n      // accuN := accuN + additive accuN\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  } // remember the state of the bound property and copy it to both accus\n\n\n  saveOriginalState() {\n    const binding = this.binding;\n    const buffer = this.buffer,\n          stride = this.valueSize,\n          originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    } // Add to identity for additive\n\n\n    this._setIdentity();\n\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  } // apply the state previously taken via 'saveOriginalState' to the binding\n\n\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  } // mix functions\n\n\n  _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n\n  _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  }\n\n  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n  }\n\n  _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    const s = 1 - t;\n\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n\n  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n\n} // Characters [].:/ are reserved for track binding syntax.\n\n\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\nconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\n\n\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\n\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\n\n\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\n\nconst _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\n\n\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\n\n\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\nconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\n\nconst _supportedObjectNames = ['material', 'materials', 'bones'];\n\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n\n  getValue(array, offset) {\n    this.bind(); // bind all binding\n\n    const firstValidIndex = this._targetGroup.nCachedObjects_,\n          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n    if (binding !== undefined) binding.getValue(array, offset);\n  }\n\n  setValue(array, offset) {\n    const bindings = this._bindings;\n\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n\n  bind() {\n    const bindings = this._bindings;\n\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  }\n\n  unbind() {\n    const bindings = this._bindings;\n\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n\n} // Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\n\n\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n    this.rootNode = rootNode; // initial state of these methods that calls 'bind'\n\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n  /**\n   * Replaces spaces with underscores and removes unsupported characters from\n   * node names, to ensure compatibility with parseTrackName().\n   *\n   * @param {string} name Node name to be sanitized.\n   * @return {string}\n   */\n\n\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, '_').replace(_reservedRe, '');\n  }\n\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n\n    if (!matches) {\n      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n    }\n\n    const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      // required\n      propertyIndex: matches[6]\n    };\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n    if (lastDot !== undefined && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n      // 'bar' could be the objectName, or part of a nodeName (which can\n      // include '.' characters).\n\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n    }\n\n    return results;\n  }\n\n  static findNode(root, nodeName) {\n    if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    } // search into skeleton bones.\n\n\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n\n      if (bone !== undefined) {\n        return bone;\n      }\n    } // search into node subtree.\n\n\n    if (root.children) {\n      const searchNodeSubtree = function (children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n\n          const result = searchNodeSubtree(childNode.children);\n          if (result) return result;\n        }\n\n        return null;\n      };\n\n      const subTreeNode = searchNodeSubtree(root.children);\n\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n\n    return null;\n  } // these are used to \"bind\" a nonexistent property\n\n\n  _getValue_unavailable() {}\n\n  _setValue_unavailable() {} // Getters\n\n\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.node[this.propertyName];\n  }\n\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  } // Direct\n\n\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  } // EntireArray\n\n\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  } // ArrayElement\n\n\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  } // HasToFromArray\n\n\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  } // create getter / setter pair for a property in the scene graph\n\n\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n      this.node = targetObject;\n    } // set fail state so we can just 'return' on error\n\n\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable; // ensure there is a value node\n\n    if (!targetObject) {\n      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n      return;\n    }\n\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n      switch (objectName) {\n        case 'materials':\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n\n          if (!targetObject.material.materials) {\n            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n            return;\n          }\n\n          targetObject = targetObject.material.materials;\n          break;\n\n        case 'bones':\n          if (!targetObject.skeleton) {\n            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n            return;\n          } // potential future optimization: skip this if propertyIndex is already an integer\n          // and convert the integer string to a true integer.\n\n\n          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n\n          break;\n\n        default:\n          if (targetObject[objectName] === undefined) {\n            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n            return;\n          }\n\n          targetObject = targetObject[objectName];\n      }\n\n      if (objectIndex !== undefined) {\n        if (targetObject[objectIndex] === undefined) {\n          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n          return;\n        }\n\n        targetObject = targetObject[objectIndex];\n      }\n    } // resolve property\n\n\n    const nodeProperty = targetObject[propertyName];\n\n    if (nodeProperty === undefined) {\n      const nodeName = parsedPath.nodeName;\n      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n      return;\n    } // determine versioning scheme\n\n\n    let versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n\n    if (targetObject.needsUpdate !== undefined) {\n      // material\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n      // node transform\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    } // determine how the property gets bound\n\n\n    let bindingType = this.BindingType.Direct;\n\n    if (propertyIndex !== undefined) {\n      // access a sub element of the property array (only primitives are supported right now)\n      if (propertyName === 'morphTargetInfluences') {\n        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n        // support resolving morphTarget names into indices.\n        if (!targetObject.geometry) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n          return;\n        }\n\n        if (targetObject.geometry.isBufferGeometry) {\n          if (!targetObject.geometry.morphAttributes) {\n            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n            return;\n          }\n\n          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n          }\n        } else {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);\n          return;\n        }\n      }\n\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n      // must use copy for Object3D.Euler/Quaternion\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    } // select getter / setter\n\n\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n\n  unbind() {\n    this.node = null; // back to the prototype version of getValue / setValue\n    // note: avoiding to mutate the shape of 'this' via 'delete'\n\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n\n}\n\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct\nPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray\nPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement\nPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray\nPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\n\nclass AnimationAction {\n  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot;\n    this.blendMode = blendMode;\n    const tracks = clip.tracks,\n          nTracks = tracks.length,\n          interpolants = new Array(nTracks);\n    const interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n\n    for (let i = 0; i !== nTracks; ++i) {\n      const interpolant = tracks[i].createInterpolant(null);\n      interpolants[i] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n\n    this._interpolantSettings = interpolantSettings;\n    this._interpolants = interpolants; // bound by the mixer\n    // inside: PropertyMixer (managed by the mixer)\n\n    this._propertyBindings = new Array(nTracks);\n    this._cacheIndex = null; // for the memory manager\n\n    this._byClipCacheIndex = null; // for the memory manager\n\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n    this.loop = LoopRepeat;\n    this._loopCount = -1; // global mixer time when the action is to be started\n    // it's set back to 'null' upon start of the action\n\n    this._startTime = null; // scaled local time of the action\n    // gets clamped or wrapped to 0..clip.duration according to loop\n\n    this.time = 0;\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n    this.weight = 1;\n    this._effectiveWeight = 1;\n    this.repetitions = Infinity; // no. of repetitions when looping\n\n    this.paused = false; // true -> zero effective time scale\n\n    this.enabled = true; // false -> zero effective weight\n\n    this.clampWhenFinished = false; // keep feeding the last frame?\n\n    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n    this.zeroSlopeAtEnd = true; // clips for start, loop and end\n  } // State & Scheduling\n\n\n  play() {\n    this._mixer._activateAction(this);\n\n    return this;\n  }\n\n  stop() {\n    this._mixer._deactivateAction(this);\n\n    return this.reset();\n  }\n\n  reset() {\n    this.paused = false;\n    this.enabled = true;\n    this.time = 0; // restart clip\n\n    this._loopCount = -1; // forget previous loops\n\n    this._startTime = null; // forget scheduling\n\n    return this.stopFading().stopWarping();\n  }\n\n  isRunning() {\n    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n  } // return true when play has been called\n\n\n  isScheduled() {\n    return this._mixer._isActiveAction(this);\n  }\n\n  startAt(time) {\n    this._startTime = time;\n    return this;\n  }\n\n  setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n    return this;\n  } // Weight\n  // set the weight stopping any scheduled fading\n  // although .enabled = false yields an effective weight of zero, this\n  // method does *not* change .enabled, because it would be confusing\n\n\n  setEffectiveWeight(weight) {\n    this.weight = weight; // note: same logic as when updated at runtime\n\n    this._effectiveWeight = this.enabled ? weight : 0;\n    return this.stopFading();\n  } // return the weight considering fading and .enabled\n\n\n  getEffectiveWeight() {\n    return this._effectiveWeight;\n  }\n\n  fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  }\n\n  fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  }\n\n  crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n\n    if (warp) {\n      const fadeInDuration = this._clip.duration,\n            fadeOutDuration = fadeOutAction._clip.duration,\n            startEndRatio = fadeOutDuration / fadeInDuration,\n            endStartRatio = fadeInDuration / fadeOutDuration;\n      fadeOutAction.warp(1.0, startEndRatio, duration);\n      this.warp(endStartRatio, 1.0, duration);\n    }\n\n    return this;\n  }\n\n  crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  }\n\n  stopFading() {\n    const weightInterpolant = this._weightInterpolant;\n\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n\n    return this;\n  } // Time Scale Control\n  // set the time scale stopping any scheduled warping\n  // although .paused = true yields an effective time scale of zero, this\n  // method does *not* change .paused, because it would be confusing\n\n\n  setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n    return this.stopWarping();\n  } // return the time scale considering warping and .paused\n\n\n  getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  }\n\n  setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n    return this.stopWarping();\n  }\n\n  syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n    return this.stopWarping();\n  }\n\n  halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  }\n\n  warp(startTimeScale, endTimeScale, duration) {\n    const mixer = this._mixer,\n          now = mixer.time,\n          timeScale = this.timeScale;\n    let interpolant = this._timeScaleInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n\n    const times = interpolant.parameterPositions,\n          values = interpolant.sampleValues;\n    times[0] = now;\n    times[1] = now + duration;\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n    return this;\n  }\n\n  stopWarping() {\n    const timeScaleInterpolant = this._timeScaleInterpolant;\n\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n\n    return this;\n  } // Object Accessors\n\n\n  getMixer() {\n    return this._mixer;\n  }\n\n  getClip() {\n    return this._clip;\n  }\n\n  getRoot() {\n    return this._localRoot || this._mixer._root;\n  } // Interna\n\n\n  _update(time, deltaTime, timeDirection, accuIndex) {\n    // called by the mixer\n    if (!this.enabled) {\n      // call ._updateWeight() to update ._effectiveWeight\n      this._updateWeight(time);\n\n      return;\n    }\n\n    const startTime = this._startTime;\n\n    if (startTime !== null) {\n      // check for scheduled start of action\n      const timeRunning = (time - startTime) * timeDirection;\n\n      if (timeRunning < 0 || timeDirection === 0) {\n        return; // yet to come / don't decide when delta = 0\n      } // start\n\n\n      this._startTime = null; // unschedule\n\n      deltaTime = timeDirection * timeRunning;\n    } // apply time scale and advance time\n\n\n    deltaTime *= this._updateTimeScale(time);\n\n    const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n    // an effective weight of 0\n\n\n    const weight = this._updateWeight(time);\n\n    if (weight > 0) {\n      const interpolants = this._interpolants;\n      const propertyMixers = this._propertyBindings;\n\n      switch (this.blendMode) {\n        case AdditiveAnimationBlendMode:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulateAdditive(weight);\n          }\n\n          break;\n\n        case NormalAnimationBlendMode:\n        default:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulate(accuIndex, weight);\n          }\n\n      }\n    }\n  }\n\n  _updateWeight(time) {\n    let weight = 0;\n\n    if (this.enabled) {\n      weight = this.weight;\n      const interpolant = this._weightInterpolant;\n\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        weight *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n\n          if (interpolantValue === 0) {\n            // faded out, disable\n            this.enabled = false;\n          }\n        }\n      }\n    }\n\n    this._effectiveWeight = weight;\n    return weight;\n  }\n\n  _updateTimeScale(time) {\n    let timeScale = 0;\n\n    if (!this.paused) {\n      timeScale = this.timeScale;\n      const interpolant = this._timeScaleInterpolant;\n\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        timeScale *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n\n          if (timeScale === 0) {\n            // motion has halted, pause\n            this.paused = true;\n          } else {\n            // warp done - apply final time scale\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  }\n\n  _updateTime(deltaTime) {\n    const duration = this._clip.duration;\n    const loop = this.loop;\n    let time = this.time + deltaTime;\n    let loopCount = this._loopCount;\n    const pingPong = loop === LoopPingPong;\n\n    if (deltaTime === 0) {\n      if (loopCount === -1) return time;\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        // just started\n        this._loopCount = 0;\n\n        this._setEndings(true, true, false);\n      }\n\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n          break handle_stop;\n        }\n\n        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n        this.time = time;\n\n        this._mixer.dispatchEvent({\n          type: 'finished',\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1\n        });\n      }\n    } else {\n      // repetitive Repeat or PingPong\n      if (loopCount === -1) {\n        // just started\n        if (deltaTime >= 0) {\n          loopCount = 0;\n\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          // when looping in reverse direction, the initial\n          // transition through zero counts as a repetition,\n          // so leave loopCount at -1\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n\n      if (time >= duration || time < 0) {\n        // wrap around\n        const loopDelta = Math.floor(time / duration); // signed\n\n        time -= duration * loopDelta;\n        loopCount += Math.abs(loopDelta);\n        const pending = this.repetitions - loopCount;\n\n        if (pending <= 0) {\n          // have to stop (switch state, clamp time, fire event)\n          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n          time = deltaTime > 0 ? duration : 0;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'finished',\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1\n          });\n        } else {\n          // keep running\n          if (pending === 1) {\n            // entering the last round\n            const atStart = deltaTime < 0;\n\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n\n          this._loopCount = loopCount;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'loop',\n            action: this,\n            loopDelta: loopDelta\n          });\n        }\n      } else {\n        this.time = time;\n      }\n\n      if (pingPong && (loopCount & 1) === 1) {\n        // invert time for the \"pong round\"\n        return duration - time;\n      }\n    }\n\n    return time;\n  }\n\n  _setEndings(atStart, atEnd, pingPong) {\n    const settings = this._interpolantSettings;\n\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      // assuming for LoopOnce atStart == atEnd == true\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  }\n\n  _scheduleFading(duration, weightNow, weightThen) {\n    const mixer = this._mixer,\n          now = mixer.time;\n    let interpolant = this._weightInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n\n    const times = interpolant.parameterPositions,\n          values = interpolant.sampleValues;\n    times[0] = now;\n    values[0] = weightNow;\n    times[1] = now + duration;\n    values[1] = weightThen;\n    return this;\n  }\n\n}\n\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n\n    this._initMemoryManager();\n\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1.0;\n  }\n\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root,\n          tracks = action._clip.tracks,\n          nTracks = tracks.length,\n          bindings = action._propertyBindings,\n          interpolants = action._interpolants,\n          rootUuid = root.uuid,\n          bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i],\n            trackName = track.name;\n      let binding = bindingsByName[trackName];\n\n      if (binding !== undefined) {\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n\n          continue;\n        }\n\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n\n        this._addInactiveBinding(binding, rootUuid, trackName);\n\n        bindings[i] = binding;\n      }\n\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n        const rootUuid = (action._localRoot || this._root).uuid,\n              clipUuid = action._clip.uuid,\n              actionsForClip = this._actionsByClip[clipUuid];\n\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n\n      const bindings = action._propertyBindings; // increment reference counts / sort out state\n\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n\n          binding.saveOriginalState();\n        }\n      }\n\n      this._lendAction(action);\n    }\n  }\n\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n\n          this._takeBackBinding(binding);\n        }\n      }\n\n      this._takeBackAction(action);\n    }\n  } // Memory manager\n\n\n  _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n\n    this._nActiveActions = 0;\n    this._actionsByClip = {}; // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n\n        get inUse() {\n          return scope._nActiveActions;\n        }\n\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n\n      }\n    };\n  } // Memory management for AnimationAction objects\n\n\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions,\n          actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n\n  _removeInactiveAction(action) {\n    const actions = this._actions,\n          lastInactiveAction = actions[actions.length - 1],\n          cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid],\n          knownActionsForClip = actionsForClip.knownActions,\n          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n          byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot,\n          rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n\n    this._removeInactiveBindingsForAction(action);\n  }\n\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n    const actions = this._actions,\n          prevIndex = action._cacheIndex,\n          lastActiveIndex = this._nActiveActions++,\n          firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n\n  _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n    const actions = this._actions,\n          prevIndex = action._cacheIndex,\n          firstInactiveIndex = --this._nActiveActions,\n          lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  } // Memory management for PropertyMixer objects\n\n\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName,\n          bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings,\n          propBinding = binding.binding,\n          rootUuid = propBinding.rootNode.uuid,\n          trackName = propBinding.path,\n          bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid],\n          lastInactiveBinding = bindings[bindings.length - 1],\n          cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n\n  _lendBinding(binding) {\n    const bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          lastActiveIndex = this._nActiveBindings++,\n          firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n\n  _takeBackBinding(binding) {\n    const bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          firstInactiveIndex = --this._nActiveBindings,\n          lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  } // Memory management of Interpolants for weight and time scale\n\n\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants,\n          lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n\n    return interpolant;\n  }\n\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants,\n          prevIndex = interpolant.__cacheIndex,\n          firstInactiveIndex = --this._nActiveControlInterpolants,\n          lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  } // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n\n\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root,\n          rootUuid = root.uuid;\n    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n\n    if (actionsForClip !== undefined) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n\n      if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n        return existingAction;\n      } // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n\n\n      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    } // clip must be known when specified via string\n\n\n    if (clipObject === null) return null; // allocate all resources required to run it\n\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n    return newAction;\n  } // get an existing action\n\n\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root,\n          rootUuid = root.uuid,\n          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n          clipUuid = clipObject ? clipObject.uuid : clip,\n          actionsForClip = this._actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n\n    return null;\n  } // deactivates all previously scheduled actions\n\n\n  stopAllAction() {\n    const actions = this._actions,\n          nActions = this._nActiveActions;\n\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n\n    return this;\n  } // advance the time and update apply the animation\n\n\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions,\n          nActions = this._nActiveActions,\n          time = this.time += deltaTime,\n          timeDirection = Math.sign(deltaTime),\n          accuIndex = this._accuIndex ^= 1; // run active actions\n\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    } // update scene graph\n\n\n    const bindings = this._bindings,\n          nBindings = this._nActiveBindings;\n\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n\n    return this;\n  } // Allows you to seek to a specific time in an animation.\n\n\n  setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  } // return this mixer's root target object\n\n\n  getRoot() {\n    return this._root;\n  } // free all resources specific to a particular clip\n\n\n  uncacheClip(clip) {\n    const actions = this._actions,\n          clipUuid = clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n      const actionsToRemove = actionsForClip.knownActions;\n\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n\n        this._deactivateAction(action);\n\n        const cacheIndex = action._cacheIndex,\n              lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n\n        this._removeInactiveBindingsForAction(action);\n      }\n\n      delete actionsByClip[clipUuid];\n    }\n  } // free all resources specific to a particular root target object\n\n\n  uncacheRoot(root) {\n    const rootUuid = root.uuid,\n          actionsByClip = this._actionsByClip;\n\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot,\n            action = actionByRoot[rootUuid];\n\n      if (action !== undefined) {\n        this._deactivateAction(action);\n\n        this._removeInactiveAction(action);\n      }\n    }\n\n    const bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName !== undefined) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n\n        this._removeInactiveBinding(binding);\n      }\n    }\n  } // remove a targeted clip from the cache\n\n\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n\n    if (action !== null) {\n      this._deactivateAction(action);\n\n      this._removeInactiveAction(action);\n    }\n  }\n\n}\n\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n  constructor(array, stride, meshPerAttribute = 1) {\n    super(array, stride);\n    this.meshPerAttribute = meshPerAttribute;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n\n  clone(data) {\n    const ib = super.clone(data);\n    ib.meshPerAttribute = this.meshPerAttribute;\n    return ib;\n  }\n\n  toJSON(data) {\n    const json = super.toJSON(data);\n    json.isInstancedInterleavedBuffer = true;\n    json.meshPerAttribute = this.meshPerAttribute;\n    return json;\n  }\n\n}\n\nInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\nclass Raycaster {\n  constructor(origin, direction, near = 0, far = Infinity) {\n    this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n      Mesh: {},\n      Line: {\n        threshold: 1\n      },\n      LOD: {},\n      Points: {\n        threshold: 1\n      },\n      Sprite: {}\n    };\n  }\n\n  set(origin, direction) {\n    // direction is assumed to be normalized (for accurate distance calculations)\n    this.ray.set(origin, direction);\n  }\n\n  setFromCamera(coords, camera) {\n    if (camera && camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera && camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n    }\n  }\n\n  intersectObject(object, recursive = false, intersects = []) {\n    intersectObject(object, this, intersects, recursive);\n    intersects.sort(ascSort);\n    return intersects;\n  }\n\n  intersectObjects(objects, recursive = false, intersects = []) {\n    for (let i = 0, l = objects.length; i < l; i++) {\n      intersectObject(objects[i], this, intersects, recursive);\n    }\n\n    intersects.sort(ascSort);\n    return intersects;\n  }\n\n}\n\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\n\nfunction intersectObject(object, raycaster, intersects, recursive) {\n  if (object.layers.test(raycaster.layers)) {\n    object.raycast(raycaster, intersects);\n  }\n\n  if (recursive === true) {\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      intersectObject(children[i], raycaster, intersects, true);\n    }\n  }\n}\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\n\nclass Spherical {\n  constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    this.phi = phi; // polar angle\n\n    this.theta = theta; // azimuthal angle\n\n    return this;\n  }\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this;\n  } // restrict phi to be betwee EPS and PI-EPS\n\n\n  makeSafe() {\n    const EPS = 0.000001;\n    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n    return this;\n  }\n\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + y * y + z * z);\n\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x, z);\n      this.phi = Math.acos(clamp$1(y / this.radius, -1, 1));\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nclass ImmediateRenderObject extends Object3D {\n  constructor(material) {\n    super();\n    this.material = material;\n\n    this.render = function ()\n    /* renderCallback */\n    {};\n\n    this.hasPositions = false;\n    this.hasNormals = false;\n    this.hasColors = false;\n    this.hasUvs = false;\n    this.positionArray = null;\n    this.normalArray = null;\n    this.colorArray = null;\n    this.uvArray = null;\n    this.count = 0;\n  }\n\n}\n\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\nconst _vector$2 = /*@__PURE__*/new Vector3();\n\nconst _boneMatrix = /*@__PURE__*/new Matrix4();\n\nconst _matrixWorldInv = /*@__PURE__*/new Matrix4();\n\nclass SkeletonHelper extends LineSegments {\n  constructor(object) {\n    const bones = getBoneList(object);\n    const geometry = new BufferGeometry();\n    const vertices = [];\n    const colors = [];\n    const color1 = new Color(0, 0, 1);\n    const color2 = new Color(0, 1, 0);\n\n    for (let i = 0; i < bones.length; i++) {\n      const bone = bones[i];\n\n      if (bone.parent && bone.parent.isBone) {\n        vertices.push(0, 0, 0);\n        vertices.push(0, 0, 0);\n        colors.push(color1.r, color1.g, color1.b);\n        colors.push(color2.r, color2.g, color2.b);\n      }\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      depthTest: false,\n      depthWrite: false,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n    this.type = 'SkeletonHelper';\n    this.isSkeletonHelper = true;\n    this.root = object;\n    this.bones = bones;\n    this.matrix = object.matrixWorld;\n    this.matrixAutoUpdate = false;\n  }\n\n  updateMatrixWorld(force) {\n    const bones = this.bones;\n    const geometry = this.geometry;\n    const position = geometry.getAttribute('position');\n\n    _matrixWorldInv.copy(this.root.matrixWorld).invert();\n\n    for (let i = 0, j = 0; i < bones.length; i++) {\n      const bone = bones[i];\n\n      if (bone.parent && bone.parent.isBone) {\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n\n        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n\n        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n        j += 2;\n      }\n    }\n\n    geometry.getAttribute('position').needsUpdate = true;\n    super.updateMatrixWorld(force);\n  }\n\n}\n\nfunction getBoneList(object) {\n  const boneList = [];\n\n  if (object && object.isBone) {\n    boneList.push(object);\n  }\n\n  for (let i = 0; i < object.children.length; i++) {\n    boneList.push.apply(boneList, getBoneList(object.children[i]));\n  }\n\n  return boneList;\n}\n\nclass GridHelper extends LineSegments {\n  constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    const center = divisions / 2;\n    const step = size / divisions;\n    const halfSize = size / 2;\n    const vertices = [],\n          colors = [];\n\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n      vertices.push(-halfSize, 0, k, halfSize, 0, k);\n      vertices.push(k, 0, -halfSize, k, 0, halfSize);\n      const color = i === center ? color1 : color2;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n    }\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    super(geometry, material);\n    this.type = 'GridHelper';\n  }\n\n}\n\nconst _floatView = new Float32Array(1);\n\nconst _int32View = new Int32Array(_floatView.buffer);\n\nclass DataUtils {\n  // Converts float32 to float16 (stored as uint16 value).\n  static toHalfFloat(val) {\n    // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n    /* This method is faster than the OpenEXR implementation (very often\n    * used, eg. in Ogre), with the additional benefit of rounding, inspired\n    * by James Tursa?s half-precision code. */\n    _floatView[0] = val;\n    const x = _int32View[0];\n    let bits = x >> 16 & 0x8000;\n    /* Get the sign */\n\n    let m = x >> 12 & 0x07ff;\n    /* Keep one extra bit for rounding */\n\n    const e = x >> 23 & 0xff;\n    /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\n    \t* half, return signed zero. */\n\n    if (e < 103) return bits;\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n      \t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\n      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n    /* If exponent underflows but not too much, return a denormal */\n\n\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\n      \t* to 1, which is OK. */\n\n      bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n      return bits;\n    }\n\n    bits |= e - 112 << 10 | m >> 1;\n    /* Extra rounding. An overflow will set mantissa to 0 and increment\n    \t* the exponent, which is OK. */\n\n    bits += m & 1;\n    return bits;\n  }\n\n} //\n\n\nCurve.create = function (construct, getPoint) {\n  console.log('THREE.Curve.create() has been deprecated');\n  construct.prototype = Object.create(Curve.prototype);\n  construct.prototype.constructor = construct;\n  construct.prototype.getPoint = getPoint;\n  return construct;\n}; //\n\n\nPath.prototype.fromPoints = function (points) {\n  console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');\n  return this.setFromPoints(points);\n};\n\nGridHelper.prototype.setColors = function () {\n  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');\n};\n\nSkeletonHelper.prototype.update = function () {\n  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');\n}; //\n\n\nLoader.prototype.extractUrlBase = function (url) {\n  console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');\n  return LoaderUtils.extractUrlBase(url);\n};\n\nLoader.Handlers = {\n  add: function ()\n  /* regex, loader */\n  {\n    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');\n  },\n  get: function ()\n  /* file */\n  {\n    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');\n  }\n}; //\n\nBox3.prototype.center = function (optionalTarget) {\n  console.warn('THREE.Box3: .center() has been renamed to .getCenter().');\n  return this.getCenter(optionalTarget);\n};\n\nBox3.prototype.empty = function () {\n  console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\n  return this.isEmpty();\n};\n\nBox3.prototype.isIntersectionBox = function (box) {\n  console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');\n  return this.intersectsBox(box);\n};\n\nBox3.prototype.isIntersectionSphere = function (sphere) {\n  console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n  return this.intersectsSphere(sphere);\n};\n\nBox3.prototype.size = function (optionalTarget) {\n  console.warn('THREE.Box3: .size() has been renamed to .getSize().');\n  return this.getSize(optionalTarget);\n}; //\n\n\nSphere.prototype.empty = function () {\n  console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');\n  return this.isEmpty();\n}; //\n\n\nFrustum.prototype.setFromMatrix = function (m) {\n  console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');\n  return this.setFromProjectionMatrix(m);\n}; //\n\n\nMatrix3.prototype.flattenToArrayOffset = function (array, offset) {\n  console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n  return this.toArray(array, offset);\n};\n\nMatrix3.prototype.multiplyVector3 = function (vector) {\n  console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\n  return vector.applyMatrix3(this);\n};\n\nMatrix3.prototype.multiplyVector3Array = function ()\n/* a */\n{\n  console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');\n};\n\nMatrix3.prototype.applyToBufferAttribute = function (attribute) {\n  console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');\n  return attribute.applyMatrix3(this);\n};\n\nMatrix3.prototype.applyToVector3Array = function ()\n/* array, offset, length */\n{\n  console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\n};\n\nMatrix3.prototype.getInverse = function (matrix) {\n  console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n  return this.copy(matrix).invert();\n}; //\n\n\nMatrix4.prototype.extractPosition = function (m) {\n  console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\n  return this.copyPosition(m);\n};\n\nMatrix4.prototype.flattenToArrayOffset = function (array, offset) {\n  console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n  return this.toArray(array, offset);\n};\n\nMatrix4.prototype.getPosition = function () {\n  console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\n  return new Vector3().setFromMatrixColumn(this, 3);\n};\n\nMatrix4.prototype.setRotationFromQuaternion = function (q) {\n  console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\n  return this.makeRotationFromQuaternion(q);\n};\n\nMatrix4.prototype.multiplyToArray = function () {\n  console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');\n};\n\nMatrix4.prototype.multiplyVector3 = function (vector) {\n  console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n  return vector.applyMatrix4(this);\n};\n\nMatrix4.prototype.multiplyVector4 = function (vector) {\n  console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n  return vector.applyMatrix4(this);\n};\n\nMatrix4.prototype.multiplyVector3Array = function ()\n/* a */\n{\n  console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');\n};\n\nMatrix4.prototype.rotateAxis = function (v) {\n  console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\n  v.transformDirection(this);\n};\n\nMatrix4.prototype.crossVector = function (vector) {\n  console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n  return vector.applyMatrix4(this);\n};\n\nMatrix4.prototype.translate = function () {\n  console.error('THREE.Matrix4: .translate() has been removed.');\n};\n\nMatrix4.prototype.rotateX = function () {\n  console.error('THREE.Matrix4: .rotateX() has been removed.');\n};\n\nMatrix4.prototype.rotateY = function () {\n  console.error('THREE.Matrix4: .rotateY() has been removed.');\n};\n\nMatrix4.prototype.rotateZ = function () {\n  console.error('THREE.Matrix4: .rotateZ() has been removed.');\n};\n\nMatrix4.prototype.rotateByAxis = function () {\n  console.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n};\n\nMatrix4.prototype.applyToBufferAttribute = function (attribute) {\n  console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');\n  return attribute.applyMatrix4(this);\n};\n\nMatrix4.prototype.applyToVector3Array = function ()\n/* array, offset, length */\n{\n  console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\n};\n\nMatrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {\n  console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');\n  return this.makePerspective(left, right, top, bottom, near, far);\n};\n\nMatrix4.prototype.getInverse = function (matrix) {\n  console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n  return this.copy(matrix).invert();\n}; //\n\n\nPlane.prototype.isIntersectionLine = function (line) {\n  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');\n  return this.intersectsLine(line);\n}; //\n\n\nQuaternion.prototype.multiplyVector3 = function (vector) {\n  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\n  return vector.applyQuaternion(this);\n};\n\nQuaternion.prototype.inverse = function () {\n  console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');\n  return this.invert();\n}; //\n\n\nRay.prototype.isIntersectionBox = function (box) {\n  console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');\n  return this.intersectsBox(box);\n};\n\nRay.prototype.isIntersectionPlane = function (plane) {\n  console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');\n  return this.intersectsPlane(plane);\n};\n\nRay.prototype.isIntersectionSphere = function (sphere) {\n  console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n  return this.intersectsSphere(sphere);\n}; //\n\n\nTriangle.prototype.area = function () {\n  console.warn('THREE.Triangle: .area() has been renamed to .getArea().');\n  return this.getArea();\n};\n\nTriangle.prototype.barycoordFromPoint = function (point, target) {\n  console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n  return this.getBarycoord(point, target);\n};\n\nTriangle.prototype.midpoint = function (target) {\n  console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');\n  return this.getMidpoint(target);\n};\n\nTriangle.prototypenormal = function (target) {\n  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n  return this.getNormal(target);\n};\n\nTriangle.prototype.plane = function (target) {\n  console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');\n  return this.getPlane(target);\n};\n\nTriangle.barycoordFromPoint = function (point, a, b, c, target) {\n  console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n  return Triangle.getBarycoord(point, a, b, c, target);\n};\n\nTriangle.normal = function (a, b, c, target) {\n  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n  return Triangle.getNormal(a, b, c, target);\n}; //\n\n\nShape.prototype.extractAllPoints = function (divisions) {\n  console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');\n  return this.extractPoints(divisions);\n};\n\nShape.prototype.extrude = function (options) {\n  console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');\n  return new ExtrudeGeometry(this, options);\n};\n\nShape.prototype.makeGeometry = function (options) {\n  console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');\n  return new ShapeGeometry(this, options);\n}; //\n\n\nVector2.prototype.fromAttribute = function (attribute, index, offset) {\n  console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');\n  return this.fromBufferAttribute(attribute, index, offset);\n};\n\nVector2.prototype.distanceToManhattan = function (v) {\n  console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n  return this.manhattanDistanceTo(v);\n};\n\nVector2.prototype.lengthManhattan = function () {\n  console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');\n  return this.manhattanLength();\n}; //\n\n\nVector3.prototype.setEulerFromRotationMatrix = function () {\n  console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n};\n\nVector3.prototype.setEulerFromQuaternion = function () {\n  console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n};\n\nVector3.prototype.getPositionFromMatrix = function (m) {\n  console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\n  return this.setFromMatrixPosition(m);\n};\n\nVector3.prototype.getScaleFromMatrix = function (m) {\n  console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\n  return this.setFromMatrixScale(m);\n};\n\nVector3.prototype.getColumnFromMatrix = function (index, matrix) {\n  console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\n  return this.setFromMatrixColumn(matrix, index);\n};\n\nVector3.prototype.applyProjection = function (m) {\n  console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');\n  return this.applyMatrix4(m);\n};\n\nVector3.prototype.fromAttribute = function (attribute, index, offset) {\n  console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');\n  return this.fromBufferAttribute(attribute, index, offset);\n};\n\nVector3.prototype.distanceToManhattan = function (v) {\n  console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n  return this.manhattanDistanceTo(v);\n};\n\nVector3.prototype.lengthManhattan = function () {\n  console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');\n  return this.manhattanLength();\n}; //\n\n\nVector4.prototype.fromAttribute = function (attribute, index, offset) {\n  console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');\n  return this.fromBufferAttribute(attribute, index, offset);\n};\n\nVector4.prototype.lengthManhattan = function () {\n  console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');\n  return this.manhattanLength();\n}; //\n\n\nObject3D.prototype.getChildByName = function (name) {\n  console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\n  return this.getObjectByName(name);\n};\n\nObject3D.prototype.renderDepth = function () {\n  console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\n};\n\nObject3D.prototype.translate = function (distance, axis) {\n  console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\n  return this.translateOnAxis(axis, distance);\n};\n\nObject3D.prototype.getWorldRotation = function () {\n  console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');\n};\n\nObject3D.prototype.applyMatrix = function (matrix) {\n  console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');\n  return this.applyMatrix4(matrix);\n};\n\nObject.defineProperties(Object3D.prototype, {\n  eulerOrder: {\n    get: function () {\n      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n      return this.rotation.order;\n    },\n    set: function (value) {\n      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n      this.rotation.order = value;\n    }\n  },\n  useQuaternion: {\n    get: function () {\n      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n    },\n    set: function () {\n      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n    }\n  }\n});\n\nMesh.prototype.setDrawMode = function () {\n  console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n};\n\nObject.defineProperties(Mesh.prototype, {\n  drawMode: {\n    get: function () {\n      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');\n      return TrianglesDrawMode;\n    },\n    set: function () {\n      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n    }\n  }\n});\n\nSkinnedMesh.prototype.initBones = function () {\n  console.error('THREE.SkinnedMesh: initBones() has been removed.');\n}; //\n\n\nPerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {\n  console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');\n  if (filmGauge !== undefined) this.filmGauge = filmGauge;\n  this.setFocalLength(focalLength);\n}; //\n\n\nObject.defineProperties(Light.prototype, {\n  onlyShadow: {\n    set: function () {\n      console.warn('THREE.Light: .onlyShadow has been removed.');\n    }\n  },\n  shadowCameraFov: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\n      this.shadow.camera.fov = value;\n    }\n  },\n  shadowCameraLeft: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');\n      this.shadow.camera.left = value;\n    }\n  },\n  shadowCameraRight: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');\n      this.shadow.camera.right = value;\n    }\n  },\n  shadowCameraTop: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\n      this.shadow.camera.top = value;\n    }\n  },\n  shadowCameraBottom: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');\n      this.shadow.camera.bottom = value;\n    }\n  },\n  shadowCameraNear: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');\n      this.shadow.camera.near = value;\n    }\n  },\n  shadowCameraFar: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\n      this.shadow.camera.far = value;\n    }\n  },\n  shadowCameraVisible: {\n    set: function () {\n      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');\n    }\n  },\n  shadowBias: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');\n      this.shadow.bias = value;\n    }\n  },\n  shadowDarkness: {\n    set: function () {\n      console.warn('THREE.Light: .shadowDarkness has been removed.');\n    }\n  },\n  shadowMapWidth: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');\n      this.shadow.mapSize.width = value;\n    }\n  },\n  shadowMapHeight: {\n    set: function (value) {\n      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');\n      this.shadow.mapSize.height = value;\n    }\n  }\n}); //\n\nObject.defineProperties(BufferAttribute.prototype, {\n  length: {\n    get: function () {\n      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');\n      return this.array.length;\n    }\n  },\n  dynamic: {\n    get: function () {\n      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n      return this.usage === DynamicDrawUsage;\n    },\n    set: function ()\n    /* value */\n    {\n      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n      this.setUsage(DynamicDrawUsage);\n    }\n  }\n});\n\nBufferAttribute.prototype.setDynamic = function (value) {\n  console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');\n  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n  return this;\n};\n\nBufferAttribute.prototype.copyIndicesArray = function ()\n/* indices */\n{\n  console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');\n}, BufferAttribute.prototype.setArray = function ()\n/* array */\n{\n  console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n}; //\n\nBufferGeometry.prototype.addIndex = function (index) {\n  console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\n  this.setIndex(index);\n};\n\nBufferGeometry.prototype.addAttribute = function (name, attribute) {\n  console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');\n\n  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\n    console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\n  }\n\n  if (name === 'index') {\n    console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\n    this.setIndex(attribute);\n    return this;\n  }\n\n  return this.setAttribute(name, attribute);\n};\n\nBufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {\n  if (indexOffset !== undefined) {\n    console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\n  }\n\n  console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\n  this.addGroup(start, count);\n};\n\nBufferGeometry.prototype.clearDrawCalls = function () {\n  console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\n  this.clearGroups();\n};\n\nBufferGeometry.prototype.computeOffsets = function () {\n  console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n};\n\nBufferGeometry.prototype.removeAttribute = function (name) {\n  console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');\n  return this.deleteAttribute(name);\n};\n\nBufferGeometry.prototype.applyMatrix = function (matrix) {\n  console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');\n  return this.applyMatrix4(matrix);\n};\n\nObject.defineProperties(BufferGeometry.prototype, {\n  drawcalls: {\n    get: function () {\n      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\n      return this.groups;\n    }\n  },\n  offsets: {\n    get: function () {\n      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\n      return this.groups;\n    }\n  }\n});\n\nInterleavedBuffer.prototype.setDynamic = function (value) {\n  console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');\n  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n  return this;\n};\n\nInterleavedBuffer.prototype.setArray = function ()\n/* array */\n{\n  console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n}; //\n\n\nExtrudeGeometry.prototype.getArrays = function () {\n  console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');\n};\n\nExtrudeGeometry.prototype.addShapeList = function () {\n  console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');\n};\n\nExtrudeGeometry.prototype.addShape = function () {\n  console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');\n}; //\n\n\nScene.prototype.dispose = function () {\n  console.error('THREE.Scene: .dispose() has been removed.');\n}; //\n\n\nObject.defineProperties(Material$1.prototype, {\n  wrapAround: {\n    get: function () {\n      console.warn('THREE.Material: .wrapAround has been removed.');\n    },\n    set: function () {\n      console.warn('THREE.Material: .wrapAround has been removed.');\n    }\n  },\n  overdraw: {\n    get: function () {\n      console.warn('THREE.Material: .overdraw has been removed.');\n    },\n    set: function () {\n      console.warn('THREE.Material: .overdraw has been removed.');\n    }\n  },\n  wrapRGB: {\n    get: function () {\n      console.warn('THREE.Material: .wrapRGB has been removed.');\n      return new Color();\n    }\n  },\n  shading: {\n    get: function () {\n      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n    },\n    set: function (value) {\n      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n      this.flatShading = value === FlatShading;\n    }\n  },\n  stencilMask: {\n    get: function () {\n      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n      return this.stencilFuncMask;\n    },\n    set: function (value) {\n      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n      this.stencilFuncMask = value;\n    }\n  },\n  vertexTangents: {\n    get: function () {\n      console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');\n    },\n    set: function () {\n      console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');\n    }\n  }\n});\nObject.defineProperties(ShaderMaterial.prototype, {\n  derivatives: {\n    get: function () {\n      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n      return this.extensions.derivatives;\n    },\n    set: function (value) {\n      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n      this.extensions.derivatives = value;\n    }\n  }\n}); //\n\nWebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {\n  console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');\n  this.setRenderTarget(renderTarget);\n  this.clear(color, depth, stencil);\n};\n\nWebGLRenderer.prototype.animate = function (callback) {\n  console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');\n  this.setAnimationLoop(callback);\n};\n\nWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n  console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');\n  return this.getRenderTarget();\n};\n\nWebGLRenderer.prototype.getMaxAnisotropy = function () {\n  console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');\n  return this.capabilities.getMaxAnisotropy();\n};\n\nWebGLRenderer.prototype.getPrecision = function () {\n  console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');\n  return this.capabilities.precision;\n};\n\nWebGLRenderer.prototype.resetGLState = function () {\n  console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');\n  return this.state.reset();\n};\n\nWebGLRenderer.prototype.supportsFloatTextures = function () {\n  console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\n  return this.extensions.get('OES_texture_float');\n};\n\nWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n  console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\n  return this.extensions.get('OES_texture_half_float');\n};\n\nWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n  console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\n  return this.extensions.get('OES_standard_derivatives');\n};\n\nWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n  console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\n  return this.extensions.get('WEBGL_compressed_texture_s3tc');\n};\n\nWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n  console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\n  return this.extensions.get('WEBGL_compressed_texture_pvrtc');\n};\n\nWebGLRenderer.prototype.supportsBlendMinMax = function () {\n  console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\n  return this.extensions.get('EXT_blend_minmax');\n};\n\nWebGLRenderer.prototype.supportsVertexTextures = function () {\n  console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');\n  return this.capabilities.vertexTextures;\n};\n\nWebGLRenderer.prototype.supportsInstancedArrays = function () {\n  console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\n  return this.extensions.get('ANGLE_instanced_arrays');\n};\n\nWebGLRenderer.prototype.enableScissorTest = function (boolean) {\n  console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');\n  this.setScissorTest(boolean);\n};\n\nWebGLRenderer.prototype.initMaterial = function () {\n  console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n};\n\nWebGLRenderer.prototype.addPrePlugin = function () {\n  console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n};\n\nWebGLRenderer.prototype.addPostPlugin = function () {\n  console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n};\n\nWebGLRenderer.prototype.updateShadowMap = function () {\n  console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n};\n\nWebGLRenderer.prototype.setFaceCulling = function () {\n  console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');\n};\n\nWebGLRenderer.prototype.allocTextureUnit = function () {\n  console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');\n};\n\nWebGLRenderer.prototype.setTexture = function () {\n  console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');\n};\n\nWebGLRenderer.prototype.setTexture2D = function () {\n  console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');\n};\n\nWebGLRenderer.prototype.setTextureCube = function () {\n  console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');\n};\n\nWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n  console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');\n  return this.getActiveMipmapLevel();\n};\n\nObject.defineProperties(WebGLRenderer.prototype, {\n  shadowMapEnabled: {\n    get: function () {\n      return this.shadowMap.enabled;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\n      this.shadowMap.enabled = value;\n    }\n  },\n  shadowMapType: {\n    get: function () {\n      return this.shadowMap.type;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\n      this.shadowMap.type = value;\n    }\n  },\n  shadowMapCullFace: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n      return undefined;\n    },\n    set: function ()\n    /* value */\n    {\n      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n    }\n  },\n  context: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');\n      return this.getContext();\n    }\n  },\n  vr: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');\n      return this.xr;\n    }\n  },\n  gammaInput: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n      return false;\n    },\n    set: function () {\n      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n    }\n  },\n  gammaOutput: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n      return false;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;\n    }\n  },\n  toneMappingWhitePoint: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n      return 1.0;\n    },\n    set: function () {\n      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n    }\n  }\n});\nObject.defineProperties(WebGLShadowMap.prototype, {\n  cullFace: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n      return undefined;\n    },\n    set: function ()\n    /* cullFace */\n    {\n      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n    }\n  },\n  renderReverseSided: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n      return undefined;\n    },\n    set: function () {\n      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n    }\n  },\n  renderSingleSided: {\n    get: function () {\n      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n      return undefined;\n    },\n    set: function () {\n      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n    }\n  }\n}); //\n\nObject.defineProperties(WebGLRenderTarget.prototype, {\n  wrapS: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n      return this.texture.wrapS;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n      this.texture.wrapS = value;\n    }\n  },\n  wrapT: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n      return this.texture.wrapT;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n      this.texture.wrapT = value;\n    }\n  },\n  magFilter: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n      return this.texture.magFilter;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n      this.texture.magFilter = value;\n    }\n  },\n  minFilter: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n      return this.texture.minFilter;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n      this.texture.minFilter = value;\n    }\n  },\n  anisotropy: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n      return this.texture.anisotropy;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n      this.texture.anisotropy = value;\n    }\n  },\n  offset: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n      return this.texture.offset;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n      this.texture.offset = value;\n    }\n  },\n  repeat: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n      return this.texture.repeat;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n      this.texture.repeat = value;\n    }\n  },\n  format: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n      return this.texture.format;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n      this.texture.format = value;\n    }\n  },\n  type: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n      return this.texture.type;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n      this.texture.type = value;\n    }\n  },\n  generateMipmaps: {\n    get: function () {\n      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n      return this.texture.generateMipmaps;\n    },\n    set: function (value) {\n      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n      this.texture.generateMipmaps = value;\n    }\n  }\n}); //\n\nAudio.prototype.load = function (file) {\n  console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');\n  const scope = this;\n  const audioLoader = new AudioLoader();\n  audioLoader.load(file, function (buffer) {\n    scope.setBuffer(buffer);\n  });\n  return this;\n}; //\n\n\nCubeCamera.prototype.updateCubeMap = function (renderer, scene) {\n  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');\n  return this.update(renderer, scene);\n};\n\nCubeCamera.prototype.clear = function (renderer, color, depth, stencil) {\n  console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');\n  return this.renderTarget.clear(renderer, color, depth, stencil);\n};\n\nImageUtils.crossOrigin = undefined;\n\nImageUtils.loadTexture = function (url, mapping, onLoad, onError) {\n  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');\n  const loader = new TextureLoader();\n  loader.setCrossOrigin(this.crossOrigin);\n  const texture = loader.load(url, onLoad, undefined, onError);\n  if (mapping) texture.mapping = mapping;\n  return texture;\n};\n\nImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {\n  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');\n  const loader = new CubeTextureLoader();\n  loader.setCrossOrigin(this.crossOrigin);\n  const texture = loader.load(urls, onLoad, undefined, onError);\n  if (mapping) texture.mapping = mapping;\n  return texture;\n};\n\nImageUtils.loadCompressedTexture = function () {\n  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\n};\n\nImageUtils.loadCompressedTextureCube = function () {\n  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\n};\n\nif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n  /* eslint-disable no-undef */\n  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {\n    detail: {\n      revision: REVISION\n    }\n  }));\n  /* eslint-enable no-undef */\n\n}\n\nif (typeof window !== 'undefined') {\n  if (window.__THREE__) {\n    console.warn('WARNING: Multiple instances of Three.js being imported.');\n  } else {\n    window.__THREE__ = REVISION;\n  }\n}\n\nconst _taskCache$1 = new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } //\n\n\n    const taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (_taskCache$1.has(buffer)) {\n      const cachedTask = _taskCache$1.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n\n      }\n    }); // Cache the task result.\n\n    _taskCache$1.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n      const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    const geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension$1(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension$1(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    } // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n    this.manager.itemStart(url);\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        scope.parse(data, resourcePath, function (gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(data, path, onLoad, onError) {\n    let content;\n    const extensions = {};\n    const plugins = {};\n\n    if (typeof data === 'string') {\n      content = data;\n    } else {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError) onError(error);\n          return;\n        }\n\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = LoaderUtils.decodeText(new Uint8Array(data));\n      }\n    }\n\n    const json = JSON.parse(content);\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n      return;\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n\n      extensions[plugin.name] = true;\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension$1();\n            break;\n\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n            break;\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n\n        }\n      }\n    }\n\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n\n}\n/* GLTFREGISTRY */\n\n\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function (key) {\n      return objects[key];\n    },\n    add: function (key, object) {\n      objects[key] = object;\n    },\n    remove: function (key) {\n      delete objects[key];\n    },\n    removeAll: function () {\n      objects = {};\n    }\n  };\n}\n/*********************************/\n\n/********** EXTENSIONS ***********/\n\n/*********************************/\n\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches\n\n    this.cache = {\n      refs: {},\n      uses: {}\n    };\n  }\n\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = 'light:' + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency) return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    const range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === undefined) return null;\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light);\n    });\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension$1 {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\n\n\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, -scale);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\n\n\nclass GLTFMaterialsTransmissionExtension$1 {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension$1 {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || 0;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationTint = new Color(colorArray[0], colorArray[1], colorArray[2]);\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\n\n\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n\n}\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\n\n\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularTint = new Color(colorArray[0], colorArray[1], colorArray[2]);\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {\n        texture.encoding = sRGBEncoding;\n      }));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\n\n\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[this.name];\n    const source = json.images[extension.source];\n    const loader = parser.options.ktx2Loader;\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null;\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, source, loader);\n  }\n\n}\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\n\n\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\n      } // Fall back to PNG or JPEG.\n\n\n      return parser.loadTexture(textureIndex);\n    });\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1);\n        };\n      });\n    }\n\n    return this.isSupported;\n  }\n\n}\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\n\n\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null;\n        }\n      }\n\n      return Promise.all([buffer, decoder.ready]).then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const result = new ArrayBuffer(count * stride);\n        const source = new Uint8Array(res[0], byteOffset, byteLength);\n        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n        return result;\n      });\n    } else {\n      return null;\n    }\n  }\n\n}\n/* BINARY EXTENSION */\n\n\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n  JSON: 0x4E4F534A,\n  BIN: 0x004E4942\n};\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n\n}\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\n\n\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  }\n\n}\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\n\n\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  extendTexture(texture, transform) {\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture;\n    }\n\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\n\n\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\n  constructor(params) {\n    super();\n    this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\n\n    const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n    const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n    const specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n    const glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n    const lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\n    const uniforms = {\n      specular: {\n        value: new Color().setHex(0xffffff)\n      },\n      glossiness: {\n        value: 1\n      },\n      specularMap: {\n        value: null\n      },\n      glossinessMap: {\n        value: null\n      }\n    };\n    this._extraUniforms = uniforms;\n\n    this.onBeforeCompile = function (shader) {\n      for (const uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n    };\n\n    Object.defineProperties(this, {\n      specular: {\n        get: function () {\n          return uniforms.specular.value;\n        },\n        set: function (v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function () {\n          return uniforms.specularMap.value;\n        },\n        set: function (v) {\n          uniforms.specularMap.value = v;\n\n          if (v) {\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        }\n      },\n      glossiness: {\n        get: function () {\n          return uniforms.glossiness.value;\n        },\n        set: function (v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function () {\n          return uniforms.glossinessMap.value;\n        },\n        set: function (v) {\n          uniforms.glossinessMap.value = v;\n\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = '';\n            this.defines.USE_UV = '';\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        }\n      }\n    });\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    this.setValues(params);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  }\n\n}\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\n  }\n\n  getMaterialType() {\n    return GLTFMeshStandardSGMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    const pending = [];\n\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n      const array = pbrSpecularGlossiness.diffuseFactor;\n      materialParams.color.fromArray(array);\n      materialParams.opacity = array[3];\n    }\n\n    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n    }\n\n    materialParams.emissive = new Color(0.0, 0.0, 0.0);\n    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n    materialParams.specular = new Color(1.0, 1.0, 1.0);\n\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n    }\n\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n      pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n      pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n    }\n\n    return Promise.all(pending);\n  }\n\n  createMaterial(materialParams) {\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\n    material.fog = true;\n    material.color = materialParams.color;\n    material.map = materialParams.map === undefined ? null : materialParams.map;\n    material.lightMap = null;\n    material.lightMapIntensity = 1.0;\n    material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n    material.aoMapIntensity = 1.0;\n    material.emissive = materialParams.emissive;\n    material.emissiveIntensity = 1.0;\n    material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n    material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n    material.bumpScale = 1;\n    material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n    material.normalMapType = TangentSpaceNormalMap;\n    if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\n    material.displacementMap = null;\n    material.displacementScale = 1;\n    material.displacementBias = 0;\n    material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n    material.specular = materialParams.specular;\n    material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n    material.glossiness = materialParams.glossiness;\n    material.alphaMap = null;\n    material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n    material.envMapIntensity = 1.0;\n    material.refractionRatio = 0.98;\n    return material;\n  }\n\n}\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\n\n\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n\n}\n/*********************************/\n\n/********** INTERPOLATION ********/\n\n/*********************************/\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          valueSize = this.valueSize,\n          offset = index * valueSize * 3 + valueSize;\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  }\n\n}\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n  const result = this.resultBuffer;\n  const values = this.sampleValues;\n  const stride = this.valueSize;\n  const stride2 = stride * 2;\n  const stride3 = stride * 3;\n  const td = t1 - t0;\n  const p = (t - t0) / td;\n  const pp = p * p;\n  const ppp = pp * p;\n  const offset1 = i1 * stride3;\n  const offset0 = offset1 - stride3;\n  const s2 = -2 * ppp + 3 * pp;\n  const s3 = ppp - pp;\n  const s0 = 1 - s2;\n  const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n  for (let i = 0; i !== stride; i++) {\n    const p0 = values[offset0 + i + stride]; // splineVertex_k\n\n    const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n    const p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n    const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n  }\n\n  return result;\n};\n/*********************************/\n\n/********** INTERNALS ************/\n\n/*********************************/\n\n/* CONSTANTS */\n\n\nconst WEBGL_CONSTANTS$1 = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  'SCALAR': 1,\n  'VEC2': 2,\n  'VEC3': 3,\n  'VEC4': 4,\n  'MAT2': 4,\n  'MAT3': 9,\n  'MAT4': 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst PATH_PROPERTIES$1 = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences'\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND'\n};\n/* UTILITY FUNCTIONS */\n\nfunction resolveURL(url, path) {\n  // Invalid URL\n  if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n  } // Absolute URL http://,https://,//\n\n\n  if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n  if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n  if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n  return path + url;\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\n\n\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xFFFFFF,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n\n  return cache['DefaultMaterial'];\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\n\n\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n    }\n  }\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== undefined) hasMorphPosition = true;\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\n    if (hasMorphPosition && hasMorphNormal) break;\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n  }\n\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\n\n\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  let geometryKey;\n\n  if (dracoExtension) {\n    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n  }\n\n  return geometryKey;\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = '';\n  const keys = Object.keys(attributes).sort();\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n  }\n\n  return attributesKey;\n}\n\nfunction getNormalizedComponentScale$1(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n\n    case Uint8Array:\n      return 1 / 255;\n\n    case Int16Array:\n      return 1 / 32767;\n\n    case Uint16Array:\n      return 1 / 65535;\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\n  }\n}\n/* GLTF PARSER */\n\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options; // loader object cache\n\n    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\n\n    this.associations = new Map(); // BufferGeometry caching\n\n    this.primitiveCache = {}; // Object3D instance caches\n\n    this.meshCache = {\n      refs: {},\n      uses: {}\n    };\n    this.cameraCache = {\n      refs: {},\n      uses: {}\n    };\n    this.lightCache = {\n      refs: {},\n      uses: {}\n    };\n    this.textureCache = {}; // Track node names, to ensure no duplicates\n\n    this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    } else {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n\n    Promise.all(this._invokeAll(function (ext) {\n      return ext.beforeRoot && ext.beforeRoot();\n    })).then(function () {\n      return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\n    }).then(function (dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(parser._invokeAll(function (ext) {\n        return ext.afterRoot && ext.afterRoot(result);\n      })).then(function () {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n\n\n  _addNodeRef(cache, index) {\n    if (index === undefined) return;\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n\n\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object;\n    const ref = object.clone();\n    ref.name += '_instance_' + cache.uses[index]++;\n    return ref;\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) return result;\n    }\n\n    return null;\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) pending.push(result);\n    }\n\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index;\n    let dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    const options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n\n\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    const pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const source = json.images[textureDef.source];\n    let loader = this.textureLoader;\n\n    if (source.uri) {\n      const handler = options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.loadTextureImage(textureIndex, source, loader);\n  }\n\n  loadTextureImage(textureIndex, source, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey];\n    }\n\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = source.uri || '';\n    let isObjectURL = false;\n    let hasAlpha = true;\n    const isJPEG = sourceURI.search(/\\.jpe?g($|\\?)/i) > 0 || sourceURI.search(/^data\\:image\\/jpeg/) === 0;\n    if (source.mimeType === 'image/jpeg' || isJPEG) hasAlpha = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        if (source.mimeType === 'image/png') {\n          // Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n          // alpha channel. This check is conservative  the image could have an alpha\n          // channel with all values == 1, and the indexed type (colorType == 3) only\n          // sometimes contains alpha.\n          //\n          // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n          const colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\n          hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n        }\n\n        isObjectURL = true;\n        const blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (source.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');\n    }\n\n    const promise = Promise.resolve(sourceURI).then(function (sourceURI) {\n      return new Promise(function (resolve, reject) {\n        let onLoad = resolve;\n\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function (imageBitmap) {\n            const texture = new Texture$1(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n\n        loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\n      if (!hasAlpha) texture.format = RGBFormat;\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, {\n        type: 'textures',\n        index: textureIndex\n      });\n      return texture;\n    }).catch(function () {\n      console.error('THREE.GLTFLoader: Couldn\\'t load texture', sourceURI);\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n\n\n  assignTexture(materialParams, mapName, mapDef) {\n    const parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useVertexTangents = geometry.attributes.tangent !== undefined;\n    const useVertexColors = geometry.attributes.color !== undefined;\n    const useFlatShading = geometry.attributes.normal === undefined;\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material$1.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material$1.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      let cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n\n        if (useVertexTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      geometry.setAttribute('uv2', geometry.attributes.uv);\n    }\n\n    mesh.material = material;\n  }\n\n  getMaterialType()\n  /* materialIndex */\n  {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n\n\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function (ext) {\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\n\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n      materialParams.normalScale = new Vector2(1, -1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      let material;\n\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, {\n        type: 'materials',\n        index: materialIndex\n      });\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n\n\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');\n    let name = sanitizedName;\n\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n      name = sanitizedName + '_' + i;\n    }\n\n    this.nodeNamesUsed[name] = true;\n    return name;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n\n\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      const cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n\n\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i]; // 1. create Mesh\n\n        let mesh;\n        const material = materials[i];\n\n        if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES || primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN || primitive.mode === undefined) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n            mesh.normalizeSkinWeights();\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n\n      const group = new Group();\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n\n\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        let TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES$1[target.path]) {\n          case PATH_PROPERTIES$1.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES$1.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES$1.position:\n          case PATH_PROPERTIES$1.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        const targetNames = [];\n\n        if (PATH_PROPERTIES$1[target.path] === PATH_PROPERTIES$1.weights) {\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        let outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale$1(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES$1[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n      return new AnimationClip(name, undefined, tracks);\n    });\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === undefined) return null;\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\n\n\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return;\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n\n\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\n\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\n    return function () {\n      const pending = [];\n\n      const meshPromise = parser._invokeOne(function (ext) {\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n      });\n\n      if (meshPromise) {\n        pending.push(meshPromise);\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        }));\n      }\n\n      parser._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n      }).forEach(function (promise) {\n        pending.push(promise);\n      });\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      let node; // .isBone isn't in glTF spec. See ._markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      parser.associations.set(node, {\n        type: 'nodes',\n        index: nodeIndex\n      });\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n\n\n  loadScene(sceneIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this; // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\n    const scene = new Group();\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n    }\n\n    return Promise.all(pending).then(function () {\n      return scene;\n    });\n  }\n\n}\n\nfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\n  const nodeDef = json.nodes[nodeId];\n  return parser.getDependency('node', nodeId).then(function (node) {\n    if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n    let skinEntry;\n    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n      skinEntry = skin;\n      const pendingJoints = [];\n\n      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n      }\n\n      return Promise.all(pendingJoints);\n    }).then(function (jointNodes) {\n      node.traverse(function (mesh) {\n        if (!mesh.isMesh) return;\n        const bones = [];\n        const boneInverses = [];\n\n        for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n          const jointNode = jointNodes[j];\n\n          if (jointNode) {\n            bones.push(jointNode);\n            const mat = new Matrix4();\n\n            if (skinEntry.inverseBindMatrices !== undefined) {\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n            }\n\n            boneInverses.push(mat);\n          } else {\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n          }\n        }\n\n        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n      });\n      return node;\n    });\n  }).then(function (node) {\n    // build node hierachy\n    parentObject.add(node);\n    const pending = [];\n\n    if (nodeDef.children) {\n      const children = nodeDef.children;\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        const child = children[i];\n        pending.push(buildNodeHierachy(child, node, json, parser));\n      }\n    }\n\n    return Promise.all(pending);\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\n\n\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale$1(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n      return;\n    }\n  } else {\n    return;\n  }\n\n  const targets = primitiveDef.targets;\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale$1(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\n\n          maxDisplacement.max(vector);\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        }\n      }\n    } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\n\n    box.expandByVector(maxDisplacement);\n  }\n\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n    if (threeAttributeName in geometry.attributes) continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor);\n    });\n    pending.push(accessor);\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  let index = geometry.getIndex(); // generate index if not present\n\n  if (index === null) {\n    const indices = [];\n    const position = geometry.getAttribute('position');\n\n    if (position !== undefined) {\n      for (let i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n      return geometry;\n    }\n  } //\n\n\n  const numberOfTriangles = index.count - 2;\n  const newIndices = [];\n\n  if (drawMode === TriangleFanDrawMode) {\n    // gl.TRIANGLE_FAN\n    for (let i = 1; i <= numberOfTriangles; i++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(i));\n      newIndices.push(index.getX(i + 1));\n    }\n  } else {\n    // gl.TRIANGLE_STRIP\n    for (let i = 0; i < numberOfTriangles; i++) {\n      if (i % 2 === 0) {\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i + 2));\n      } else {\n        newIndices.push(index.getX(i + 2));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i));\n      }\n    }\n  }\n\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n  } // build final geometry\n\n\n  const newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n  return newGeometry;\n}\n\nconst e = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\nvar n, i$1, s, a, r, o, l, f;\n!function (t) {\n  t[t.NONE = 0] = \"NONE\", t[t.BASISLZ = 1] = \"BASISLZ\", t[t.ZSTD = 2] = \"ZSTD\", t[t.ZLIB = 3] = \"ZLIB\";\n}(n || (n = {})), function (t) {\n  t[t.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(i$1 || (i$1 = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.ETC1S = 163] = \"ETC1S\", t[t.UASTC = 166] = \"UASTC\";\n}(s || (s = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.SRGB = 1] = \"SRGB\";\n}(a || (a = {})), function (t) {\n  t[t.UNSPECIFIED = 0] = \"UNSPECIFIED\", t[t.LINEAR = 1] = \"LINEAR\", t[t.SRGB = 2] = \"SRGB\", t[t.ITU = 3] = \"ITU\", t[t.NTSC = 4] = \"NTSC\", t[t.SLOG = 5] = \"SLOG\", t[t.SLOG2 = 6] = \"SLOG2\";\n}(r || (r = {})), function (t) {\n  t[t.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", t[t.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(o || (o = {})), function (t) {\n  t[t.RGB = 0] = \"RGB\", t[t.RRR = 3] = \"RRR\", t[t.GGG = 4] = \"GGG\", t[t.AAA = 15] = \"AAA\";\n}(l || (l = {})), function (t) {\n  t[t.RGB = 0] = \"RGB\", t[t.RGBA = 3] = \"RGBA\", t[t.RRR = 4] = \"RRR\", t[t.RRRG = 5] = \"RRRG\";\n}(f || (f = {}));\n\nclass U {\n  constructor() {\n    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = n.NONE, this.levels = [], this.dataFormatDescriptor = [{\n      vendorId: 0,\n      descriptorType: i$1.BASICFORMAT,\n      versionNumber: 2,\n      descriptorBlockSize: 40,\n      colorModel: s.UNSPECIFIED,\n      colorPrimaries: a.SRGB,\n      transferFunction: a.SRGB,\n      flags: o.ALPHA_STRAIGHT,\n      texelBlockDimension: {\n        x: 4,\n        y: 4,\n        z: 1,\n        w: 1\n      },\n      bytesPlane: [],\n      samples: []\n    }], this.keyValue = {}, this.globalData = null;\n  }\n\n}\n\nclass c {\n  constructor(t, e, n, i) {\n    this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = i, this._offset = 0;\n  }\n\n  _nextUint8() {\n    const t = this._dataView.getUint8(this._offset);\n\n    return this._offset += 1, t;\n  }\n\n  _nextUint16() {\n    const t = this._dataView.getUint16(this._offset, this._littleEndian);\n\n    return this._offset += 2, t;\n  }\n\n  _nextUint32() {\n    const t = this._dataView.getUint32(this._offset, this._littleEndian);\n\n    return this._offset += 4, t;\n  }\n\n  _nextUint64() {\n    const t = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\n    return this._offset += 8, t;\n  }\n\n  _skip(t) {\n    return this._offset += t, this;\n  }\n\n  _scan(t, e = 0) {\n    const n = this._offset;\n    let i = 0;\n\n    for (; this._dataView.getUint8(this._offset) !== e && i < t;) i++, this._offset++;\n\n    return i < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i);\n  }\n\n}\n\nfunction _(t) {\n  return \"undefined\" != typeof TextDecoder ? new TextDecoder().decode(t) : Buffer.from(t).toString(\"utf8\");\n}\n\nfunction p(t) {\n  const n = new Uint8Array(t.buffer, t.byteOffset, e.length);\n  if (n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] || n[6] !== e[6] || n[7] !== e[7] || n[8] !== e[8] || n[9] !== e[9] || n[10] !== e[10] || n[11] !== e[11]) throw new Error(\"Missing KTX 2.0 identifier.\");\n  const i = new U(),\n        s = 17 * Uint32Array.BYTES_PER_ELEMENT,\n        a = new c(t, e.length, s, !0);\n  i.vkFormat = a._nextUint32(), i.typeSize = a._nextUint32(), i.pixelWidth = a._nextUint32(), i.pixelHeight = a._nextUint32(), i.pixelDepth = a._nextUint32(), i.layerCount = a._nextUint32(), i.faceCount = a._nextUint32();\n\n  const r = a._nextUint32();\n\n  i.supercompressionScheme = a._nextUint32();\n\n  const o = a._nextUint32(),\n        l = a._nextUint32(),\n        f = a._nextUint32(),\n        h = a._nextUint32(),\n        g = a._nextUint64(),\n        p = a._nextUint64(),\n        x = new c(t, e.length + s, 3 * r * 8, !0);\n\n  for (let e = 0; e < r; e++) i.levels.push({\n    levelData: new Uint8Array(t.buffer, t.byteOffset + x._nextUint64(), x._nextUint64()),\n    uncompressedByteLength: x._nextUint64()\n  });\n\n  const u = new c(t, o, l, !0),\n        y = {\n    vendorId: u._skip(4)._nextUint16(),\n    descriptorType: u._nextUint16(),\n    versionNumber: u._nextUint16(),\n    descriptorBlockSize: u._nextUint16(),\n    colorModel: u._nextUint8(),\n    colorPrimaries: u._nextUint8(),\n    transferFunction: u._nextUint8(),\n    flags: u._nextUint8(),\n    texelBlockDimension: {\n      x: u._nextUint8() + 1,\n      y: u._nextUint8() + 1,\n      z: u._nextUint8() + 1,\n      w: u._nextUint8() + 1\n    },\n    bytesPlane: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()],\n    samples: []\n  },\n        D = (y.descriptorBlockSize / 4 - 6) / 4;\n\n  for (let t = 0; t < D; t++) y.samples[t] = {\n    bitOffset: u._nextUint16(),\n    bitLength: u._nextUint8(),\n    channelID: u._nextUint8(),\n    samplePosition: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()],\n    sampleLower: u._nextUint32(),\n    sampleUpper: u._nextUint32()\n  };\n\n  i.dataFormatDescriptor.length = 0, i.dataFormatDescriptor.push(y);\n  const b = new c(t, f, h, !0);\n\n  for (; b._offset < h;) {\n    const t = b._nextUint32(),\n          e = b._scan(t),\n          n = _(e),\n          s = b._scan(t - e.byteLength);\n\n    i.keyValue[n] = n.match(/^ktx/i) ? _(s) : s, b._offset % 4 && b._skip(4 - b._offset % 4);\n  }\n\n  if (p <= 0) return i;\n\n  const d = new c(t, g, p, !0),\n        B = d._nextUint16(),\n        w = d._nextUint16(),\n        A = d._nextUint32(),\n        S = d._nextUint32(),\n        m = d._nextUint32(),\n        L = d._nextUint32(),\n        I = [];\n\n  for (let t = 0; t < r; t++) I.push({\n    imageFlags: d._nextUint32(),\n    rgbSliceByteOffset: d._nextUint32(),\n    rgbSliceByteLength: d._nextUint32(),\n    alphaSliceByteOffset: d._nextUint32(),\n    alphaSliceByteLength: d._nextUint32()\n  });\n\n  const R = g + d._offset,\n        E = R + A,\n        T = E + S,\n        O = T + m,\n        P = new Uint8Array(t.buffer, t.byteOffset + R, A),\n        C = new Uint8Array(t.buffer, t.byteOffset + E, S),\n        F = new Uint8Array(t.buffer, t.byteOffset + T, m),\n        G = new Uint8Array(t.buffer, t.byteOffset + O, L);\n  return i.globalData = {\n    endpointCount: B,\n    selectorCount: w,\n    imageDescs: I,\n    endpointsData: P,\n    selectorsData: C,\n    tablesData: F,\n    extendedData: G\n  }, i;\n}\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\n\nconst _taskCache = new WeakMap();\n\nclass BasisTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = '';\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.workerConfig = null;\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\n    };\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n    const texture = new CompressedTexture();\n    loader.load(url, buffer => {\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n\n      this._createTexture([buffer]).then(function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }).catch(onError);\n    }, onProgress, onError);\n    return texture;\n  }\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n\n\n  parseInternalAsync(options) {\n    const {\n      levels\n    } = options;\n    const buffers = new Set();\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer);\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options,\n      lowLevel: true\n    });\n  }\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n\n\n  _createTexture(buffers, config = {}) {\n    let worker;\n    let taskID;\n    const taskConfig = config;\n    let taskCost = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength;\n    }\n\n    const texturePending = this._allocateWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'transcode',\n          id: taskID,\n          buffers: buffers,\n          taskConfig: taskConfig\n        }, buffers);\n      });\n    }).then(message => {\n      const {\n        mipmaps,\n        width,\n        height,\n        format\n      } = message;\n      const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      return texture;\n    }); // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    texturePending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        worker._taskLoad -= taskCost;\n        delete worker._callbacks[taskID];\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffers[0], {\n      promise: texturePending\n    });\n\n    return texturePending;\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject);\n      }); // Load transcoder WASM binary.\n\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject);\n      });\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = BasisTextureLoader.BasisWorker.toString();\n        const body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent;\n      });\n    }\n\n    return this.transcoderPending;\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* CONSTANTS */\n\n\nBasisTextureLoader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1\n};\nBasisTextureLoader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n};\nBasisTextureLoader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n};\n/* WEB WORKER */\n\nBasisTextureLoader.BasisWorker = function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\n            const buffers = [];\n\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage({\n              type: 'transcode',\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(() => {\n      BasisModule.initializeBasis();\n    });\n  }\n\n  function transcodeLowLevel(taskConfig) {\n    const {\n      basisFormat,\n      width,\n      height,\n      hasAlpha\n    } = taskConfig;\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.');\n    const mipmaps = [];\n\n    if (basisFormat === BasisFormat.ETC1S) {\n      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      const {\n        endpointCount,\n        endpointsData,\n        selectorCount,\n        selectorsData,\n        tablesData\n      } = taskConfig.globalData;\n\n      try {\n        let ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.');\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.');\n\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i];\n          const imageDesc = taskConfig.globalData.imageDescs[i];\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          const dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.');\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (let i = 0; i < taskConfig.levels.length; i++) {\n        const level = taskConfig.levels[i];\n        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n        const dst = new Uint8Array(dstByteLength);\n        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.');\n        mipmaps.push({\n          data: dst,\n          width: level.width,\n          height: level.height\n        });\n      }\n    }\n\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  }\n\n  function transcode(buffer) {\n    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = basisFile.getImageWidth(0, 0);\n    const height = basisFile.getImageHeight(0, 0);\n    const levels = basisFile.getNumLevels(0);\n    const hasAlpha = basisFile.getHasAlpha();\n\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader:\tInvalid texture');\n    }\n\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader: .startTranscoding failed');\n    }\n\n    const mipmaps = [];\n\n    for (let mip = 0; mip < levels; mip++) {\n      const mipWidth = basisFile.getImageWidth(0, mip);\n      const mipHeight = basisFile.getImageHeight(0, mip);\n      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  } //\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n\n\n  const FORMAT_OPTIONS = [{\n    if: 'astcSupported',\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: 'bptcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: 'dxtSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc2Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc1Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: 'pvrtcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n\n    console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.');\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      // GL requires extra padding for very small textures:\n      // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n      const paddedWidth = width + 3 & ~3;\n      const paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n};\n/**\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\n\nlet init, instance, heap;\nconst importObject = {\n  env: {\n    emscripten_notify_memory_growth: function (index) {\n      heap = new Uint8Array(instance.exports.memory.buffer);\n    }\n  }\n};\n/**\n * ZSTD (Zstandard) decoder.\n *\n * Compiled from https://github.com/facebook/zstd/tree/dev/contrib/single_file_libs, with the\n * following steps:\n *\n * ```\n * ./combine.sh -r ../../lib -o zstddeclib.c zstddeclib-in.c\n * emcc zstddeclib.c -Oz -s EXPORTED_FUNCTIONS=\"['_ZSTD_decompress', '_ZSTD_findDecompressedSize', '_ZSTD_isError', '_malloc', '_free']\" -s ALLOW_MEMORY_GROWTH=1 -s MALLOC=emmalloc -o zstddec.wasm\n * base64 zstddec.wasm > zstddec.txt\n * ```\n *\n * The base64 string written to `zstddec.txt` is embedded as the `wasm` variable at the bottom\n * of this file. The rest of this file is written by hand, in order to avoid an additional JS\n * wrapper generated by Emscripten.\n */\n\nclass ZSTDDecoder {\n  init() {\n    if (!init) {\n      init = fetch('data:application/wasm;base64,' + wasm).then(response => response.arrayBuffer()).then(arrayBuffer => WebAssembly.instantiate(arrayBuffer, importObject)).then(result => {\n        instance = result.instance;\n        importObject.env.emscripten_notify_memory_growth(0); // initialize heap.\n      });\n    }\n\n    return init;\n  }\n\n  decode(array, uncompressedSize = 0) {\n    // Write compressed data into WASM memory.\n    const compressedSize = array.byteLength;\n    const compressedPtr = instance.exports.malloc(compressedSize);\n    heap.set(array, compressedPtr); // Decompress into WASM memory.\n\n    uncompressedSize = uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));\n    const uncompressedPtr = instance.exports.malloc(uncompressedSize);\n    const actualSize = instance.exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize); // Read decompressed data and free WASM memory.\n\n    const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize);\n    instance.exports.free(compressedPtr);\n    instance.exports.free(uncompressedPtr);\n    return dec;\n  }\n\n}\n/**\n * BSD License\n *\n * For Zstandard software\n *\n * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name Facebook nor the names of its contributors may be used to\n *    endorse or promote products derived from this software without specific\n *    prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nconst wasm = 'AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ';\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats. While KTX 2.0 also allows\n * other hardware-specific formats, this loader does not yet parse them.\n *\n * This loader parses the KTX 2.0 container and then relies on\n * THREE.BasisTextureLoader to complete the transcoding process.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nclass KTX2Loader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.basisLoader = new BasisTextureLoader(manager);\n    this.zstd = new ZSTDDecoder();\n    this.zstd.init();\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.basisLoader.setTranscoderPath(path);\n    return this;\n  }\n\n  setWorkerLimit(path) {\n    this.basisLoader.setWorkerLimit(path);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.basisLoader.detectSupport(renderer);\n    return this;\n  }\n\n  dispose() {\n    this.basisLoader.dispose();\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new CompressedTexture();\n    var bufferPending = new Promise(function (resolve, reject) {\n      new FileLoader(scope.manager).setPath(scope.path).setResponseType('arraybuffer').load(url, resolve, onProgress, reject);\n    });\n    bufferPending.then(function (buffer) {\n      scope.parse(buffer, function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onError);\n    }).catch(onError);\n    return texture;\n  }\n\n  parse(buffer, onLoad, onError) {\n    var scope = this;\n    var ktx = p(new Uint8Array(buffer));\n\n    if (ktx.pixelDepth > 0) {\n      throw new Error('THREE.KTX2Loader: Only 2D textures are currently supported.');\n    }\n\n    if (ktx.layerCount > 1) {\n      throw new Error('THREE.KTX2Loader: Array textures are not currently supported.');\n    }\n\n    if (ktx.faceCount > 1) {\n      throw new Error('THREE.KTX2Loader: Cube textures are not currently supported.');\n    }\n\n    var dfd = KTX2Utils.getBasicDFD(ktx);\n    KTX2Utils.createLevels(ktx, this.zstd).then(function (levels) {\n      var basisFormat = dfd.colorModel === s.UASTC ? BasisTextureLoader.BasisFormat.UASTC_4x4 : BasisTextureLoader.BasisFormat.ETC1S;\n      var parseConfig = {\n        levels: levels,\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        basisFormat: basisFormat,\n        hasAlpha: KTX2Utils.getAlpha(ktx)\n      };\n\n      if (basisFormat === BasisTextureLoader.BasisFormat.ETC1S) {\n        parseConfig.globalData = ktx.globalData;\n      }\n\n      return scope.basisLoader.parseInternalAsync(parseConfig);\n    }).then(function (texture) {\n      texture.encoding = dfd.transferFunction === r.SRGB ? sRGBEncoding : LinearEncoding;\n      texture.premultiplyAlpha = KTX2Utils.getPremultiplyAlpha(ktx);\n      onLoad(texture);\n    }).catch(onError);\n    return this;\n  }\n\n}\n\nvar KTX2Utils = {\n  createLevels: function () {\n    var _ref2 = _asyncToGenerator(function* (ktx, zstd) {\n      if (ktx.supercompressionScheme === n.ZSTD) {\n        yield zstd.init();\n      }\n\n      var levels = [];\n      var width = ktx.pixelWidth;\n      var height = ktx.pixelHeight;\n\n      for (var levelIndex = 0; levelIndex < ktx.levels.length; levelIndex++) {\n        var levelWidth = Math.max(1, Math.floor(width / Math.pow(2, levelIndex)));\n        var levelHeight = Math.max(1, Math.floor(height / Math.pow(2, levelIndex)));\n        var levelData = ktx.levels[levelIndex].levelData;\n\n        if (ktx.supercompressionScheme === n.ZSTD) {\n          levelData = zstd.decode(levelData, ktx.levels[levelIndex].uncompressedByteLength);\n        }\n\n        levels.push({\n          index: levelIndex,\n          width: levelWidth,\n          height: levelHeight,\n          data: levelData\n        });\n      }\n\n      return levels;\n    });\n\n    return function createLevels(_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }(),\n  getBasicDFD: function (ktx) {\n    // Basic Data Format Descriptor Block is always the first DFD.\n    return ktx.dataFormatDescriptor[0];\n  },\n  getAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx); // UASTC\n\n    if (dfd.colorModel === s.UASTC) {\n      if ((dfd.samples[0].channelID & 0xF) === f.RGBA) {\n        return true;\n      }\n\n      return false;\n    } // ETC1S\n\n\n    if (dfd.samples.length === 2 && (dfd.samples[1].channelID & 0xF) === l.AAA) {\n      return true;\n    }\n\n    return false;\n  },\n  getPremultiplyAlpha: function (ktx) {\n    var dfd = this.getBasicDFD(ktx);\n    return !!(dfd.flags & o.ALPHA_PREMULTIPLIED);\n  }\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _a$a, _b$8;\n\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\n\nclass CacheEvictionPolicy {\n  constructor(cache, evictionThreshold = 5) {\n    this[_a$a] = new Map();\n    this[_b$8] = [];\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n\n\n  set evictionThreshold(value) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n\n  get evictionThreshold() {\n    return this[$evictionThreshold];\n  }\n  /**\n   * A reference to the cache that operates under this policy\n   */\n\n\n  get cache() {\n    return this[$cache];\n  }\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n\n\n  retainerCount(key) {\n    return this[$retainerCount].get(key) || 0;\n  }\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n\n\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n\n\n  retain(key) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n\n    this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n\n    this[$recentlyUsed].unshift(key); // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n\n    this[$evict]();\n  }\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n\n\n  release(key) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));\n    }\n\n    this[$evict]();\n  }\n\n  [(_a$a = $retainerCount, _b$8 = $recentlyUsed, $evict)]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n\n}\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * KHR_materials_variants specification allows duplicated variant names\n * but it makes handling the extension complex.\n * We ensure tha names and make it easier.\n * If you want to export the extension with the original names\n * you are recommended to write GLTFExporter plugin to restore the names.\n *\n * @param variantNames {Array<string>}\n * @return {Array<string>}\n */\n\n\nconst ensureUniqueNames = variantNames => {\n  const uniqueNames = [];\n  const knownNames = new Set();\n\n  for (const name of variantNames) {\n    let uniqueName = name;\n    let suffix = 0; // @TODO: An easy solution.\n    //        O(N^2) in the worst scenario where N is variantNames.length.\n    //        Fix me if needed.\n\n    while (knownNames.has(uniqueName)) {\n      uniqueName = name + '.' + ++suffix;\n    }\n\n    knownNames.add(uniqueName);\n    uniqueNames.push(uniqueName);\n  }\n\n  return uniqueNames;\n};\n/**\n * Convert mappings array to table object to make handling the extension easier.\n *\n * @param\n *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}\n * @param variantNames {Array<string>} Required to be unique names\n * @return {Map}\n */\n\n\nconst mappingsArrayToTable = (extensionDef, variantNames) => {\n  const table = new Map();\n\n  for (const mapping of extensionDef.mappings) {\n    for (const variant of mapping.variants) {\n      table.set(variantNames[variant], {\n        material: null,\n        gltfMaterialIndex: mapping.material\n      });\n    }\n  }\n\n  return table;\n};\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\n\n\nconst compatibleObject$1 = object => {\n  return 'material' in object && // easier than (!object.isMesh &&\n  // !object.isLine && !object.isPoints)\n  object.userData && // just in case\n  object.userData.variantMaterials;\n};\n\nclass GLTFMaterialsVariantsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = 'KHR_materials_variants';\n  } // Note that the following properties will be overridden even if they are\n  // pre-defined\n  // - gltf.userData.variants\n  // - mesh.userData.variantMaterials\n\n\n  afterRoot(gltf) {\n    const parser = this.parser;\n    const json = parser.json;\n\n    if (json.extensions === undefined || json.extensions[this.name] === undefined) {\n      return null;\n    }\n\n    const extensionDef = json.extensions[this.name];\n    const variantsDef = extensionDef.variants || [];\n    const variants = ensureUniqueNames(variantsDef.map(v => v.name));\n\n    for (const scene of gltf.scenes) {\n      // Save the variants data under associated mesh.userData\n      scene.traverse(object => {\n        // The following code can be simplified if parser.associations directly\n        // supports meshes.\n        const association = parser.associations.get(object);\n\n        if (!association || association.type !== 'nodes') {\n          return;\n        }\n\n        const nodeDef = json.nodes[association.index];\n        const meshIndex = nodeDef.mesh;\n\n        if (meshIndex === undefined) {\n          return;\n        } // Two limitations:\n        // 1. The nodeDef shouldn't have any objects (camera, light, or\n        // nodeDef.extensions object)\n        //    other than nodeDef.mesh\n        // 2. Other plugins shouldn't change any scene graph hierarchy\n        // The following code can cause error if hitting the either or both\n        // limitations If parser.associations will directly supports meshes\n        // these limitations can be removed\n\n\n        const meshDef = json.meshes[meshIndex];\n        const primitivesDef = meshDef.primitives;\n        const meshes = 'isMesh' in object ? [object] : object.children;\n\n        for (let i = 0; i < primitivesDef.length; i++) {\n          const primitiveDef = primitivesDef[i];\n          const extensionsDef = primitiveDef.extensions;\n\n          if (!extensionsDef || !extensionsDef[this.name]) {\n            continue;\n          }\n\n          meshes[i].userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name], variants);\n        }\n      });\n    }\n\n    gltf.userData.variants = variants; // @TODO: Adding functions to userData might be problematic\n    //        for example when serializing?\n\n    gltf.userData.functions = gltf.userData.functions || {};\n    /**\n     * @param object {THREE.Mesh}\n     * @param variantName {string|null}\n     * @return {Promise}\n     * @TODO: Support multi materials?\n     */\n\n    const switchMaterial = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (object, variantName, onUpdate) {\n        if (!object.userData.originalMaterial) {\n          object.userData.originalMaterial = object.material;\n        }\n\n        const oldMaterial = object.material;\n        let gltfMaterialIndex = null;\n\n        if (variantName === null || !object.userData.variantMaterials.has(variantName)) {\n          object.material = object.userData.originalMaterial;\n\n          if (parser.associations.has(object.material)) {\n            gltfMaterialIndex = parser.associations.get(object.material).index;\n          }\n        } else {\n          const variantMaterialParam = object.userData.variantMaterials.get(variantName);\n\n          if (variantMaterialParam.material) {\n            object.material = variantMaterialParam.material;\n\n            if ('gltfMaterialIndex' in variantMaterialParam) {\n              gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;\n            }\n          } else {\n            gltfMaterialIndex = variantMaterialParam.gltfMaterialIndex;\n            object.material = yield parser.getDependency('material', gltfMaterialIndex);\n            parser.assignFinalMaterial(object);\n            variantMaterialParam.material = object.material;\n          }\n        }\n\n        if (onUpdate !== null) {\n          onUpdate(object, oldMaterial, gltfMaterialIndex);\n        }\n      });\n\n      return function switchMaterial(_x5, _x6, _x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    /**\n     * @param object {THREE.Mesh}\n     * @return {Promise}\n     */\n\n\n    const ensureLoadVariants = object => {\n      const currentMaterial = object.material;\n      const variantMaterials = object.userData.variantMaterials;\n      const pending = [];\n\n      for (const variantName of variantMaterials.keys()) {\n        const variantMaterial = variantMaterials.get(variantName);\n\n        if (variantMaterial.material) {\n          continue;\n        }\n\n        const materialIndex = variantMaterial.gltfMaterialIndex;\n        pending.push(parser.getDependency('material', materialIndex).then(material => {\n          object.material = material;\n          parser.assignFinalMaterial(object);\n          variantMaterials.get(variantName).material = object.material;\n        }));\n      }\n\n      return Promise.all(pending).then(() => {\n        object.material = currentMaterial;\n      });\n    };\n    /**\n     * @param object {THREE.Object3D}\n     * @param variantName {string|null}\n     * @param doTraverse {boolean} Default is true\n     * @param onUpdate {function}\n     * @return {Promise}\n     */\n\n\n    gltf.userData.functions.selectVariant = (object, variantName, doTraverse = true, onUpdate = null) => {\n      const pending = [];\n\n      if (doTraverse) {\n        object.traverse(o => compatibleObject$1(o) && pending.push(switchMaterial(o, variantName, onUpdate)));\n      } else {\n        compatibleObject$1(object) && pending.push(switchMaterial(object, variantName, onUpdate));\n      }\n\n      return Promise.all(pending);\n    };\n    /**\n     * @param object {THREE.Object3D}\n     * @param doTraverse {boolean} Default is true\n     * @return {Promise}\n     */\n\n\n    gltf.userData.functions.ensureLoadVariants = (object, doTraverse = true) => {\n      const pending = [];\n\n      if (doTraverse) {\n        object.traverse(o => compatibleObject$1(o) && pending.push(ensureLoadVariants(o)));\n      } else {\n        compatibleObject$1(object) && pending.push(ensureLoadVariants(object));\n      }\n\n      return Promise.all(pending);\n    };\n\n    return Promise.resolve();\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a$9, _b$7;\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\n\n\nconst loadWithLoader = (url, loader, progressCallback = () => {}) => {\n  const onProgress = event => {\n    const fraction = event.loaded / event.total;\n    progressCallback(Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)));\n  };\n\n  return new Promise((resolve, reject) => {\n    loader.load(url, resolve, onProgress, reject);\n  });\n};\n\nconst cache = new Map();\nconst preloaded = new Map();\nlet dracoDecoderLocation;\nconst dracoLoader = new DRACOLoader();\nlet ktx2TranscoderLocation;\nconst ktx2Loader = new KTX2Loader();\nconst $loader = Symbol('loader');\nconst $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\n\nclass CachingGLTFLoader extends EventDispatcher {\n  constructor(GLTFInstance) {\n    super();\n    this[_b$7] = new GLTFLoader().register(parser => new GLTFMaterialsVariantsExtension(parser));\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n    this[$loader].setKTX2Loader(ktx2Loader);\n  }\n\n  static setDRACODecoderLocation(url) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n\n  static setKTX2TranscoderLocation(url) {\n    ktx2TranscoderLocation = url;\n    ktx2Loader.setTranscoderPath(url);\n  }\n\n  static getKTX2TranscoderLocation() {\n    return ktx2TranscoderLocation;\n  }\n\n  static initializeKTX2Loader(renderer) {\n    ktx2Loader.detectSupport(renderer);\n  }\n\n  static get cache() {\n    return cache;\n  }\n  /** @nocollapse */\n\n\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n\n  static has(url) {\n    return cache.has(url);\n  }\n  /** @nocollapse */\n\n\n  static delete(url) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this3.has(url)) {\n        return;\n      }\n\n      const gltfLoads = cache.get(url);\n      preloaded.delete(url);\n      cache.delete(url);\n      const gltf = yield gltfLoads; // Dispose of the cached glTF's materials and geometries:\n\n      gltf.dispose();\n    })();\n  }\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n\n\n  static hasFinishedLoading(url) {\n    return !!preloaded.get(url);\n  }\n\n  get [(_a$9 = $evictionPolicy, _b$7 = $loader, $evictionPolicy)]() {\n    return this.constructor[$evictionPolicy];\n  }\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n\n\n  preload(url, element, progressCallback = () => {}) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4.dispatchEvent({\n        type: 'preload',\n        element: element,\n        src: url\n      });\n\n      if (!cache.has(url)) {\n        const rawGLTFLoads = loadWithLoader(url, _this4[$loader], progress => {\n          progressCallback(progress * 0.8);\n        });\n        const GLTFInstance = _this4[$GLTFInstance];\n        const gltfInstanceLoads = rawGLTFLoads.then(rawGLTF => {\n          return GLTFInstance.prepare(rawGLTF);\n        }).then(preparedGLTF => {\n          progressCallback(0.9);\n          return new GLTFInstance(preparedGLTF);\n        });\n        cache.set(url, gltfInstanceLoads);\n      }\n\n      yield cache.get(url);\n      preloaded.set(url, true);\n\n      if (progressCallback) {\n        progressCallback(1.0);\n      }\n    })();\n  }\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n\n\n  load(url, element, progressCallback = () => {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.preload(url, element, progressCallback);\n      const gltf = yield cache.get(url);\n      const clone = yield gltf.clone();\n\n      _this5[$evictionPolicy].retain(url); // Patch dispose so that we can properly account for instance use\n      // in the caching layer:\n\n\n      clone.dispose = (() => {\n        const originalDispose = clone.dispose;\n        let disposed = false;\n        return () => {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n          originalDispose.apply(clone);\n\n          _this5[$evictionPolicy].release(url);\n        };\n      })();\n\n      return clone;\n    })();\n  }\n\n}\n\nCachingGLTFLoader[_a$9] = new CacheEvictionPolicy(CachingGLTFLoader);\n\nclass CSS2DObject extends Object3D {\n  constructor(element) {\n    super();\n    this.element = element || document.createElement('div');\n    this.element.style.position = 'absolute';\n    this.element.style.userSelect = 'none';\n    this.element.setAttribute('draggable', false);\n    this.addEventListener('removed', function () {\n      this.traverse(function (object) {\n        if (object.element instanceof Element && object.element.parentNode !== null) {\n          object.element.parentNode.removeChild(object.element);\n        }\n      });\n    });\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.element = source.element.cloneNode(true);\n    return this;\n  }\n\n}\n\nCSS2DObject.prototype.isCSS2DObject = true; //\n\nconst _vector = new Vector3();\n\nconst _viewMatrix = new Matrix4();\n\nconst _viewProjectionMatrix = new Matrix4();\n\nconst _a$8 = new Vector3();\n\nconst _b$6 = new Vector3();\n\nclass CSS2DRenderer {\n  constructor() {\n    const _this = this;\n\n    let _width, _height;\n\n    let _widthHalf, _heightHalf;\n\n    const cache = {\n      objects: new WeakMap()\n    };\n    const domElement = document.createElement('div');\n    domElement.style.overflow = 'hidden';\n    this.domElement = domElement;\n\n    this.getSize = function () {\n      return {\n        width: _width,\n        height: _height\n      };\n    };\n\n    this.render = function (scene, camera) {\n      if (scene.autoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null) camera.updateMatrixWorld();\n\n      _viewMatrix.copy(camera.matrixWorldInverse);\n\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n\n      renderObject(scene, scene, camera);\n      zOrder(scene);\n    };\n\n    this.setSize = function (width, height) {\n      _width = width;\n      _height = height;\n      _widthHalf = _width / 2;\n      _heightHalf = _height / 2;\n      domElement.style.width = width + 'px';\n      domElement.style.height = height + 'px';\n    };\n\n    function renderObject(object, scene, camera) {\n      if (object.isCSS2DObject) {\n        object.onBeforeRender(_this, scene, camera);\n\n        _vector.setFromMatrixPosition(object.matrixWorld);\n\n        _vector.applyMatrix4(_viewProjectionMatrix);\n\n        const element = object.element;\n\n        if (/apple/i.test(navigator.vendor)) {\n          // https://github.com/mrdoob/three.js/issues/21415\n          element.style.transform = 'translate(-50%,-50%) translate(' + Math.round(_vector.x * _widthHalf + _widthHalf) + 'px,' + Math.round(-_vector.y * _heightHalf + _heightHalf) + 'px)';\n        } else {\n          element.style.transform = 'translate(-50%,-50%) translate(' + (_vector.x * _widthHalf + _widthHalf) + 'px,' + (-_vector.y * _heightHalf + _heightHalf) + 'px)';\n        }\n\n        element.style.display = object.visible && _vector.z >= -1 && _vector.z <= 1 ? '' : 'none';\n        const objectData = {\n          distanceToCameraSquared: getDistanceToSquared(camera, object)\n        };\n        cache.objects.set(object, objectData);\n\n        if (element.parentNode !== domElement) {\n          domElement.appendChild(element);\n        }\n\n        object.onAfterRender(_this, scene, camera);\n      }\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        renderObject(object.children[i], scene, camera);\n      }\n    }\n\n    function getDistanceToSquared(object1, object2) {\n      _a$8.setFromMatrixPosition(object1.matrixWorld);\n\n      _b$6.setFromMatrixPosition(object2.matrixWorld);\n\n      return _a$8.distanceToSquared(_b$6);\n    }\n\n    function filterAndFlatten(scene) {\n      const result = [];\n      scene.traverse(function (object) {\n        if (object.isCSS2DObject) result.push(object);\n      });\n      return result;\n    }\n\n    function zOrder(scene) {\n      const sorted = filterAndFlatten(scene).sort(function (a, b) {\n        const distanceA = cache.objects.get(a).distanceToCameraSquared;\n        const distanceB = cache.objects.get(b).distanceToCameraSquared;\n        return distanceA - distanceB;\n      });\n      const zMax = sorted.length;\n\n      for (let i = 0, l = sorted.length; i < l; i++) {\n        sorted[i].element.style.zIndex = zMax - i;\n      }\n    }\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst deserializeUrl = url => !!url && url !== 'null' ? toFullUrl(url) : null;\n\nconst assertIsArCandidate = () => {\n  if (IS_WEBXR_AR_CANDIDATE) {\n    return;\n  }\n\n  const missingApis = [];\n\n  if (!HAS_WEBXR_DEVICE_API) {\n    missingApis.push('WebXR Device API');\n  }\n\n  if (!HAS_WEBXR_HIT_TEST_API) {\n    missingApis.push('WebXR Hit Test API');\n  }\n\n  throw new Error(`The following APIs are required for AR, but are missing in this browser: ${missingApis.join(', ')}`);\n};\n/**\n * Converts a partial URL string to a fully qualified URL string.\n *\n * @param {String} url\n * @return {String}\n */\n\n\nconst toFullUrl = partialUrl => {\n  const url = new URL(partialUrl, window.location.toString());\n  return url.toString();\n};\n/**\n * Returns a throttled version of a given function that is only invoked at most\n * once within a given threshold of time in milliseconds.\n *\n * The throttled version of the function has a \"flush\" property that resets the\n * threshold for cases when immediate invokation is desired.\n */\n\n\nconst throttle = (fn, ms) => {\n  let timer = null;\n\n  const throttled = (...args) => {\n    if (timer != null) {\n      return;\n    }\n\n    fn(...args);\n    timer = self.setTimeout(() => timer = null, ms);\n  };\n\n  throttled.flush = () => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n      timer = null;\n    }\n  };\n\n  return throttled;\n};\n\nconst debounce = (fn, ms) => {\n  let timer = null;\n  return (...args) => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n    }\n\n    timer = self.setTimeout(() => {\n      timer = null;\n      fn(...args);\n    }, ms);\n  };\n};\n/**\n * @param {Number} value\n * @param {Number} lowerLimit\n * @param {Number} upperLimit\n * @return {Number} value clamped within lowerLimit..upperLimit\n */\n\n\nconst clamp = (value, lowerLimit, upperLimit) => Math.max(lowerLimit, Math.min(upperLimit, value)); // The DPR we use for a \"capped\" scenario (see resolveDpr below):\n\n\nconst CAPPED_DEVICE_PIXEL_RATIO = 1;\n/**\n * This helper analyzes the layout of the current page to decide if we should\n * use the natural device pixel ratio, or a capped value.\n *\n * We cap DPR if there is no meta viewport (suggesting that user is not\n * consciously specifying how to scale the viewport relative to the device\n * screen size).\n *\n * The rationale is that this condition typically leads to a pathological\n * outcome on mobile devices. When the window dimensions are scaled up on a\n * device with a high DPR, we create a canvas that is much larger than\n * appropriate to accomodate for the pixel density if we naively use the\n * reported DPR.\n *\n * This value needs to be measured in real time, as device pixel ratio can\n * change over time (e.g., when a user zooms the page). Also, in some cases\n * (such as Firefox on Android), the window's innerWidth is initially reported\n * as the same as the screen's availWidth but changes later.\n *\n * A user who specifies a meta viewport, thereby consciously creating scaling\n * conditions where <model-viewer> is slow, will be encouraged to live their\n * best life.\n */\n\nconst resolveDpr = (() => {\n  // If true, implies that the user is conscious of the viewport scaling\n  // relative to the device screen size.\n  const HAS_META_VIEWPORT_TAG = (() => {\n    const metas = document.head != null ? Array.from(document.head.querySelectorAll('meta')) : [];\n\n    for (const meta of metas) {\n      if (meta.name === 'viewport') {\n        return true;\n      }\n    }\n\n    return false;\n  })();\n\n  if (!HAS_META_VIEWPORT_TAG) {\n    console.warn('No <meta name=\"viewport\"> detected; <model-viewer> will cap pixel density at 1.');\n  }\n\n  return () => HAS_META_VIEWPORT_TAG ? window.devicePixelRatio : CAPPED_DEVICE_PIXEL_RATIO;\n})();\n/**\n * Debug mode is enabled when one of the two following conditions is true:\n *\n *  1. A 'model-viewer-debug-mode' query parameter is present in the current\n *     search string\n *  2. There is a global object ModelViewerElement with a debugMode property set\n *     to true\n */\n\n\nconst isDebugMode = (() => {\n  const debugQueryParameterName = 'model-viewer-debug-mode';\n  const debugQueryParameter = new RegExp(`[?&]${debugQueryParameterName}(&|$)`);\n  return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(debugQueryParameter);\n})();\n/**\n * Returns the first key in a Map in iteration order.\n *\n * NOTE(cdata): This is necessary because IE11 does not implement iterator\n * methods of Map, and polymer-build does not polyfill these methods for\n * compatibility and performance reasons. This helper proposes that it is\n * a reasonable compromise to sacrifice a very small amount of runtime\n * performance in IE11 for the sake of code clarity.\n */\n\n\nconst getFirstMapKey = map => {\n  if (map.keys != null) {\n    return map.keys().next().value || null;\n  }\n\n  let firstKey = null;\n\n  try {\n    map.forEach((_value, key, _map) => {\n      firstKey = key; // Stop iterating the Map with forEach:\n\n      throw new Error();\n    });\n  } catch (_error) {}\n\n  return firstKey;\n};\n\nconst timePasses = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms));\n/**\n * @param {EventTarget|EventDispatcher} target\n * @param {string} eventName\n * @param {?Function} predicate\n */\n\n\nconst waitForEvent = (target, eventName, predicate = null) => new Promise(resolve => {\n  function handler(event) {\n    if (!predicate || predicate(event)) {\n      resolve(event);\n      target.removeEventListener(eventName, handler);\n    }\n  }\n\n  target.addEventListener(eventName, handler);\n});\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst SETTLING_TIME = 10000; // plenty long enough\n\nconst MIN_DECAY_MILLISECONDS = 0.001;\nconst DECAY_MILLISECONDS = 50;\n/**\n * The Damper class is a generic second-order critically damped system that does\n * one linear step of the desired length of time. The only parameter is\n * DECAY_MILLISECONDS. This common parameter makes all states converge at the\n * same rate regardless of scale. xNormalization is a number to provide the\n * rough scale of x, such that NIL_SPEED clamping also happens at roughly the\n * same convergence for all states.\n */\n\nclass Damper {\n  constructor(decayMilliseconds = DECAY_MILLISECONDS) {\n    this.velocity = 0;\n    this.naturalFrequency = 0;\n    this.setDecayTime(decayMilliseconds);\n  }\n\n  setDecayTime(decayMilliseconds) {\n    this.naturalFrequency = 1 / Math.max(MIN_DECAY_MILLISECONDS, decayMilliseconds);\n  }\n\n  update(x, xGoal, timeStepMilliseconds, xNormalization) {\n    const nilSpeed = 0.0002 * this.naturalFrequency;\n\n    if (x == null || xNormalization === 0) {\n      return xGoal;\n    }\n\n    if (x === xGoal && this.velocity === 0) {\n      return xGoal;\n    }\n\n    if (timeStepMilliseconds < 0) {\n      return x;\n    } // Exact solution to a critically damped second-order system, where:\n    // acceleration = this.naturalFrequency * this.naturalFrequency * (xGoal\n    // - x) - 2 * this.naturalFrequency * this.velocity;\n\n\n    const deltaX = x - xGoal;\n    const intermediateVelocity = this.velocity + this.naturalFrequency * deltaX;\n    const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;\n    const decay = Math.exp(-this.naturalFrequency * timeStepMilliseconds);\n    const newVelocity = (intermediateVelocity - this.naturalFrequency * intermediateX) * decay;\n    const acceleration = -this.naturalFrequency * (newVelocity + intermediateVelocity * decay);\n\n    if (Math.abs(newVelocity) < nilSpeed * Math.abs(xNormalization) && acceleration * deltaX >= 0) {\n      // This ensures the controls settle and stop calling this function instead\n      // of asymptotically approaching their goal.\n      this.velocity = 0;\n      return xGoal;\n    } else {\n      this.velocity = newVelocity;\n      return xGoal + intermediateX * decay;\n    }\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst numberNode = (value, unit) => ({\n  type: 'number',\n  number: value,\n  unit\n});\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexidecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\n\n\nconst parseExpressions = (() => {\n  const cache = {};\n  const MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large\n\n  return inputString => {\n    const cacheKey = inputString;\n\n    if (cacheKey in cache) {\n      return cache[cacheKey];\n    }\n\n    const expressions = [];\n    let parseIterations = 0;\n\n    while (inputString) {\n      if (++parseIterations > MAX_PARSE_ITERATIONS) {\n        // Avoid a potentially infinite loop due to typos:\n        inputString = '';\n        break;\n      }\n\n      const expressionParseResult = parseExpression(inputString);\n      const expression = expressionParseResult.nodes[0];\n\n      if (expression == null || expression.terms.length === 0) {\n        break;\n      }\n\n      expressions.push(expression);\n      inputString = expressionParseResult.remainingInput;\n    }\n\n    return cache[cacheKey] = expressions;\n  };\n})();\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invokation.\n */\n\n\nconst parseExpression = (() => {\n  const IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n  const IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n  const IS_EXPRESSION_END_RE = /^[\\),]/;\n  const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n  const HEX_FIRST_TOKEN = '#';\n  return inputString => {\n    const terms = [];\n\n    while (inputString.length) {\n      inputString = inputString.trim();\n\n      if (IS_EXPRESSION_END_RE.test(inputString)) {\n        break;\n      } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n        const {\n          nodes,\n          remainingInput\n        } = parseFunctionArguments(inputString);\n        inputString = remainingInput;\n        terms.push({\n          type: 'function',\n          name: {\n            type: 'ident',\n            value: 'calc'\n          },\n          arguments: nodes\n        });\n      } else if (IS_IDENT_RE.test(inputString)) {\n        const identParseResult = parseIdent(inputString);\n        const identNode = identParseResult.nodes[0];\n        inputString = identParseResult.remainingInput;\n\n        if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n          const {\n            nodes,\n            remainingInput\n          } = parseFunctionArguments(inputString);\n          terms.push({\n            type: 'function',\n            name: identNode,\n            arguments: nodes\n          });\n          inputString = remainingInput;\n        } else {\n          terms.push(identNode);\n        }\n      } else if (IS_OPERATOR_RE.test(inputString)) {\n        // Operators are always a single character, so just pluck them out:\n        terms.push({\n          type: 'operator',\n          value: inputString[0]\n        });\n        inputString = inputString.slice(1);\n      } else {\n        const {\n          nodes,\n          remainingInput\n        } = inputString[0] === HEX_FIRST_TOKEN ? parseHex(inputString) : parseNumber(inputString); // The remaining string may not have had any meaningful content. Exit\n        // early if this is the case:\n\n        if (nodes.length === 0) {\n          break;\n        }\n\n        terms.push(nodes[0]);\n        inputString = remainingInput;\n      }\n    }\n\n    return {\n      nodes: [{\n        type: 'expression',\n        terms\n      }],\n      remainingInput: inputString\n    };\n  };\n})();\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\n\n\nconst parseIdent = (() => {\n  const NOT_IDENT_RE = /[^a-z0-9_\\-\\u0240-\\uffff]/i;\n  return inputString => {\n    const match = inputString.match(NOT_IDENT_RE);\n    const ident = match == null ? inputString : inputString.substr(0, match.index);\n    const remainingInput = match == null ? '' : inputString.substr(match.index);\n    return {\n      nodes: [{\n        type: 'ident',\n        value: ident\n      }],\n      remainingInput\n    };\n  };\n})();\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\n\n\nconst parseNumber = (() => {\n  // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n  const VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n  const UNIT_RE = /^[a-z%]+/i;\n  const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n  return inputString => {\n    const valueMatch = inputString.match(VALUE_RE);\n    const value = valueMatch == null ? '0' : valueMatch[0];\n    inputString = value == null ? inputString : inputString.slice(value.length);\n    const unitMatch = inputString.match(UNIT_RE);\n    let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n    const remainingInput = unitMatch == null ? inputString : inputString.slice(unit.length);\n\n    if (unit != null && !ALLOWED_UNITS.test(unit)) {\n      unit = null;\n    }\n\n    return {\n      nodes: [{\n        type: 'number',\n        number: parseFloat(value) || 0,\n        unit: unit\n      }],\n      remainingInput\n    };\n  };\n})();\n/**\n * Parses a hexidecimal-encoded color in 3, 6 or 8 digit form.\n */\n\n\nconst parseHex = (() => {\n  // TODO(cdata): right now we don't actually enforce the number of digits\n  const HEX_RE = /^[a-f0-9]*/i;\n  return inputString => {\n    inputString = inputString.slice(1).trim();\n    const hexMatch = inputString.match(HEX_RE);\n    const nodes = hexMatch == null ? [] : [{\n      type: 'hex',\n      value: hexMatch[0]\n    }];\n    return {\n      nodes,\n      remainingInput: hexMatch == null ? inputString : inputString.slice(hexMatch[0].length)\n    };\n  };\n})();\n/**\n * Parses arguments passed to a function invokation (e.g., the expressions\n * within a matched set of parens).\n */\n\n\nconst parseFunctionArguments = inputString => {\n  const expressionNodes = []; // Consume the opening paren\n\n  inputString = inputString.slice(1).trim();\n\n  while (inputString.length) {\n    const expressionParseResult = parseExpression(inputString);\n    expressionNodes.push(expressionParseResult.nodes[0]);\n    inputString = expressionParseResult.remainingInput.trim();\n\n    if (inputString[0] === ',') {\n      inputString = inputString.slice(1).trim();\n    } else if (inputString[0] === ')') {\n      // Consume the closing paren and stop parsing\n      inputString = inputString.slice(1);\n      break;\n    }\n  }\n\n  return {\n    nodes: expressionNodes,\n    remainingInput: inputString\n  };\n};\n\nconst $visitedTypes = Symbol('visitedTypes');\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\n\nclass ASTWalker {\n  constructor(visitedTypes) {\n    this[$visitedTypes] = visitedTypes;\n  }\n  /**\n   * Walk the given set of ASTs, and invoke the provided callback for nodes that\n   * match the filtered set that the ASTWalker was constructed with.\n   */\n\n\n  walk(ast, callback) {\n    const remaining = ast.slice();\n\n    while (remaining.length) {\n      const next = remaining.shift();\n\n      if (this[$visitedTypes].indexOf(next.type) > -1) {\n        callback(next);\n      }\n\n      switch (next.type) {\n        case 'expression':\n          remaining.unshift(...next.terms);\n          break;\n\n        case 'function':\n          remaining.unshift(next.name, ...next.arguments);\n          break;\n      }\n    }\n  }\n\n}\n\nconst ZERO = Object.freeze({\n  type: 'number',\n  number: 0,\n  unit: null\n});\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Ensures that a given number is expressed in radians. If the number is already\n * in radians, does nothing. If the value is in degrees, converts it to radians.\n * If the value has no specified unit, the unit is assumed to be radians. If the\n * value is not in radians or degrees, the value is resolved as 0 radians.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\n\nconst degreesToRadians = (numberNode, fallbackRadianValue = 0) => {\n  let {\n    number,\n    unit\n  } = numberNode;\n\n  if (!isFinite(number)) {\n    number = fallbackRadianValue;\n    unit = 'rad';\n  } else if (numberNode.unit === 'rad' || numberNode.unit == null) {\n    return numberNode;\n  }\n\n  const valueIsDegrees = unit === 'deg' && number != null;\n  const value = valueIsDegrees ? number : 0;\n  const radians = value * Math.PI / 180;\n  return {\n    type: 'number',\n    number: radians,\n    unit: 'rad'\n  };\n};\n/**\n * Converts a given length to meters. Currently supported input units are\n * meters, centimeters and millimeters.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\n\n\nconst lengthToBaseMeters = (numberNode, fallbackMeterValue = 0) => {\n  let {\n    number,\n    unit\n  } = numberNode;\n\n  if (!isFinite(number)) {\n    number = fallbackMeterValue;\n    unit = 'm';\n  } else if (numberNode.unit === 'm') {\n    return numberNode;\n  }\n\n  let scale;\n\n  switch (unit) {\n    default:\n      scale = 1;\n      break;\n\n    case 'cm':\n      scale = 1 / 100;\n      break;\n\n    case 'mm':\n      scale = 1 / 1000;\n      break;\n  }\n\n  const value = scale * number;\n  return {\n    type: 'number',\n    number: value,\n    unit: 'm'\n  };\n};\n/**\n * Normalizes the unit of a given input number so that it is expressed in a\n * preferred unit. For length nodes, the return value will be expressed in\n * meters. For angle nodes, the return value will be expressed in radians.\n *\n * Also takes a fallback number that is used when the number value is not a\n * valid number or when the unit of the given number cannot be normalized.\n */\n\n\nconst normalizeUnit = (() => {\n  const identity = node => node;\n\n  const unitNormalizers = {\n    'rad': identity,\n    'deg': degreesToRadians,\n    'm': identity,\n    'mm': lengthToBaseMeters,\n    'cm': lengthToBaseMeters\n  };\n  return (node, fallback = ZERO) => {\n    if (!isFinite(node.number)) {\n      node.number = fallback.number;\n      node.unit = fallback.unit;\n    }\n\n    const {\n      unit\n    } = node;\n\n    if (unit == null) {\n      return node;\n    }\n\n    const normalize = unitNormalizers[unit];\n\n    if (normalize == null) {\n      return fallback;\n    }\n\n    return normalize(node);\n  };\n})();\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The Hotspot object is a reference-counted slot. If decrement() returns true,\n * it should be removed from the tree so it can be garbage-collected.\n */\n\n\nclass Hotspot extends CSS2DObject {\n  constructor(config) {\n    super(document.createElement('div'));\n    this.normal = new Vector3(0, 1, 0);\n    this.initialized = false;\n    this.referenceCount = 1;\n    this.pivot = document.createElement('div');\n    this.slot = document.createElement('slot');\n    this.element.classList.add('annotation-wrapper');\n    this.slot.name = config.name;\n    this.element.appendChild(this.pivot);\n    this.pivot.appendChild(this.slot);\n    this.updatePosition(config.position);\n    this.updateNormal(config.normal);\n  }\n\n  get facingCamera() {\n    return !this.element.classList.contains('hide');\n  }\n  /**\n   * Sets the hotspot to be in the highly visible foreground state.\n   */\n\n\n  show() {\n    if (!this.facingCamera || !this.initialized) {\n      this.updateVisibility(true);\n    }\n  }\n  /**\n   * Sets the hotspot to be in the diminished background state.\n   */\n\n\n  hide() {\n    if (this.facingCamera || !this.initialized) {\n      this.updateVisibility(false);\n    }\n  }\n  /**\n   * Call this when adding elements to the same slot to keep track.\n   */\n\n\n  increment() {\n    this.referenceCount++;\n  }\n  /**\n   * Call this when removing elements from the slot; returns true when the slot\n   * is unused.\n   */\n\n\n  decrement() {\n    if (this.referenceCount > 0) {\n      --this.referenceCount;\n    }\n\n    return this.referenceCount === 0;\n  }\n  /**\n   * Change the position of the hotspot to the input string, in the same format\n   * as the data-position attribute.\n   */\n\n\n  updatePosition(position) {\n    if (position == null) return;\n    const positionNodes = parseExpressions(position)[0].terms;\n\n    for (let i = 0; i < 3; ++i) {\n      this.position.setComponent(i, normalizeUnit(positionNodes[i]).number);\n    }\n\n    this.updateMatrixWorld();\n  }\n  /**\n   * Change the hotspot's normal to the input string, in the same format as the\n   * data-normal attribute.\n   */\n\n\n  updateNormal(normal) {\n    if (normal == null) return;\n    const normalNodes = parseExpressions(normal)[0].terms;\n\n    for (let i = 0; i < 3; ++i) {\n      this.normal.setComponent(i, normalizeUnit(normalNodes[i]).number);\n    }\n  }\n\n  orient(radians) {\n    this.pivot.style.transform = `rotate(${radians}rad)`;\n  }\n\n  updateVisibility(show) {\n    // NOTE: IE11 doesn't support a second arg for classList.toggle\n    if (show) {\n      this.element.classList.remove('hide');\n    } else {\n      this.element.classList.add('hide');\n    } // NOTE: ShadyDOM doesn't support slot.assignedElements, otherwise we could\n    // use that here.\n\n\n    this.slot.assignedNodes().forEach(node => {\n      if (node.nodeType !== Node.ELEMENT_NODE) {\n        return;\n      }\n\n      const element = node; // Visibility attribute can be configured per-node in the hotspot:\n\n      const visibilityAttribute = element.dataset.visibilityAttribute;\n\n      if (visibilityAttribute != null) {\n        const attributeName = `data-${visibilityAttribute}`; // NOTE: IE11 doesn't support toggleAttribute\n\n        if (show) {\n          element.setAttribute(attributeName, '');\n        } else {\n          element.removeAttribute(attributeName);\n        }\n      }\n\n      element.dispatchEvent(new CustomEvent('hotspot-visibility', {\n        detail: {\n          visible: show\n        }\n      }));\n    });\n    this.initialized = true;\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Gets a scale value to perform inverse quantization of a vertex value\n * Reference:\n * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n * @param buffer A gltf vertex buffer\n * @returns A scale value based on KHR_mesh_quantization or 1 if the buffer is\n *     not quantized.\n */\n\n\nconst getNormalizedComponentScale = buffer => {\n  if (!buffer.normalized) {\n    return 1;\n  }\n\n  const array = buffer.array;\n\n  if (array instanceof Int8Array) {\n    return 1 / 127;\n  } else if (array instanceof Uint8Array) {\n    return 1 / 255;\n  } else if (array instanceof Int16Array) {\n    return 1 / 32767;\n  } else if (array instanceof Uint16Array) {\n    return 1 / 65535;\n  }\n\n  return 1;\n};\n/**\n * Performs a reduction across all the vertices of the input model and all its\n * children. The supplied function takes the reduced value and a vertex and\n * returns the newly reduced value. The value is initialized as zero.\n *\n * Adapted from Three.js, @see https://github.com/mrdoob/three.js/blob/7e0a78beb9317e580d7fa4da9b5b12be051c6feb/src/math/Box3.js#L241\n */\n\n\nconst reduceVertices = (model, func, initialValue) => {\n  let value = initialValue;\n  const vertex = new Vector3();\n  model.traverse(object => {\n    let i, l;\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n\n    if (geometry !== undefined) {\n      if (geometry.isGeometry) {\n        const vertices = geometry.vertices;\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex.copy(vertices[i]);\n          vertex.applyMatrix4(object.matrixWorld);\n          value = func(value, vertex);\n        }\n      } else if (geometry.isBufferGeometry) {\n        const {\n          position\n        } = geometry.attributes;\n\n        if (position !== undefined) {\n          const scale = getNormalizedComponentScale(position);\n\n          for (i = 0, l = position.count; i < l; i++) {\n            vertex.fromBufferAttribute(position, i);\n            vertex.multiplyScalar(scale);\n            vertex.applyMatrix4(object.matrixWorld);\n            value = func(value, vertex);\n          }\n        }\n      }\n    }\n  });\n  return value;\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Nothing within Offset of the bottom of the scene casts a shadow\n// (this is to avoid having a baked-in shadow plane cast its own shadow).\n\n\nconst OFFSET = 0.002; // The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\n\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6; // Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimesion multiplied\n// by this scale factor.\n\nconst ANIMATION_SCALING = 2;\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\n\nclass Shadow extends DirectionalLight {\n  constructor(scene, softness, side) {\n    super();\n    this.shadowMaterial = new ShadowMaterial();\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.shadowScale = 1;\n    this.isAnimated = false;\n    this.side = 'bottom';\n    this.needsUpdate = false; // We use the light only to cast a shadow, not to light the scene.\n\n    this.intensity = 0;\n    this.castShadow = true;\n    this.frustumCulled = false;\n    this.floor = new Mesh(new PlaneGeometry(), this.shadowMaterial);\n    this.floor.rotateX(-Math.PI / 2);\n    this.floor.receiveShadow = true;\n    this.floor.castShadow = false;\n    this.floor.frustumCulled = false;\n    this.add(this.floor);\n    scene.target.add(this);\n    this.target = scene.target;\n    this.setScene(scene, softness, side);\n  }\n  /**\n   * Update the shadow's size and position for a new scene. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n\n\n  setScene(scene, softness, side) {\n    this.side = side;\n    this.isAnimated = scene.animationNames.length > 0;\n    this.boundingBox.copy(scene.boundingBox);\n    this.size.copy(scene.size);\n\n    if (this.side === 'back') {\n      const {\n        min,\n        max\n      } = this.boundingBox;\n      [min.y, min.z] = [min.z, min.y];\n      [max.y, max.z] = [max.z, max.y];\n      [this.size.y, this.size.z] = [this.size.z, this.size.y];\n      this.rotation.x = Math.PI / 2;\n      this.rotation.y = Math.PI;\n    }\n\n    const {\n      boundingBox,\n      size\n    } = this;\n\n    if (this.isAnimated) {\n      const maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;\n      size.y = maxDimension;\n      boundingBox.expandByVector(size.subScalar(maxDimension).multiplyScalar(-0.5));\n      boundingBox.max.y = boundingBox.min.y + maxDimension;\n      size.set(maxDimension, maxDimension, maxDimension);\n    }\n\n    boundingBox.getCenter(this.floor.position);\n    const shadowOffset = boundingBox.max.y + size.y * OFFSET;\n\n    if (side === 'bottom') {\n      this.position.y = shadowOffset;\n      this.shadow.camera.up.set(0, 0, 1);\n    } else {\n      this.position.y = 0;\n      this.position.z = shadowOffset;\n      this.shadow.camera.up.set(0, 1, 0);\n    }\n\n    this.setSoftness(softness);\n  }\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n\n\n  setSoftness(softness) {\n    const resolution = Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n  }\n  /**\n   * Lower-level version of the above function.\n   */\n\n\n  setMapSize(maxMapSize) {\n    const {\n      camera,\n      mapSize,\n      map\n    } = this.shadow;\n    const {\n      size,\n      boundingBox\n    } = this;\n\n    if (map != null) {\n      map.dispose();\n      this.shadow.map = null;\n    }\n\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n\n    const width = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const height = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n    mapSize.set(width, height); // These pads account for the softening radius around the shadow.\n\n    const widthPad = 2.5 * size.x / width;\n    const heightPad = 2.5 * size.z / height;\n    camera.left = -boundingBox.max.x - widthPad;\n    camera.right = -boundingBox.min.x + widthPad;\n    camera.bottom = boundingBox.min.z - heightPad;\n    camera.top = boundingBox.max.z + heightPad;\n    this.setScaleAndOffset(this.shadowScale, 0);\n    this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n\n\n  setIntensity(intensity) {\n    this.shadowMaterial.opacity = intensity;\n\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n\n  getIntensity() {\n    return this.shadowMaterial.opacity;\n  }\n  /**\n   * The shadow does not rotate with its parent transforms, so the rotation must\n   * be manually updated here if it rotates in world space. The input is its\n   * absolute orientation about the Y-axis (other rotations are not supported).\n   */\n\n\n  setRotation(radiansY) {\n    if (this.side !== 'bottom') {\n      // We don't support rotation about a horizontal axis yet.\n      this.shadow.updateMatrices(this);\n      return;\n    }\n\n    this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));\n    this.shadow.updateMatrices(this);\n  }\n  /**\n   * The scale is also not inherited from parents, so it must be set here in\n   * accordance with any transforms. An offset can also be specified to move the\n   * shadow vertically relative to the bottom of the scene. Positive is up, so\n   * values are generally negative.\n   */\n\n\n  setScaleAndOffset(scale, offset) {\n    const sizeY = this.size.y;\n    const {\n      camera\n    } = this.shadow;\n    this.shadowScale = scale;\n    camera.near = 0;\n    camera.far = sizeY - offset / scale;\n    camera.updateProjectionMatrix();\n    camera.scale.setScalar(scale); // Floor plane is up slightly from the bottom of the bounding box to avoid\n    // Z-fighting with baked-in shadows and to stay inside the shadow camera.\n\n    const shadowOffset = sizeY * OFFSET;\n    this.floor.position.y = 2 * shadowOffset - camera.far;\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst DEFAULT_FOV_DEG = 45;\nconst DEFAULT_HALF_FOV = DEFAULT_FOV_DEG / 2 * Math.PI / 180;\nconst SAFE_RADIUS_RATIO = Math.sin(DEFAULT_HALF_FOV);\nconst DEFAULT_TAN_FOV = Math.tan(DEFAULT_HALF_FOV);\nconst view = new Vector3();\nconst target = new Vector3();\nconst normalWorld = new Vector3();\nconst raycaster = new Raycaster();\nconst vector3$1 = new Vector3();\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\n\nclass ModelScene extends Scene {\n  constructor({\n    canvas,\n    element,\n    width,\n    height\n  }) {\n    super();\n    this.context = null;\n    this.annotationRenderer = new CSS2DRenderer();\n    this.width = 1;\n    this.height = 1;\n    this.aspect = 1;\n    this.isDirty = false;\n    this.renderCount = 0;\n    this.externalRenderer = null; // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.xrCamera = null;\n    this.url = null;\n    this.target = new Object3D();\n    this.modelContainer = new Object3D();\n    this.animationNames = [];\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.idealCameraDistance = 0;\n    this.fieldOfViewAspect = 0;\n    this.framedFieldOfView = DEFAULT_FOV_DEG;\n    this.shadow = null;\n    this.shadowIntensity = 0;\n    this.shadowSoftness = 1;\n    this.exposure = 1;\n    this.canScale = true;\n    this.tightBounds = false;\n    this.goalTarget = new Vector3();\n    this.targetDamperX = new Damper();\n    this.targetDamperY = new Damper();\n    this.targetDamperZ = new Damper();\n    this._currentGLTF = null;\n    this.cancelPendingSourceChange = null;\n    this.animationsByName = new Map();\n    this.currentAnimationAction = null;\n    this.name = 'ModelScene';\n    this.element = element;\n    this.canvas = canvas; // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.camera.name = 'MainCamera';\n    this.add(this.target);\n    this.setSize(width, height);\n    this.target.name = 'Target';\n    this.modelContainer.name = 'ModelContainer';\n    this.target.add(this.modelContainer);\n    this.mixer = new AnimationMixer(this.modelContainer);\n    const {\n      domElement\n    } = this.annotationRenderer;\n    const {\n      style\n    } = domElement;\n    style.display = 'none';\n    style.pointerEvents = 'none';\n    style.position = 'absolute';\n    style.top = '0';\n    this.element.shadowRoot.querySelector('.default').appendChild(domElement);\n  }\n  /**\n   * Function to create the context lazily, as when there is only one\n   * <model-viewer> element, the renderer's 3D context can be displayed\n   * directly. This extra context is necessary to copy the renderings into when\n   * there are more than one.\n   */\n\n\n  createContext() {\n    this.context = this.canvas.getContext('2d');\n  }\n\n  getCamera() {\n    return this.xrCamera != null ? this.xrCamera : this.camera;\n  }\n  /**\n   * Pass in a THREE.Object3D to be controlled\n   * by this model.\n   */\n\n\n  setObject(model) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      _this6.reset();\n\n      _this6.modelContainer.add(model);\n\n      yield _this6.setupScene();\n    })();\n  }\n  /**\n   * Sets the model via URL.\n   */\n\n\n  setSource(url, progressCallback = () => {}) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!url || url === _this7.url) {\n        progressCallback(1);\n        return;\n      }\n\n      _this7.reset();\n\n      _this7.url = url;\n\n      if (_this7.externalRenderer != null) {\n        const framingInfo = yield _this7.externalRenderer.load(progressCallback);\n        _this7.idealCameraDistance = framingInfo.framedRadius / SAFE_RADIUS_RATIO;\n        _this7.fieldOfViewAspect = framingInfo.fieldOfViewAspect;\n\n        _this7.frameModel();\n\n        _this7.dispatchEvent({\n          type: 'model-load',\n          url: _this7.url\n        });\n\n        return;\n      } // If we have pending work due to a previous source change in progress,\n      // cancel it so that we do not incur a race condition:\n\n\n      if (_this7.cancelPendingSourceChange != null) {\n        _this7.cancelPendingSourceChange();\n\n        _this7.cancelPendingSourceChange = null;\n      }\n\n      let gltf;\n\n      try {\n        gltf = yield new Promise( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (resolve, reject) {\n            _this7.cancelPendingSourceChange = () => reject();\n\n            try {\n              const result = yield _this7.element[$renderer].loader.load(url, _this7.element, progressCallback);\n              resolve(result);\n            } catch (error) {\n              reject(error);\n            }\n          });\n\n          return function (_x8, _x9) {\n            return _ref4.apply(this, arguments);\n          };\n        }());\n      } catch (error) {\n        if (error == null) {\n          // Loading was cancelled, so silently return\n          return;\n        }\n\n        throw error;\n      }\n\n      _this7.reset();\n\n      _this7.url = url;\n      _this7._currentGLTF = gltf;\n\n      if (gltf != null) {\n        _this7.modelContainer.add(gltf.scene);\n      }\n\n      const {\n        animations\n      } = gltf;\n      const animationsByName = new Map();\n      const animationNames = [];\n\n      for (const animation of animations) {\n        animationsByName.set(animation.name, animation);\n        animationNames.push(animation.name);\n      }\n\n      _this7.animations = animations;\n      _this7.animationsByName = animationsByName;\n      _this7.animationNames = animationNames;\n      yield _this7.setupScene();\n    })();\n  }\n\n  setupScene() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8.updateBoundingBox();\n\n      let target = null;\n\n      if (_this8.tightBounds === true) {\n        yield _this8.element.requestUpdate('cameraTarget');\n        target = _this8.getTarget();\n      }\n\n      _this8.updateFraming(target);\n\n      _this8.frameModel();\n\n      _this8.setShadowIntensity(_this8.shadowIntensity);\n\n      _this8.dispatchEvent({\n        type: 'model-load',\n        url: _this8.url\n      });\n    })();\n  }\n\n  reset() {\n    this.url = null;\n    this.isDirty = true;\n\n    if (this.shadow != null) {\n      this.shadow.setIntensity(0);\n    }\n\n    const gltf = this._currentGLTF; // Remove all current children\n\n    if (gltf != null) {\n      for (const child of this.modelContainer.children) {\n        this.modelContainer.remove(child);\n      }\n\n      gltf.dispose();\n      this._currentGLTF = null;\n    }\n\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n    this.mixer.uncacheRoot(this);\n  }\n\n  get currentGLTF() {\n    return this._currentGLTF;\n  }\n  /**\n   * Updates the ModelScene for a new container size in CSS pixels.\n   */\n\n\n  setSize(width, height) {\n    if (this.width === width && this.height === height) {\n      return;\n    }\n\n    this.width = Math.max(width, 1);\n    this.height = Math.max(height, 1);\n    this.annotationRenderer.setSize(width, height);\n    this.aspect = this.width / this.height;\n    this.frameModel();\n\n    if (this.externalRenderer != null) {\n      const dpr = resolveDpr();\n      this.externalRenderer.resize(width * dpr, height * dpr);\n    }\n\n    this.isDirty = true;\n  }\n\n  updateBoundingBox() {\n    this.target.remove(this.modelContainer);\n\n    if (this.tightBounds === true) {\n      const bound = (box, vertex) => {\n        return box.expandByPoint(vertex);\n      };\n\n      this.boundingBox = reduceVertices(this.modelContainer, bound, new Box3());\n    } else {\n      this.boundingBox.setFromObject(this.modelContainer);\n    }\n\n    this.boundingBox.getSize(this.size);\n    this.target.add(this.modelContainer);\n  }\n  /**\n   * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D\n   * object to be framed tightly in a 2D window of any aspect ratio without\n   * clipping at any camera orbit. The camera's center target point can be\n   * optionally specified. If no center is specified, it defaults to the center\n   * of the bounding box, which means asymmetric models will tend to be tight on\n   * one side instead of both. Proper choice of center can correct this.\n   */\n\n\n  updateFraming(center = null) {\n    this.target.remove(this.modelContainer);\n\n    if (center == null) {\n      center = this.boundingBox.getCenter(new Vector3());\n    }\n\n    const radiusSquared = (value, vertex) => {\n      return Math.max(value, center.distanceToSquared(vertex));\n    };\n\n    const framedRadius = Math.sqrt(reduceVertices(this.modelContainer, radiusSquared, 0));\n    this.idealCameraDistance = framedRadius / SAFE_RADIUS_RATIO;\n\n    const horizontalFov = (value, vertex) => {\n      vertex.sub(center);\n      const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);\n      return Math.max(value, radiusXZ / (this.idealCameraDistance - Math.abs(vertex.y)));\n    };\n\n    this.fieldOfViewAspect = reduceVertices(this.modelContainer, horizontalFov, 0) / DEFAULT_TAN_FOV;\n    this.target.add(this.modelContainer);\n  }\n  /**\n   * Set's the framedFieldOfView based on the aspect ratio of the window in\n   * order to keep the model fully visible at any camera orientation.\n   */\n\n\n  frameModel() {\n    const vertical = DEFAULT_TAN_FOV * Math.max(1, this.fieldOfViewAspect / this.aspect);\n    this.framedFieldOfView = 2 * Math.atan(vertical) * 180 / Math.PI;\n  }\n  /**\n   * Returns the size of the corresponding canvas element.\n   */\n\n\n  getSize() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n  /**\n   * Sets the point in model coordinates the model should orbit/pivot around.\n   */\n\n\n  setTarget(modelX, modelY, modelZ) {\n    this.goalTarget.set(-modelX, -modelY, -modelZ);\n  }\n  /**\n   * Set the decay time of, affects the speed of target transitions.\n   */\n\n\n  setTargetDamperDecayTime(decayMilliseconds) {\n    this.targetDamperX.setDecayTime(decayMilliseconds);\n    this.targetDamperY.setDecayTime(decayMilliseconds);\n    this.targetDamperZ.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Gets the point in model coordinates the model should orbit/pivot around.\n   */\n\n\n  getTarget() {\n    return vector3$1.copy(this.goalTarget).multiplyScalar(-1);\n  }\n  /**\n   * Shifts the model to the target point immediately instead of easing in.\n   */\n\n\n  jumpToGoal() {\n    this.updateTarget(SETTLING_TIME);\n  }\n  /**\n   * This should be called every frame with the frame delta to cause the target\n   * to transition to its set point.\n   */\n\n\n  updateTarget(delta) {\n    const goal = this.goalTarget;\n    const target = this.target.position;\n\n    if (!goal.equals(target)) {\n      const radius = this.idealCameraDistance;\n      let {\n        x,\n        y,\n        z\n      } = target;\n      x = this.targetDamperX.update(x, goal.x, delta, radius);\n      y = this.targetDamperY.update(y, goal.y, delta, radius);\n      z = this.targetDamperZ.update(z, goal.z, delta, radius);\n      this.target.position.set(x, y, z);\n      this.target.updateMatrixWorld();\n      this.setShadowRotation(this.yaw);\n      this.isDirty = true;\n    }\n  }\n  /**\n   * Yaw the +z (front) of the model toward the indicated world coordinates.\n   */\n\n\n  pointTowards(worldX, worldZ) {\n    const {\n      x,\n      z\n    } = this.position;\n    this.yaw = Math.atan2(worldX - x, worldZ - z);\n  }\n  /**\n   * Yaw is the scene's orientation about the y-axis, around the rotation\n   * center.\n   */\n\n\n  set yaw(radiansY) {\n    this.rotation.y = radiansY;\n    this.updateMatrixWorld(true);\n    this.setShadowRotation(radiansY);\n    this.isDirty = true;\n  }\n\n  get yaw() {\n    return this.rotation.y;\n  }\n\n  set animationTime(value) {\n    this.mixer.setTime(value);\n  }\n\n  get animationTime() {\n    if (this.currentAnimationAction != null) {\n      return this.currentAnimationAction.time;\n    }\n\n    return 0;\n  }\n\n  get duration() {\n    if (this.currentAnimationAction != null && this.currentAnimationAction.getClip()) {\n      return this.currentAnimationAction.getClip().duration;\n    }\n\n    return 0;\n  }\n\n  get hasActiveAnimation() {\n    return this.currentAnimationAction != null;\n  }\n  /**\n   * Plays an animation if there are any associated with the current model.\n   * Accepts an optional string name of an animation to play. If no name is\n   * provided, or if no animation is found by the given name, always falls back\n   * to playing the first animation.\n   */\n\n\n  playAnimation(name = null, crossfadeTime = 0) {\n    if (this._currentGLTF == null) {\n      return;\n    }\n\n    const {\n      animations\n    } = this;\n\n    if (animations == null || animations.length === 0) {\n      console.warn(`Cannot play animation (model does not have any animations)`);\n      return;\n    }\n\n    let animationClip = null;\n\n    if (name != null) {\n      animationClip = this.animationsByName.get(name);\n    }\n\n    if (animationClip == null) {\n      animationClip = animations[0];\n    }\n\n    try {\n      const {\n        currentAnimationAction: lastAnimationAction\n      } = this;\n      this.currentAnimationAction = this.mixer.clipAction(animationClip, this).play();\n      this.currentAnimationAction.enabled = true;\n\n      if (lastAnimationAction != null && this.currentAnimationAction !== lastAnimationAction) {\n        this.currentAnimationAction.crossFadeFrom(lastAnimationAction, crossfadeTime, false);\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  stopAnimation() {\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction.reset();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n  }\n\n  updateAnimation(step) {\n    this.mixer.update(step);\n  }\n  /**\n   * Call if the object has been changed in such a way that the shadow's shape\n   * has changed (not a rotation about the Y axis).\n   */\n\n\n  updateShadow() {\n    const shadow = this.shadow;\n\n    if (shadow != null) {\n      const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';\n      shadow.setScene(this, this.shadowSoftness, side);\n    }\n  }\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n\n\n  setShadowIntensity(shadowIntensity) {\n    this.shadowIntensity = shadowIntensity;\n\n    if (this._currentGLTF == null) {\n      return;\n    }\n\n    let shadow = this.shadow;\n    const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';\n\n    if (shadow != null) {\n      shadow.setIntensity(shadowIntensity);\n      shadow.setScene(this, this.shadowSoftness, side);\n    } else if (shadowIntensity > 0) {\n      shadow = new Shadow(this, this.shadowSoftness, side);\n      shadow.setIntensity(shadowIntensity);\n      this.shadow = shadow;\n    }\n  }\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n\n\n  setShadowSoftness(softness) {\n    this.shadowSoftness = softness;\n    const shadow = this.shadow;\n\n    if (shadow != null) {\n      shadow.setSoftness(softness);\n    }\n  }\n  /**\n   * The shadow must be rotated manually to match any global rotation applied to\n   * this model. The input is the global orientation about the Y axis.\n   */\n\n\n  setShadowRotation(radiansY) {\n    const shadow = this.shadow;\n\n    if (shadow != null) {\n      shadow.setRotation(radiansY);\n    }\n  }\n  /**\n   * Call to check if the shadow needs an updated render; returns true if an\n   * update is needed and resets the state.\n   */\n\n\n  isShadowDirty() {\n    const shadow = this.shadow;\n\n    if (shadow == null) {\n      return false;\n    } else {\n      const {\n        needsUpdate\n      } = shadow;\n      shadow.needsUpdate = false;\n      return needsUpdate;\n    }\n  }\n  /**\n   * Shift the floor vertically from the bottom of the model's bounding box by\n   * offset (should generally be negative).\n   */\n\n\n  setShadowScaleAndOffset(scale, offset) {\n    const shadow = this.shadow;\n\n    if (shadow != null) {\n      shadow.setScaleAndOffset(scale, offset);\n    }\n  }\n  /**\n   * This method returns the world position and model-space normal of the point\n   * on the mesh corresponding to the input pixel coordinates given relative to\n   * the model-viewer element. If the mesh is not hit, the result is null.\n   */\n\n\n  positionAndNormalFromPoint(pixelPosition, object = this) {\n    raycaster.setFromCamera(pixelPosition, this.getCamera());\n    const hits = raycaster.intersectObject(object, true);\n\n    if (hits.length === 0) {\n      return null;\n    }\n\n    const hit = hits[0];\n\n    if (hit.face == null) {\n      return null;\n    }\n\n    hit.face.normal.applyNormalMatrix(new Matrix3().getNormalMatrix(hit.object.matrixWorld));\n    return {\n      position: hit.point,\n      normal: hit.face.normal\n    };\n  }\n  /**\n   * The following methods are for operating on the set of Hotspot objects\n   * attached to the scene. These come from DOM elements, provided to slots by\n   * the Annotation Mixin.\n   */\n\n\n  addHotspot(hotspot) {\n    this.target.add(hotspot); // This happens automatically in render(), but we do it early so that\n    // the slots appear in the shadow DOM and the elements get attached,\n    // allowing us to dispatch events on them.\n\n    this.annotationRenderer.domElement.appendChild(hotspot.element);\n  }\n\n  removeHotspot(hotspot) {\n    this.target.remove(hotspot);\n  }\n  /**\n   * Helper method to apply a function to all hotspots.\n   */\n\n\n  forHotspots(func) {\n    const {\n      children\n    } = this.target;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      const hotspot = children[i];\n\n      if (hotspot instanceof Hotspot) {\n        func(hotspot);\n      }\n    }\n  }\n  /**\n   * Update the CSS visibility of the hotspots based on whether their normals\n   * point toward the camera.\n   */\n\n\n  updateHotspots(viewerPosition) {\n    this.forHotspots(hotspot => {\n      view.copy(viewerPosition);\n      target.setFromMatrixPosition(hotspot.matrixWorld);\n      view.sub(target);\n      normalWorld.copy(hotspot.normal).transformDirection(this.target.matrixWorld);\n\n      if (view.dot(normalWorld) < 0) {\n        hotspot.hide();\n      } else {\n        hotspot.show();\n      }\n    });\n  }\n  /**\n   * Rotate all hotspots to an absolute orientation given by the input number of\n   * radians. Zero returns them to upright.\n   */\n\n\n  orientHotspots(radians) {\n    this.forHotspots(hotspot => {\n      hotspot.orient(radians);\n    });\n  }\n  /**\n   * Set the rendering visibility of all hotspots. This is used to hide them\n   * during transitions and such.\n   */\n\n\n  setHotspotsVisibility(visible) {\n    this.forHotspots(hotspot => {\n      hotspot.visible = visible;\n    });\n  }\n\n}\n/**\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\n\n\nconst _mipmapMaterial = _getMipmapMaterial();\n\nconst _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);\n\nconst _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);\n\nlet _tempTarget = null;\nlet _renderer = null;\n\nclass RoughnessMipmapper {\n  constructor(renderer) {\n    _renderer = renderer;\n\n    _renderer.compile(_mesh, _flatCamera);\n  }\n\n  generateMipmaps(material) {\n    if ('roughnessMap' in material === false) return;\n    const {\n      roughnessMap,\n      normalMap\n    } = material;\n    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) return;\n    material.userData.roughnessUpdated = true;\n    let width = Math.max(roughnessMap.image.width, normalMap.image.width);\n    let height = Math.max(roughnessMap.image.height, normalMap.image.height);\n    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) return;\n\n    const oldTarget = _renderer.getRenderTarget();\n\n    const autoClear = _renderer.autoClear;\n    _renderer.autoClear = false;\n\n    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {\n      if (_tempTarget !== null) _tempTarget.dispose();\n      _tempTarget = new WebGLRenderTarget(width, height, {\n        depthBuffer: false\n      });\n      _tempTarget.scissorTest = true;\n    }\n\n    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n      const params = {\n        wrapS: roughnessMap.wrapS,\n        wrapT: roughnessMap.wrapT,\n        magFilter: roughnessMap.magFilter,\n        minFilter: roughnessMap.minFilter,\n        depthBuffer: false\n      };\n      const newRoughnessTarget = new WebGLRenderTarget(width, height, params);\n      newRoughnessTarget.texture.generateMipmaps = true; // Setting the render target causes the memory to be allocated.\n\n      _renderer.setRenderTarget(newRoughnessTarget);\n\n      material.roughnessMap = newRoughnessTarget.texture;\n      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;\n      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap; // Copy UV transform parameters\n\n      material.roughnessMap.offset.copy(roughnessMap.offset);\n      material.roughnessMap.repeat.copy(roughnessMap.repeat);\n      material.roughnessMap.center.copy(roughnessMap.center);\n      material.roughnessMap.rotation = roughnessMap.rotation;\n      material.roughnessMap.matrixAutoUpdate = roughnessMap.matrixAutoUpdate;\n      material.roughnessMap.matrix.copy(roughnessMap.matrix);\n    }\n\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n    _mipmapMaterial.uniforms.normalMap.value = normalMap;\n    const position = new Vector2(0, 0);\n    const texelSize = _mipmapMaterial.uniforms.texelSize.value;\n\n    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\n      // up a secondary texture to write the result to, then copy it back to the\n      // proper mipmap level.\n      texelSize.set(1.0 / width, 1.0 / height);\n      if (mip == 0) texelSize.set(0.0, 0.0);\n\n      _tempTarget.viewport.set(position.x, position.y, width, height);\n\n      _tempTarget.scissor.set(position.x, position.y, width, height);\n\n      _renderer.setRenderTarget(_tempTarget);\n\n      _renderer.render(_mesh, _flatCamera);\n\n      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\n\n    _renderer.setRenderTarget(oldTarget);\n\n    _renderer.autoClear = autoClear;\n  }\n\n  dispose() {\n    _mipmapMaterial.dispose();\n\n    _mesh.geometry.dispose();\n\n    if (_tempTarget != null) _tempTarget.dispose();\n  }\n\n}\n\nfunction _getMipmapMaterial() {\n  const shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      roughnessMap: {\n        value: null\n      },\n      normalMap: {\n        value: null\n      },\n      texelSize: {\n        value: new Vector2(1, 1)\n      }\n    },\n    vertexShader:\n    /* glsl */\n    `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t`,\n    fragmentShader:\n    /* glsl */\n    `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'RoughnessMipmapper';\n  return shaderMaterial;\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nconst BASE_OPACITY = 0.1;\nconst DEFAULT_SHADOW_INTENSITY = 0.0;\nconst DEFAULT_SHADOW_SOFTNESS = 1.0;\nconst DEFAULT_EXPOSURE = 1.0;\nconst $currentEnvironmentMap = Symbol('currentEnvironmentMap');\nconst $applyEnvironmentMap = Symbol('applyEnvironmentMap');\nconst $updateEnvironment = Symbol('updateEnvironment');\nconst $cancelEnvironmentUpdate = Symbol('cancelEnvironmentUpdate');\nconst $onPreload = Symbol('onPreload');\n\nconst EnvironmentMixin = ModelViewerElement => {\n  var _a, _b, _c;\n\n  class EnvironmentModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.environmentImage = null;\n      this.skyboxImage = null;\n      this.shadowIntensity = DEFAULT_SHADOW_INTENSITY;\n      this.shadowSoftness = DEFAULT_SHADOW_SOFTNESS;\n      this.exposure = DEFAULT_EXPOSURE;\n      this[_a] = null;\n      this[_b] = null;\n\n      this[_c] = event => {\n        if (event.element === this) {\n          this[$updateEnvironment]();\n        }\n      };\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this[$renderer].loader.addEventListener('preload', this[$onPreload]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$renderer].loader.removeEventListener('preload', this[$onPreload]);\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('shadowIntensity')) {\n        this[$scene].setShadowIntensity(this.shadowIntensity * BASE_OPACITY);\n        this[$needsRender]();\n      }\n\n      if (changedProperties.has('shadowSoftness')) {\n        this[$scene].setShadowSoftness(this.shadowSoftness);\n        this[$needsRender]();\n      }\n\n      if (changedProperties.has('exposure')) {\n        this[$scene].exposure = this.exposure;\n        this[$needsRender]();\n      }\n\n      if ((changedProperties.has('environmentImage') || changedProperties.has('skyboxImage')) && this[$shouldAttemptPreload]()) {\n        this[$updateEnvironment]();\n      }\n    }\n\n    [(_a = $currentEnvironmentMap, _b = $cancelEnvironmentUpdate, _c = $onPreload, $onModelLoad)]() {\n      super[$onModelLoad]();\n\n      if (this[$currentEnvironmentMap] != null) {\n        this[$applyEnvironmentMap](this[$currentEnvironmentMap]);\n      }\n    }\n\n    [$updateEnvironment]() {\n      var _this9 = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          skyboxImage,\n          environmentImage\n        } = _this9;\n\n        if (_this9[$cancelEnvironmentUpdate] != null) {\n          _this9[$cancelEnvironmentUpdate]();\n\n          _this9[$cancelEnvironmentUpdate] = null;\n        }\n\n        const {\n          textureUtils\n        } = _this9[$renderer];\n\n        if (textureUtils == null) {\n          return;\n        }\n\n        try {\n          const {\n            environmentMap,\n            skybox\n          } = yield new Promise( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* (resolve, reject) {\n              const texturesLoad = textureUtils.generateEnvironmentMapAndSkybox(deserializeUrl(skyboxImage), environmentImage, {\n                progressTracker: _this9[$progressTracker]\n              });\n\n              _this9[$cancelEnvironmentUpdate] = () => reject(texturesLoad);\n\n              resolve(yield texturesLoad);\n            });\n\n            return function (_x10, _x11) {\n              return _ref5.apply(this, arguments);\n            };\n          }());\n          const environment = environmentMap.texture;\n\n          if (skybox != null) {\n            // When using the same environment and skybox, use the environment as\n            // it gives HDR filtering.\n            _this9[$scene].background = skybox.userData.url === environment.userData.url ? environment : skybox;\n          } else {\n            _this9[$scene].background = null;\n          }\n\n          _this9[$applyEnvironmentMap](environmentMap.texture);\n\n          _this9[$scene].dispatchEvent({\n            type: 'envmap-update'\n          });\n        } catch (errorOrPromise) {\n          if (errorOrPromise instanceof Error) {\n            _this9[$applyEnvironmentMap](null);\n\n            throw errorOrPromise;\n          }\n        }\n      })();\n    }\n    /**\n     * Sets the Model to use the provided environment map,\n     * or `null` if the Model should remove its' environment map.\n     */\n\n\n    [$applyEnvironmentMap](environmentMap) {\n      this[$currentEnvironmentMap] = environmentMap;\n      this[$scene].environment = this[$currentEnvironmentMap];\n      this.dispatchEvent(new CustomEvent('environment-change'));\n      this[$needsRender]();\n    }\n\n  }\n\n  __decorate$7([property({\n    type: String,\n    attribute: 'environment-image'\n  })], EnvironmentModelViewerElement.prototype, \"environmentImage\", void 0);\n\n  __decorate$7([property({\n    type: String,\n    attribute: 'skybox-image'\n  })], EnvironmentModelViewerElement.prototype, \"skyboxImage\", void 0);\n\n  __decorate$7([property({\n    type: Number,\n    attribute: 'shadow-intensity'\n  })], EnvironmentModelViewerElement.prototype, \"shadowIntensity\", void 0);\n\n  __decorate$7([property({\n    type: Number,\n    attribute: 'shadow-softness'\n  })], EnvironmentModelViewerElement.prototype, \"shadowSoftness\", void 0);\n\n  __decorate$7([property({\n    type: Number\n  })], EnvironmentModelViewerElement.prototype, \"exposure\", void 0);\n\n  return EnvironmentModelViewerElement;\n};\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n\n}\n\nclass XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\nconst vector2 = new Vector2();\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\n\nconst addCorner = (vertices, cornerX, cornerY) => {\n  let phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;\n\n  for (let i = 0; i <= SEGMENTS; ++i) {\n    vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);\n    phi += DELTA_PHI;\n  }\n};\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a scene. It is purposely larger than the scene's bounding box by RADIUS on\n * all sides so that small scenes are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\n\n\nclass PlacementBox extends Mesh {\n  constructor(scene, side) {\n    const geometry = new BufferGeometry();\n    const triangles = [];\n    const vertices = [];\n    const {\n      size,\n      boundingBox\n    } = scene;\n    const x = size.x / 2;\n    const y = (side === 'back' ? size.y : size.z) / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n    const numVertices = vertices.length / 3;\n\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n    super(geometry);\n    this.side = side;\n    const material = this.material;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n    this.hitPlane = new Mesh(new PlaneGeometry(2 * (x + RADIUS), 2 * (y + RADIUS)));\n    this.hitPlane.visible = false;\n    this.add(this.hitPlane);\n    boundingBox.getCenter(this.position);\n\n    switch (side) {\n      case 'bottom':\n        this.rotateX(-Math.PI / 2);\n        this.shadowHeight = boundingBox.min.y;\n        this.position.y = this.shadowHeight;\n        break;\n\n      case 'back':\n        this.shadowHeight = boundingBox.min.z;\n        this.position.z = this.shadowHeight;\n    }\n\n    scene.target.add(this);\n  }\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n\n\n  getHit(scene, screenX, screenY) {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n\n  getExpandedHit(scene, screenX, screenY) {\n    this.hitPlane.scale.set(1000, 1000, 1000);\n    const hitResult = this.getHit(scene, screenX, screenY);\n    this.hitPlane.scale.set(1, 1, 1);\n    return hitResult;\n  }\n  /**\n   * Offset the height of the box relative to the bottom of the scene. Positive\n   * is up, so generally only negative values are used.\n   */\n\n\n  set offsetHeight(offset) {\n    if (this.side === 'back') {\n      this.position.z = this.shadowHeight + offset;\n    } else {\n      this.position.y = this.shadowHeight + offset;\n    }\n  }\n\n  get offsetHeight() {\n    if (this.side === 'back') {\n      return this.position.z - this.shadowHeight;\n    } else {\n      return this.position.y - this.shadowHeight;\n    }\n  }\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n\n\n  set show(visible) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n\n\n  updateOpacity(delta) {\n    const material = this.material;\n    material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n\n\n  dispose() {\n    var _a;\n\n    const {\n      geometry,\n      material\n    } = this.hitPlane;\n    geometry.dispose();\n    material.dispose();\n    this.geometry.dispose();\n    this.material.dispose();\n    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.remove(this);\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// number of initial null pose XRFrames allowed before we post not-tracking\n\n\nconst INIT_FRAMES = 30; // AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\n\nconst AR_SHADOW_INTENSITY = 0.3;\nconst ROTATION_RATE = 1.5; // Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\n\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP_HIGH = 1.3;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH; // For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\n\nconst MIN_VIEWPORT_SCALE = 0.25; // Furthest away you can move an object (meters).\n\nconst MAX_DISTANCE = 10;\nconst ARStatus = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\nconst ARTracking = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\n\nclass ARRenderer extends EventDispatcher {\n  constructor(renderer) {\n    super();\n    this.renderer = renderer;\n    this.currentSession = null;\n    this.placeOnWall = false;\n    this.placementBox = null;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.oldBackground = null;\n    this.oldEnvironment = null;\n    this.frame = null;\n    this.initialHitSource = null;\n    this.transientHitTestSource = null;\n    this.inputSource = null;\n    this._presentedScene = null;\n    this.resolveCleanup = null;\n    this.exitWebXRButtonContainer = null;\n    this.overlay = null;\n    this.xrLight = null;\n    this.environmentEstimation = false;\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.oldTarget = new Vector3();\n    this.oldFramedFieldOfView = 45;\n    this.placementComplete = false;\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastDragPosition = new Vector3();\n    this.firstRatio = 0;\n    this.lastAngle = 0;\n    this.goalPosition = new Vector3();\n    this.goalYaw = 0;\n    this.goalScale = 1;\n    this.xDamper = new Damper();\n    this.yDamper = new Damper();\n    this.zDamper = new Damper();\n    this.yawDamper = new Damper();\n    this.scaleDamper = new Damper();\n\n    this.onExitWebXRButtonContainerClick = () => this.stopPresenting();\n\n    this.onUpdateScene = () => {\n      if (this.placementBox != null && this.isPresenting) {\n        this.placementBox.dispose();\n        this.placementBox = new PlacementBox(this.presentedScene, this.placeOnWall ? 'back' : 'bottom');\n      }\n    };\n\n    this.onSelectStart = event => {\n      const hitSource = this.transientHitTestSource;\n\n      if (hitSource == null) {\n        return;\n      }\n\n      const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);\n      const scene = this.presentedScene;\n      const box = this.placementBox;\n\n      if (fingers.length === 1) {\n        this.inputSource = event.inputSource;\n        const {\n          axes\n        } = this.inputSource.gamepad;\n        const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);\n        box.show = true;\n\n        if (hitPosition != null) {\n          this.isTranslating = true;\n          this.lastDragPosition.copy(hitPosition);\n        } else if (this.placeOnWall === false) {\n          this.isRotating = true;\n          this.lastAngle = axes[0] * ROTATION_RATE;\n        }\n      } else if (fingers.length === 2) {\n        box.show = true;\n        this.isTwoFingering = true;\n        const {\n          separation\n        } = this.fingerPolar(fingers);\n        this.firstRatio = separation / scene.scale.x;\n      }\n    };\n\n    this.onSelectEnd = () => {\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = false;\n      this.inputSource = null;\n      this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x;\n      this.placementBox.show = false;\n    };\n\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n    this.xrLight = new XREstimatedLight(this.threeRenderer);\n    this.xrLight.addEventListener('estimationstart', () => {\n      if (!this.isPresenting || this.xrLight == null) {\n        return;\n      }\n\n      const scene = this.presentedScene;\n      scene.add(this.xrLight);\n\n      if (this.environmentEstimation && this.xrLight.environment) {\n        this.oldEnvironment = scene.environment;\n        scene.environment = this.xrLight.environment;\n      }\n    });\n  }\n\n  resolveARSession() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      assertIsArCandidate();\n      const session = yield navigator.xr.requestSession('immersive-ar', {\n        requiredFeatures: ['hit-test'],\n        optionalFeatures: ['dom-overlay', 'light-estimation'],\n        domOverlay: {\n          root: _this10.overlay\n        }\n      });\n\n      _this10.threeRenderer.xr.setReferenceSpaceType('local');\n\n      yield _this10.threeRenderer.xr.setSession(session);\n      _this10.threeRenderer.xr.cameraAutoUpdate = false;\n      return session;\n    })();\n  }\n  /**\n   * The currently presented scene, if any\n   */\n\n\n  get presentedScene() {\n    return this._presentedScene;\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n\n\n  supportsPresentation() {\n    return _asyncToGenerator(function* () {\n      try {\n        assertIsArCandidate();\n        return yield navigator.xr.isSessionSupported('immersive-ar');\n      } catch (error) {\n        console.warn('Request to present in WebXR denied:');\n        console.warn(error);\n        console.warn('Falling back to next ar-mode');\n        return false;\n      }\n    })();\n  }\n  /**\n   * Present a scene in AR\n   */\n\n\n  present(scene, environmentEstimation = false) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this11.isPresenting) {\n        console.warn('Cannot present while a model is already presenting');\n      }\n\n      let waitForAnimationFrame = new Promise((resolve, _reject) => {\n        requestAnimationFrame(() => resolve());\n      });\n      scene.setHotspotsVisibility(false);\n      scene.isDirty = true; // Render a frame to turn off the hotspots\n\n      yield waitForAnimationFrame; // This sets isPresenting to true\n\n      _this11._presentedScene = scene;\n      _this11.overlay = scene.element.shadowRoot.querySelector('div.default');\n      _this11.environmentEstimation = environmentEstimation;\n      const currentSession = yield _this11.resolveARSession();\n      currentSession.addEventListener('end', () => {\n        _this11.postSessionCleanup();\n      }, {\n        once: true\n      });\n      const exitButton = scene.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');\n      exitButton.classList.add('enabled');\n      exitButton.addEventListener('click', _this11.onExitWebXRButtonContainerClick);\n      _this11.exitWebXRButtonContainer = exitButton;\n      const viewerRefSpace = yield currentSession.requestReferenceSpace('viewer');\n      _this11.tracking = true;\n      _this11.frames = 0;\n      _this11.initialized = false;\n      _this11.turntableRotation = scene.yaw;\n      _this11.goalYaw = scene.yaw;\n      _this11.goalScale = 1;\n      _this11.oldBackground = scene.background;\n      scene.background = null;\n      _this11.oldShadowIntensity = scene.shadowIntensity;\n      scene.setShadowIntensity(0);\n\n      _this11.oldTarget.copy(scene.getTarget());\n\n      _this11.oldFramedFieldOfView = scene.framedFieldOfView;\n      scene.addEventListener('model-load', _this11.onUpdateScene);\n      const radians = HIT_ANGLE_DEG * Math.PI / 180;\n      const ray = _this11.placeOnWall === true ? undefined : new XRRay(new DOMPoint(0, 0, 0), {\n        x: 0,\n        y: -Math.sin(radians),\n        z: -Math.cos(radians)\n      });\n      currentSession.requestHitTestSource({\n        space: viewerRefSpace,\n        offsetRay: ray\n      }).then(hitTestSource => {\n        _this11.initialHitSource = hitTestSource;\n      });\n      _this11.currentSession = currentSession;\n      _this11.placementBox = new PlacementBox(scene, _this11.placeOnWall ? 'back' : 'bottom');\n      _this11.placementComplete = false;\n      _this11.lastTick = performance.now();\n\n      _this11.dispatchEvent({\n        type: 'status',\n        status: ARStatus.SESSION_STARTED\n      });\n    })();\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n\n\n  stopPresenting() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this12.isPresenting) {\n        return;\n      }\n\n      const cleanupPromise = new Promise(resolve => {\n        _this12.resolveCleanup = resolve;\n      });\n\n      try {\n        yield _this12.currentSession.end();\n        yield cleanupPromise;\n      } catch (error) {\n        console.warn('Error while trying to end WebXR AR session');\n        console.warn(error);\n\n        _this12.postSessionCleanup();\n      }\n    })();\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n\n\n  get isPresenting() {\n    return this.presentedScene != null;\n  }\n\n  get target() {\n    return this.oldTarget;\n  }\n\n  updateTarget() {\n    const scene = this.presentedScene;\n\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n\n  postSessionCleanup() {\n    const session = this.currentSession;\n\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n\n    const scene = this.presentedScene;\n\n    if (scene != null) {\n      const {\n        element\n      } = scene;\n\n      if (this.xrLight != null && this.xrLight.parent != null) {\n        scene.remove(this.xrLight);\n\n        if (this.oldEnvironment != null) {\n          scene.environment = this.oldEnvironment;\n          this.oldEnvironment = null;\n        }\n      }\n\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      scene.setShadowScaleAndOffset(1, 0);\n      const yaw = this.turntableRotation;\n\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n\n      const intensity = this.oldShadowIntensity;\n\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n\n      const background = this.oldBackground;\n\n      if (background != null) {\n        scene.background = background;\n      }\n\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.framedFieldOfView = this.oldFramedFieldOfView;\n      scene.xrCamera = null;\n      scene.removeEventListener('model-load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element.requestUpdate('maxCameraOrbit');\n      element[$onResize](element.getBoundingClientRect());\n    } // Force the Renderer to update its size\n\n\n    this.renderer.height = 0;\n    const exitButton = this.exitWebXRButtonContainer;\n\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener('click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n\n    const hitSource = this.transientHitTestSource;\n\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n\n    const hitSourceInitial = this.initialHitSource;\n\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n\n    if (this.placementBox != null) {\n      this.placementBox.dispose();\n      this.placementBox = null;\n    }\n\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.oldBackground = null;\n    this._presentedScene = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup();\n    }\n\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.NOT_PRESENTING\n    });\n  }\n\n  updateView(view) {\n    const scene = this.presentedScene;\n    const xr = this.threeRenderer.xr;\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {\n      elements\n    } = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    } // Use automatic dynamic viewport scaling if supported.\n\n\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n\n    const layer = this.currentSession.renderState.baseLayer;\n    const viewport = layer.getViewport(view);\n    this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);\n  }\n\n  placeInitially() {\n    const scene = this.presentedScene;\n    const {\n      position,\n      element\n    } = scene;\n    const xrCamera = scene.getCamera();\n    const {\n      width,\n      height\n    } = this.overlay.getBoundingClientRect();\n    scene.setSize(width, height);\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n    const {\n      theta,\n      radius\n    } = element.getCameraOrbit(); // Orient model to match the 3D camera view\n\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n    position.copy(xrCamera.position).add(cameraDirection.multiplyScalar(radius));\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n    this.goalPosition.copy(position);\n    scene.setHotspotsVisibility(true);\n    const {\n      session\n    } = this.frame;\n    session.addEventListener('selectstart', this.onSelectStart);\n    session.addEventListener('selectend', this.onSelectEnd);\n    session.requestHitTestSourceForTransientInput({\n      profile: 'generic-touchscreen'\n    }).then(hitTestSource => {\n      this.transientHitTestSource = hitTestSource;\n    });\n  }\n\n  getTouchLocation() {\n    const {\n      axes\n    } = this.inputSource.gamepad;\n    let location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);\n\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE) return null;\n    }\n\n    return location;\n  }\n\n  getHitPoint(hitResult) {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = hitResult.getPose(refSpace);\n\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    } // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n\n\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? hitPosition.setFromMatrixPosition(hitMatrix) : null;\n  }\n\n  moveToFloor(frame) {\n    const hitSource = this.initialHitSource;\n\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n\n    if (hitPoint == null) {\n      return;\n    }\n\n    this.placementBox.show = true; // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.OBJECT_PLACED\n    });\n  }\n\n  fingerPolar(fingers) {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n\n  processInput(frame) {\n    const hitSource = this.transientHitTestSource;\n\n    if (hitSource == null) {\n      return;\n    }\n\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene;\n    const scale = scene.scale.x; // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {\n          separation,\n          deltaYaw\n        } = this.fingerPolar(fingers);\n\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n\n        if (scene.canScale) {\n          const scale = separation / this.firstRatio;\n          this.goalScale = scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW ? 1 : scale;\n        }\n      }\n\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {\n        separation\n      } = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n\n    if (this.isRotating) {\n      const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n\n        let hit = null;\n\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0]);\n        }\n\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n\n        if (hit == null) {\n          return;\n        }\n\n        this.goalPosition.sub(this.lastDragPosition);\n\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y; // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n\n          if (offset < 0) {\n            this.placementBox.offsetHeight = offset / scale;\n            this.presentedScene.setShadowScaleAndOffset(scale, offset); // Interpolate hit ray up to drag plane\n\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n\n  moveScene(delta) {\n    const scene = this.presentedScene;\n    const {\n      position,\n      yaw,\n      idealCameraDistance: radius\n    } = scene;\n    const goal = this.goalPosition;\n    const oldScale = scene.scale.x;\n    const box = this.placementBox;\n\n    if (!goal.equals(position) || this.goalScale !== oldScale) {\n      let {\n        x,\n        y,\n        z\n      } = position;\n      x = this.xDamper.update(x, goal.x, delta, radius);\n      y = this.yDamper.update(y, goal.y, delta, radius);\n      z = this.zDamper.update(z, goal.z, delta, radius);\n      position.set(x, y, z);\n      const newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n\n      if (!this.isTranslating) {\n        const offset = goal.y - y;\n\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / newScale;\n          scene.setShadowScaleAndOffset(newScale, offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n    }\n\n    box.updateOpacity(delta);\n    scene.updateTarget(delta); // yaw must be updated last, since this also updates the shadow position.\n\n    scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);\n  }\n  /**\n   * Only public to make it testable.\n   */\n\n\n  onWebXRFrame(time, frame) {\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = frame.getViewerPose(refSpace);\n\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.NOT_TRACKING\n      });\n    }\n\n    const scene = this.presentedScene;\n\n    if (pose == null || scene == null || !scene.element[$sceneIsReady]()) {\n      this.threeRenderer.clear();\n      return;\n    }\n\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.TRACKING\n      });\n    } // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n\n\n    let isFirstView = true;\n\n    for (const view of pose.views) {\n      this.updateView(view);\n\n      if (isFirstView) {\n        this.moveToFloor(frame);\n        this.processInput(frame);\n        const delta = time - this.lastTick;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n      } // TODO: This is a workaround for a Chrome bug, which should be fixed\n      // soon: https://bugs.chromium.org/p/chromium/issues/detail?id=1184085\n\n\n      const gl = this.threeRenderer.getContext();\n      gl.depthMask(false);\n      gl.clear(gl.DEPTH_BUFFER_BIT);\n      gl.depthMask(true);\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This Debugger exposes internal details of the <model-viewer> rendering\n * substructure so that external tools can more easily inspect and operate on\n * them.\n *\n * It also activates shader debugging on the associated GL context. Shader\n * debugging trades performance for useful error information, so it is not\n * recommended to activate this unless needed.\n */\n\n\nclass Debugger {\n  constructor(renderer) {\n    // Force WebGL shader debugging on:\n    renderer.threeRenderer.debug = {\n      checkShaderErrors: true\n    }; // Announce debug details at microtask timing to give the `Renderer`\n    // constructor time to complete its initialization, just to be on the safe\n    // side:\n\n    Promise.resolve().then(() => {\n      self.dispatchEvent(new CustomEvent('model-viewer-renderer-debug', {\n        detail: {\n          renderer,\n          THREE: {\n            ShaderMaterial,\n            Texture: Texture$1,\n            Mesh,\n            Scene,\n            PlaneBufferGeometry: PlaneGeometry,\n            OrthographicCamera,\n            WebGLRenderTarget\n          }\n        }\n      }));\n    });\n  }\n\n  addScene(scene) {\n    self.dispatchEvent(new CustomEvent('model-viewer-scene-added-debug', {\n      detail: {\n        scene\n      }\n    }));\n  }\n\n  removeScene(scene) {\n    self.dispatchEvent(new CustomEvent('model-viewer-scene-removed-debug', {\n      detail: {\n        scene\n      }\n    }));\n  }\n\n}\n\nclass SkeletonUtils {\n  static retarget(target, source, options = {}) {\n    const pos = new Vector3(),\n          quat = new Quaternion(),\n          scale = new Vector3(),\n          bindBoneMatrix = new Matrix4(),\n          relativeMatrix = new Matrix4(),\n          globalMatrix = new Matrix4();\n    options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n    options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n    options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n    options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n    options.hip = options.hip !== undefined ? options.hip : 'hip';\n    options.names = options.names || {};\n    const sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target);\n    let bindBones, bone, name, boneTo, bonesPosition; // reset bones\n\n    if (target.isObject3D) {\n      target.skeleton.pose();\n    } else {\n      options.useTargetMatrix = true;\n      options.preserveMatrix = false;\n    }\n\n    if (options.preservePosition) {\n      bonesPosition = [];\n\n      for (let i = 0; i < bones.length; i++) {\n        bonesPosition.push(bones[i].position.clone());\n      }\n    }\n\n    if (options.preserveMatrix) {\n      // reset matrix\n      target.updateMatrixWorld();\n      target.matrixWorld.identity(); // reset children matrix\n\n      for (let i = 0; i < target.children.length; ++i) {\n        target.children[i].updateMatrixWorld(true);\n      }\n    }\n\n    if (options.offsets) {\n      bindBones = [];\n\n      for (let i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n\n        if (options.offsets && options.offsets[name]) {\n          bone.matrix.multiply(options.offsets[name]);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n        }\n\n        bindBones.push(bone.matrixWorld.clone());\n      }\n    }\n\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      boneTo = this.getBoneByName(name, sourceBones);\n      globalMatrix.copy(bone.matrixWorld);\n\n      if (boneTo) {\n        boneTo.updateMatrixWorld();\n\n        if (options.useTargetMatrix) {\n          relativeMatrix.copy(boneTo.matrixWorld);\n        } else {\n          relativeMatrix.copy(target.matrixWorld).invert();\n          relativeMatrix.multiply(boneTo.matrixWorld);\n        } // ignore scale to extract rotation\n\n\n        scale.setFromMatrixScale(relativeMatrix);\n        relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n        globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n        if (target.isObject3D) {\n          const boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n          globalMatrix.multiply(wBindMatrix);\n        }\n\n        globalMatrix.copyPosition(relativeMatrix);\n      }\n\n      if (bone.parent && bone.parent.isBone) {\n        bone.matrix.copy(bone.parent.matrixWorld).invert();\n        bone.matrix.multiply(globalMatrix);\n      } else {\n        bone.matrix.copy(globalMatrix);\n      }\n\n      if (options.preserveHipPosition && name === options.hip) {\n        bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n      }\n\n      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      bone.updateMatrixWorld();\n    }\n\n    if (options.preservePosition) {\n      for (let i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n\n        if (name !== options.hip) {\n          bone.position.copy(bonesPosition[i]);\n        }\n      }\n    }\n\n    if (options.preserveMatrix) {\n      // restore matrix\n      target.updateMatrixWorld(true);\n    }\n  }\n\n  static retargetClip(target, source, clip, options = {}) {\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n          delta = 1 / options.fps,\n          convertedTracks = [],\n          mixer = new AnimationMixer(source),\n          bones = this.getBones(target.skeleton),\n          boneDatas = [];\n    let positionOffset, bone, boneTo, boneData, name;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (let i = 0; i < numFrames; ++i) {\n      const time = i * delta;\n      this.retarget(target, source, options);\n\n      for (let j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (let i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  }\n\n  static getHelperFromSkeleton(skeleton) {\n    const source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  }\n\n  static getSkeletonOffsets(target, source, options = {}) {\n    const targetParentPos = new Vector3(),\n          targetPos = new Vector3(),\n          sourceParentPos = new Vector3(),\n          sourcePos = new Vector3(),\n          targetDir = new Vector2(),\n          sourceDir = new Vector2();\n    options.hip = options.hip !== undefined ? options.hip : 'hip';\n    options.names = options.names || {};\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    const nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [];\n    let bone, boneTo, name, i;\n    target.skeleton.pose();\n\n    for (i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      boneTo = this.getBoneByName(name, sourceBones);\n\n      if (boneTo && name !== options.hip) {\n        const boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n        boneParent.updateMatrixWorld();\n        boneToParent.updateMatrixWorld();\n        targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n        targetPos.setFromMatrixPosition(bone.matrixWorld);\n        sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n        sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n        targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n        sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n        const laterialAngle = targetDir.angle() - sourceDir.angle();\n        const offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n        bone.matrix.multiply(offset);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n        offsets[name] = offset;\n      }\n    }\n\n    return offsets;\n  }\n\n  static renameBones(skeleton, names) {\n    const bones = this.getBones(skeleton);\n\n    for (let i = 0; i < bones.length; ++i) {\n      const bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  }\n\n  static getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  }\n\n  static getBoneByName(name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  }\n\n  static getNearestBone(bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  }\n\n  static findBoneTrackData(name, tracks) {\n    const regexp = /\\[(.*)\\]\\.(.*)/,\n          result = {\n      name: name\n    };\n\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      const trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  }\n\n  static getEqualsBonesNames(skeleton, targetSkeleton) {\n    const sourceBones = this.getBones(skeleton),\n          targetBones = this.getBones(targetSkeleton),\n          bones = [];\n\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      const boneName = sourceBones[i].name;\n\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  }\n\n  static clone(source) {\n    const sourceLookup = new Map();\n    const cloneLookup = new Map();\n    const clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      const clonedMesh = node;\n      const sourceMesh = sourceLookup.get(node);\n      const sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst $prepared = Symbol('prepared');\nconst $prepare = Symbol('prepare');\nconst $preparedGLTF = Symbol('preparedGLTF');\nconst $clone = Symbol('clone');\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\n\nclass GLTFInstance {\n  constructor(preparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n\n\n  static prepare(source) {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n\n    if (source[$prepared]) {\n      return source;\n    }\n\n    const prepared = this[$prepare](source); // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n\n    prepared[$prepared] = true;\n    return prepared;\n  }\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n\n\n  static [$prepare](source) {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {\n      scene\n    } = source;\n    const scenes = [scene];\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes\n    });\n  }\n\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n  /**\n   * Creates and returns a copy of this instance.\n   */\n\n\n  clone() {\n    const GLTFInstanceConstructor = this.constructor;\n    const clonedGLTF = this[$clone]();\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n\n\n  dispose() {\n    this.scenes.forEach(scene => {\n      scene.traverse(object => {\n        if (!object.isMesh) {\n          return;\n        }\n\n        const mesh = object;\n        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          // Explicitly dispose any textures assigned to this material\n          for (const propertyName in material) {\n            const propertyValue = material[propertyName];\n\n            if (propertyValue instanceof Texture$1) {\n              propertyValue.dispose();\n            }\n          }\n\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n\n\n  [$clone]() {\n    const source = this[$preparedGLTF]; // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n\n    const scene = SkeletonUtils.clone(this.scene);\n    cloneVariantMaterials(scene, this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? Object.assign({}, source.userData) : {};\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes,\n      userData\n    });\n  }\n\n} // Variant materials and original material instances are stored under\n// object.userData.variantMaterials/originalMaterial.\n// Three.js Object3D.clone() doesn't clone Three.js objects under\n// .userData so this function is a workaround.\n\n\nconst cloneVariantMaterials = (dst, src) => {\n  traversePair(dst, src, (dst, src) => {\n    if (src.userData.variantMaterials !== undefined) {\n      dst.userData.variantMaterials = new Map(src.userData.variantMaterials);\n    }\n\n    if (src.userData.originalMaterial !== undefined) {\n      dst.userData.originalMaterial = src.userData.originalMaterial;\n    }\n  });\n};\n\nconst traversePair = (obj1, obj2, callback) => {\n  callback(obj1, obj2); // Assume obj1 and obj2 have the same tree structure\n\n  for (let i = 0; i < obj1.children.length; i++) {\n    traversePair(obj1.children[i], obj2.children[i], callback);\n  }\n};\n/**\n * @license MIT\n * @see https://github.com/mrdoob/three.js/blob/dev/LICENSE\n */\n\n\nconst alphaChunk =\n/* glsl */\n`\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n`;\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\n\nclass CorrelatedSceneGraph {\n  constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n\n\n  static from(threeGLTF, upstreamCorrelatedSceneGraph) {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n\n  static [$correlateOriginalThreeGLTF](threeGLTF) {\n    const gltf = threeGLTF.parser.json;\n    const {\n      associations\n    } = threeGLTF.parser;\n    const gltfElementMap = new Map();\n    const defaultMaterial = {\n      name: 'Default'\n    };\n    const defaultReference = {\n      type: 'materials',\n      index: -1\n    }; // NOTE: IE11 does not have Map iterator methods\n\n    associations.forEach((gltfElementReference, threeObject) => {\n      // Note: GLTFLoader creates a \"default\" material that has no corresponding\n      // glTF element in the case that no materials are specified in the source\n      // glTF. In this case we append a default material to allow this to be\n      // operated upon.\n      if (gltfElementReference == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n\n        gltfElementReference = defaultReference;\n      }\n\n      const {\n        type,\n        index\n      } = gltfElementReference;\n      const elementArray = gltf[type] || [];\n      const gltfElement = elementArray[index];\n\n      if (gltfElement == null) {\n        // TODO: Maybe throw here...\n        return;\n      }\n\n      let threeObjects = gltfElementMap.get(gltfElement);\n\n      if (threeObjects == null) {\n        threeObjects = new Set();\n        gltfElementMap.set(gltfElement, threeObjects);\n      }\n\n      threeObjects.add(threeObject);\n    });\n    return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap);\n  }\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedsceneGraph instance.\n   */\n\n\n  static [$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap = new Map();\n    const cloneGLTFELementMap = new Map();\n    const defaultMaterial = {\n      name: 'Default'\n    };\n    const defaultReference = {\n      type: 'materials',\n      index: -1\n    };\n\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject) => {\n        let elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n\n        if ((object.isMesh || object.isMaterial) && elementReference == null) {\n          // Checks if default material was allready addded to the gltf.\n          if (cloneGLTF.materials && cloneGLTF.materials.length) {\n            const material = cloneGLTF.materials[cloneGLTF.materials.length - 1];\n\n            if (material.name === 'Default') {\n              defaultReference.index = cloneGLTF.materials.length - 1;\n            }\n          } // Adds the defaul material if the default material was not added.\n\n\n          if (defaultReference.index < 0) {\n            if (cloneGLTF.materials == null) {\n              cloneGLTF.materials = [];\n            }\n\n            defaultReference.index = cloneGLTF.materials.length;\n            cloneGLTF.materials.push(defaultMaterial);\n          }\n\n          elementReference = defaultReference;\n        }\n\n        if (elementReference == null) {\n          return;\n        }\n\n        const {\n          type,\n          index\n        } = elementReference;\n        const cloneElement = cloneGLTF[type][index];\n        cloneThreeObjectMap.set(cloneObject, {\n          type,\n          index\n        });\n        const cloneObjects = cloneGLTFELementMap.get(cloneElement) || new Set();\n        cloneObjects.add(cloneObject);\n        cloneGLTFELementMap.set(cloneElement, cloneObjects);\n      });\n    }\n\n    return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFELementMap);\n  }\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a callback\n   * for each Object3D or Material encountered, including the initial scene.\n   * Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n\n\n  static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {\n    const isMesh = object => {\n      return object.isMesh;\n    };\n\n    const traverse = (a, b) => {\n      callback(a, b);\n\n      if (a.isObject3D) {\n        if (isMesh(a)) {\n          if (Array.isArray(a.material)) {\n            for (let i = 0; i < a.material.length; ++i) {\n              traverse(a.material[i], b.material[i]);\n            }\n          } else {\n            traverse(a.material, b.material);\n          }\n        }\n\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n\n    traverse(sceneOne, sceneTwo);\n  }\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n\n\n  get threeGLTF() {\n    return this[$threeGLTF];\n  }\n  /**\n   * The in-memory deserialized source glTF.\n   */\n\n\n  get gltf() {\n    return this[$gltf];\n  }\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n\n\n  get gltfElementMap() {\n    return this[$gltfElementMap];\n  }\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n\n\n  get threeObjectMap() {\n    return this[$threeObjectMap];\n  }\n\n  loadVariant(variantName) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const updatedMaterials = new Set();\n\n      if (!('variants' in _this13.threeGLTF.userData) || !('functions' in _this13.threeGLTF.userData) || !('selectVariant' in _this13.threeGLTF.userData.functions)) {\n        return updatedMaterials;\n      }\n\n      yield _this13.threeGLTF.userData.functions.selectVariant(_this13.threeGLTF.scene, variantName, true, (object, _oldMaterial, gltfMaterialIndex) => {\n        updatedMaterials.add(gltfMaterialIndex);\n        const gltfElement = _this13.gltf.materials[gltfMaterialIndex];\n\n        let threeObjects = _this13.gltfElementMap.get(gltfElement);\n\n        if (threeObjects == null) {\n          threeObjects = new Set();\n\n          _this13.gltfElementMap.set(gltfElement, threeObjects);\n        }\n\n        threeObjects.add(object.material);\n      });\n      return updatedMaterials;\n    })();\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Provides value assigned to alpha-cutoff when opaque rendering is desired.\n\n\nconst ALPHA_CUTOFF_OPAQUE = -0.5; // Provides value assigned to alpha-cutoff when alpha-blending is desired.\n\nconst ALPHA_CUTOFF_BLEND = 0;\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\n\nclass ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  static [$prepare](source) {\n    const prepared = super[$prepare](source);\n\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n\n    const {\n      scene\n    } = prepared;\n    scene.traverse(node => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000; // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n\n      node.frustumCulled = false; // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n\n      if (node.isMesh) {\n        node.castShadow = true;\n      }\n    });\n    return prepared;\n  }\n\n  get correlatedSceneGraph() {\n    return this[$preparedGLTF][$correlatedSceneGraph];\n  }\n  /**\n   * @override\n   */\n\n\n  [$clone]() {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map();\n    clone.scene.traverse(node => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if (node.isMesh) {\n        const mesh = node;\n\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map(material => this[$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial));\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](mesh.material, sourceUUIDToClonedMaterial);\n        }\n      }\n    }); // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n\n    clone[$correlatedSceneGraph] = CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n    return clone;\n  }\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n\n\n  [$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid);\n    }\n\n    const clone = material.clone();\n\n    if (material.map != null) {\n      clone.map = material.map.clone();\n      clone.map.needsUpdate = true;\n    }\n\n    if (material.normalMap != null) {\n      clone.normalMap = material.normalMap.clone();\n      clone.normalMap.needsUpdate = true;\n    }\n\n    if (material.emissiveMap != null) {\n      clone.emissiveMap = material.emissiveMap.clone();\n      clone.emissiveMap.needsUpdate = true;\n    } // Clones the roughnessMap if it exists.\n\n\n    let roughnessMap = null;\n\n    if (material.roughnessMap != null) {\n      roughnessMap = material.roughnessMap.clone();\n    } // Assigns the roughnessMap to the cloned material and generates mipmaps.\n\n\n    if (roughnessMap != null) {\n      roughnessMap.needsUpdate = true;\n      clone.roughnessMap = roughnessMap; // Generates mipmaps from the clone of the roughnessMap.\n\n      const {\n        threeRenderer,\n        roughnessMipmapper\n      } = Renderer.singleton; // XR must be disabled while doing offscreen rendering or it will\n      // clobber the camera.\n\n      const {\n        enabled\n      } = threeRenderer.xr;\n      threeRenderer.xr.enabled = false;\n      roughnessMipmapper.generateMipmaps(clone);\n      threeRenderer.xr.enabled = enabled;\n    } // Checks if roughnessMap and metalnessMap share the same texture and\n    // either clones or assigns.\n\n\n    if (material.roughnessMap === material.metalnessMap) {\n      clone.metalnessMap = roughnessMap;\n    } else if (material.metalnessMap != null) {\n      clone.metalnessMap = material.metalnessMap.clone();\n      clone.metalnessMap.needsUpdate = true;\n    } // Checks if roughnessMap and aoMap share the same texture and\n    // either clones or assigns.\n\n\n    if (material.roughnessMap === material.aoMap) {\n      clone.aoMap = roughnessMap;\n    } else if (material.aoMap != null) {\n      clone.aoMap = material.aoMap.clone();\n      clone.aoMap.needsUpdate = true;\n    } // This allows us to patch three's materials, on top of patches already\n    // made, for instance GLTFLoader patches SpecularGlossiness materials.\n    // Unfortunately, three's program cache differentiates SpecGloss materials\n    // via onBeforeCompile.toString(), so these two functions do the same\n    // thing but look different in order to force a proper recompile.\n\n\n    const oldOnBeforeCompile = material.onBeforeCompile;\n    clone.onBeforeCompile = material.isGLTFSpecularGlossinessMaterial ? shader => {\n      oldOnBeforeCompile(shader, undefined);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <alphatest_fragment>', alphaChunk);\n    } : shader => {\n      shader.fragmentShader = shader.fragmentShader.replace('#include <alphatest_fragment>', alphaChunk);\n      oldOnBeforeCompile(shader, undefined);\n    }; // This makes shadows better for non-manifold meshes\n\n    clone.shadowSide = FrontSide; // This improves transparent rendering and can be removed whenever\n    // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n\n    if (clone.transparent) {\n      clone.depthWrite = false;\n    } // This little hack ignores alpha for opaque materials, in order to comply\n    // with the glTF spec.\n\n\n    if (!clone.alphaTest && !clone.transparent) {\n      clone.alphaTest = ALPHA_CUTOFF_OPAQUE;\n    }\n\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n    return clone;\n  }\n\n} // https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = FloatType;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  parse(buffer) {\n    const\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n          rgbe_write_error = 2,\n          rgbe_format_error = 3,\n          rgbe_memory_error = 4,\n          rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n          RGBE_VALID_FORMAT = 2,\n          RGBE_VALID_DIMENSIONS = 4,\n          NEWLINE = '\\n',\n          fgets = function (buffer, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        \tbyteCode = m.charCodeAt(i);\n        \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      // regexes to parse header info fields\n      const magic_token_re = /^#\\?(\\S+)/,\n            gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n            dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n            // RGBE format header struct\n      header = {\n        valid: 0,\n\n        /* indicate which fields are valid */\n        string: '',\n\n        /* the actual header string */\n        comments: '',\n\n        /* comments found in header */\n        programtype: 'RGBE',\n\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        format: '',\n\n        /* RGBE format, default 32-bit_rle_rgbe */\n        gamma: 1.0,\n\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        exposure: 1.0,\n\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n      let line, match;\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n          RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      const scanline_width = w;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      const data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      let offset = 0,\n          pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h; // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        let ptr = 0,\n            count;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            const byteValue = buffer[pos++];\n\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        const l = scanline_width; //scanline_buffer.byteLength;\n\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      const w = rgbe_header_info.width,\n            h = rgbe_header_info.height,\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        let data, format, type;\n        let numElements;\n\n        switch (this.type) {\n          case UnsignedByteType:\n            data = image_rgba_data;\n            format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            numElements = image_rgba_data.length / 4 * 3;\n            const floatArray = new Float32Array(numElements);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            data = floatArray;\n            format = RGBFormat;\n            type = FloatType;\n            break;\n\n          case HalfFloatType:\n            numElements = image_rgba_data.length / 4 * 3;\n            const halfArray = new Uint16Array(numElements);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n            }\n\n            data = halfArray;\n            format = RGBFormat;\n            type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nclass EnvironmentScene extends Scene {\n  constructor() {\n    super();\n    this.position.y = -3.5;\n    const geometry = new BoxGeometry();\n    geometry.deleteAttribute('uv');\n    const roomMaterial = new MeshStandardMaterial({\n      metalness: 0,\n      side: BackSide\n    });\n    const boxMaterial = new MeshStandardMaterial({\n      metalness: 0\n    });\n    const mainLight = new PointLight(0xffffff, 500.0, 28, 2);\n    mainLight.position.set(0.418, 16.199, 0.300);\n    this.add(mainLight);\n    const room = new Mesh(geometry, roomMaterial);\n    room.position.set(-0.757, 13.219, 0.717);\n    room.scale.set(31.713, 28.305, 28.591);\n    this.add(room);\n    const box1 = new Mesh(geometry, boxMaterial);\n    box1.position.set(-10.906, 2.009, 1.846);\n    box1.rotation.set(0, -0.195, 0);\n    box1.scale.set(2.328, 7.905, 4.651);\n    this.add(box1);\n    const box2 = new Mesh(geometry, boxMaterial);\n    box2.position.set(-5.607, -0.754, -0.758);\n    box2.rotation.set(0, 0.994, 0);\n    box2.scale.set(1.970, 1.534, 3.955);\n    this.add(box2);\n    const box3 = new Mesh(geometry, boxMaterial);\n    box3.position.set(6.167, 0.857, 7.803);\n    box3.rotation.set(0, 0.561, 0);\n    box3.scale.set(3.927, 6.285, 3.687);\n    this.add(box3);\n    const box4 = new Mesh(geometry, boxMaterial);\n    box4.position.set(-2.017, 0.018, 6.124);\n    box4.rotation.set(0, 0.333, 0);\n    box4.scale.set(2.002, 4.566, 2.064);\n    this.add(box4);\n    const box5 = new Mesh(geometry, boxMaterial);\n    box5.position.set(2.291, -0.756, -2.621);\n    box5.rotation.set(0, -0.286, 0);\n    box5.scale.set(1.546, 1.552, 1.496);\n    this.add(box5);\n    const box6 = new Mesh(geometry, boxMaterial);\n    box6.position.set(-2.193, -0.369, -5.547);\n    box6.rotation.set(0, 0.516, 0);\n    box6.scale.set(3.875, 3.487, 2.986);\n    this.add(box6); // -x right\n\n    const light1 = new Mesh(geometry, this.createAreaLightMaterial(50));\n    light1.position.set(-16.116, 14.37, 8.208);\n    light1.scale.set(0.1, 2.428, 2.739);\n    this.add(light1); // -x left\n\n    const light2 = new Mesh(geometry, this.createAreaLightMaterial(50));\n    light2.position.set(-16.109, 18.021, -8.207);\n    light2.scale.set(0.1, 2.425, 2.751);\n    this.add(light2); // +x\n\n    const light3 = new Mesh(geometry, this.createAreaLightMaterial(17));\n    light3.position.set(14.904, 12.198, -1.832);\n    light3.scale.set(0.15, 4.265, 6.331);\n    this.add(light3); // +z\n\n    const light4 = new Mesh(geometry, this.createAreaLightMaterial(43));\n    light4.position.set(-0.462, 8.89, 14.520);\n    light4.scale.set(4.38, 5.441, 0.088);\n    this.add(light4); // -z\n\n    const light5 = new Mesh(geometry, this.createAreaLightMaterial(20));\n    light5.position.set(3.235, 11.486, -12.541);\n    light5.scale.set(2.5, 2.0, 0.1);\n    this.add(light5); // +y\n\n    const light6 = new Mesh(geometry, this.createAreaLightMaterial(100));\n    light6.position.set(0.0, 20.0, 0.0);\n    light6.scale.set(1.0, 0.1, 1.0);\n    this.add(light6);\n  }\n\n  createAreaLightMaterial(intensity) {\n    const material = new MeshBasicMaterial();\n    material.color.setScalar(intensity);\n    return material;\n  }\n\n}\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nclass EnvironmentSceneAlt extends Scene {\n  constructor() {\n    super();\n    this.position.y = -3.5;\n    const geometry = new BoxGeometry();\n    geometry.deleteAttribute('uv');\n    const roomMaterial = new MeshStandardMaterial({\n      metalness: 0,\n      side: BackSide\n    });\n    const boxMaterial = new MeshStandardMaterial({\n      metalness: 0\n    });\n    const mainLight = new PointLight(0xffffff, 400.0, 28, 2);\n    mainLight.position.set(0.5, 14.0, 0.5);\n    this.add(mainLight);\n    const room = new Mesh(geometry, roomMaterial);\n    room.position.set(0.0, 13.2, 0.0);\n    room.scale.set(31.5, 28.5, 31.5);\n    this.add(room);\n    const box1 = new Mesh(geometry, boxMaterial);\n    box1.position.set(-10.906, -1.0, 1.846);\n    box1.rotation.set(0, -0.195, 0);\n    box1.scale.set(2.328, 7.905, 4.651);\n    this.add(box1);\n    const box2 = new Mesh(geometry, boxMaterial);\n    box2.position.set(-5.607, -0.754, -0.758);\n    box2.rotation.set(0, 0.994, 0);\n    box2.scale.set(1.970, 1.534, 3.955);\n    this.add(box2);\n    const box3 = new Mesh(geometry, boxMaterial);\n    box3.position.set(6.167, -0.16, 7.803);\n    box3.rotation.set(0, 0.561, 0);\n    box3.scale.set(3.927, 6.285, 3.687);\n    this.add(box3);\n    const box4 = new Mesh(geometry, boxMaterial);\n    box4.position.set(-2.017, 0.018, 6.124);\n    box4.rotation.set(0, 0.333, 0);\n    box4.scale.set(2.002, 4.566, 2.064);\n    this.add(box4);\n    const box5 = new Mesh(geometry, boxMaterial);\n    box5.position.set(2.291, -0.756, -2.621);\n    box5.rotation.set(0, -0.286, 0);\n    box5.scale.set(1.546, 1.552, 1.496);\n    this.add(box5);\n    const box6 = new Mesh(geometry, boxMaterial);\n    box6.position.set(-2.193, -0.369, -5.547);\n    box6.rotation.set(0, 0.516, 0);\n    box6.scale.set(3.875, 3.487, 2.986);\n    this.add(box6); // -x_left\n\n    const light1 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light1.position.set(-14.0, 10.0, 8.0);\n    light1.scale.set(0.1, 2.5, 2.5);\n    this.add(light1); // -x_right\n\n    const light2 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light2.position.set(-14.0, 14.0, -4.0);\n    light2.scale.set(0.1, 2.5, 2.5);\n    this.add(light2); // +x only on light\n\n    const light3 = new Mesh(geometry, this.createAreaLightMaterial(23));\n    light3.position.set(14.0, 12.0, 0.0);\n    light3.scale.set(0.1, 5.0, 5.0);\n    this.add(light3); // +z\n\n    const light4 = new Mesh(geometry, this.createAreaLightMaterial(16));\n    light4.position.set(0.0, 9.0, 14.0);\n    light4.scale.set(5.0, 5.0, 0.1);\n    this.add(light4); // -z right\n\n    const light5 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light5.position.set(7.0, 8.0, -14.0);\n    light5.scale.set(2.5, 2.5, 0.1);\n    this.add(light5); // -z left\n\n    const light6 = new Mesh(geometry, this.createAreaLightMaterial(80));\n    light6.position.set(-7.0, 16.0, -14.0);\n    light6.scale.set(2.5, 2.5, 0.1);\n    this.add(light6); // +y\n\n    const light7 = new Mesh(geometry, this.createAreaLightMaterial(1));\n    light7.position.set(0.0, 20.0, 0.0);\n    light7.scale.set(0.1, 0.1, 0.1);\n    this.add(light7);\n  }\n\n  createAreaLightMaterial(intensity) {\n    const material = new MeshBasicMaterial();\n    material.color.setScalar(intensity);\n    return material;\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst GENERATED_SIGMA = 0.04;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nhdrLoader.setDataType(UnsignedByteType); // Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\n\nconst userData = {\n  url: null\n};\n\nclass TextureUtils extends EventDispatcher {\n  constructor(threeRenderer) {\n    super();\n    this.generatedEnvironmentMap = null;\n    this.generatedEnvironmentMapAlt = null;\n    this.skyboxCache = new Map();\n    this.environmentMapCache = new Map();\n    this.PMREMGenerator = new PMREMGenerator(threeRenderer);\n  }\n\n  load(url, progressCallback = () => {}) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const isHDR = HDR_FILE_RE.test(url);\n        const loader = isHDR ? hdrLoader : ldrLoader;\n        const texture = yield new Promise((resolve, reject) => loader.load(url, resolve, event => {\n          progressCallback(event.loaded / event.total * 0.9);\n        }, reject));\n        progressCallback(1.0);\n\n        _this14.addMetadata(texture, url);\n\n        texture.mapping = EquirectangularReflectionMapping;\n\n        if (!isHDR) {\n          texture.encoding = GammaEncoding;\n        }\n\n        return texture;\n      } finally {\n        if (progressCallback) {\n          progressCallback(1);\n        }\n      }\n    })();\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n\n\n  generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMap = null, options = {}) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        progressTracker\n      } = options;\n      const updateGenerationProgress = progressTracker != null ? progressTracker.beginActivity() : () => {};\n      const useAltEnvironment = environmentMap === 'neutral';\n\n      if (useAltEnvironment === true) {\n        environmentMap = null;\n      }\n\n      const environmentMapUrl = deserializeUrl(environmentMap);\n\n      try {\n        let skyboxLoads = Promise.resolve(null);\n        let environmentMapLoads; // If we have a skybox URL, attempt to load it as a cubemap\n\n        if (!!skyboxUrl) {\n          skyboxLoads = _this15.loadSkyboxFromUrl(skyboxUrl, progressTracker);\n        }\n\n        if (!!environmentMapUrl) {\n          // We have an available environment map URL\n          environmentMapLoads = _this15.loadEnvironmentMapFromUrl(environmentMapUrl, progressTracker);\n        } else if (!!skyboxUrl) {\n          // Fallback to deriving the environment map from an available skybox\n          environmentMapLoads = _this15.loadEnvironmentMapFromUrl(skyboxUrl, progressTracker);\n        } else {\n          // Fallback to generating the environment map\n          environmentMapLoads = useAltEnvironment === true ? _this15.loadGeneratedEnvironmentMapAlt() : _this15.loadGeneratedEnvironmentMap();\n        }\n\n        let [environmentMap, skybox] = yield Promise.all([environmentMapLoads, skyboxLoads]);\n\n        if (environmentMap == null) {\n          throw new Error('Failed to load environment map.');\n        }\n\n        return {\n          environmentMap,\n          skybox\n        };\n      } finally {\n        updateGenerationProgress(1.0);\n      }\n    })();\n  }\n\n  addMetadata(texture, url) {\n    if (texture == null) {\n      return;\n    }\n\n    texture.userData = Object.assign(Object.assign({}, userData), {\n      url: url\n    });\n  }\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n\n\n  loadSkyboxFromUrl(url, progressTracker) {\n    if (!this.skyboxCache.has(url)) {\n      const progressCallback = progressTracker ? progressTracker.beginActivity() : () => {};\n      const skyboxMapLoads = this.load(url, progressCallback);\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n\n    return this.skyboxCache.get(url);\n  }\n  /**\n   * Loads a WebGLRenderTarget from a given URL. The render target in this\n   * case will be assumed to be used as an environment map.\n   */\n\n\n  loadEnvironmentMapFromUrl(url, progressTracker) {\n    if (!this.environmentMapCache.has(url)) {\n      const environmentMapLoads = this.loadSkyboxFromUrl(url, progressTracker).then(equirect => {\n        const cubeUV = this.PMREMGenerator.fromEquirectangular(equirect);\n        this.addMetadata(cubeUV.texture, url);\n        return cubeUV;\n      });\n      this.PMREMGenerator.compileEquirectangularShader();\n      this.environmentMapCache.set(url, environmentMapLoads);\n    }\n\n    return this.environmentMapCache.get(url);\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n\n\n  loadGeneratedEnvironmentMap() {\n    if (this.generatedEnvironmentMap == null) {\n      const defaultScene = new EnvironmentScene();\n      this.generatedEnvironmentMap = this.PMREMGenerator.fromScene(defaultScene, GENERATED_SIGMA);\n      this.addMetadata(this.generatedEnvironmentMap.texture, null);\n    }\n\n    return Promise.resolve(this.generatedEnvironmentMap);\n  }\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n\n\n  loadGeneratedEnvironmentMapAlt() {\n    if (this.generatedEnvironmentMapAlt == null) {\n      const defaultScene = new EnvironmentSceneAlt();\n      this.generatedEnvironmentMapAlt = this.PMREMGenerator.fromScene(defaultScene, GENERATED_SIGMA);\n      this.addMetadata(this.generatedEnvironmentMapAlt.texture, null);\n    }\n\n    return Promise.resolve(this.generatedEnvironmentMapAlt);\n  }\n\n  dispose() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const allTargetsLoad = []; // NOTE(cdata): We would use for-of iteration on the maps here, but\n      // IE11 doesn't have the necessary iterator-returning methods. So,\n      // disposal of these render targets is kind of convoluted as a result.\n\n      _this16.environmentMapCache.forEach(targetLoads => {\n        allTargetsLoad.push(targetLoads);\n      });\n\n      _this16.environmentMapCache.clear();\n\n      for (const targetLoads of allTargetsLoad) {\n        try {\n          const target = yield targetLoads;\n          target.dispose();\n        } catch (e) {// Suppress errors, so that all render targets will be disposed\n        }\n      }\n\n      if (_this16.generatedEnvironmentMap != null) {\n        _this16.generatedEnvironmentMap.dispose();\n\n        _this16.generatedEnvironmentMap = null;\n      }\n\n      if (_this16.generatedEnvironmentMapAlt != null) {\n        _this16.generatedEnvironmentMapAlt.dispose();\n\n        _this16.generatedEnvironmentMapAlt = null;\n      }\n    })();\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Between 0 and 1: larger means the average responds faster and is less smooth.\n\n\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 18;\nconst HIGH_FRAME_DURATION_MS = 26;\nconst MAX_AVG_CHANGE_MS = 2;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nconst DEFAULT_POWER_PREFERENCE = 'high-performance';\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transfering of\n * the texture.\n */\n\nclass Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.debugger = null;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n\n    this.onWebGLContextRestored = () => {\n      var _a;\n\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      this.roughnessMipmapper = new RoughnessMipmapper(this.threeRenderer);\n\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n\n      this.threeRenderer.shadowMap.needsUpdate = true;\n    };\n\n    this.dpr = resolveDpr();\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = GammaEncoding;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n\n      this.threeRenderer.shadowMap.enabled = true;\n      this.threeRenderer.shadowMap.type = PCFSoftShadowMap;\n      this.threeRenderer.shadowMap.autoUpdate = false;\n      this.debugger = !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!this.debugger\n      }; // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    this.roughnessMipmapper = new RoughnessMipmapper(this.threeRenderer);\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n    this.lastTick = performance.now();\n    this.avgFrameDuration = 0;\n  }\n\n  static get singleton() {\n    return this._singleton;\n  }\n\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n\n  set minScale(scale) {\n    let i = 1;\n\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n\n      ++i;\n    }\n\n    this.lastStep = i - 1;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n\n\n  updateRendererSize() {\n    const dpr = resolveDpr();\n\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    } // Make the renderer the size of the largest scene\n\n\n    let width = 0;\n    let height = 0;\n\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n\n    if (this.canRender) {\n      this.threeRenderer.setSize(width * dpr, height * dpr, false);\n    } // Expand the canvas size to make up for shrinking the viewport.\n\n\n    const scale = this.scaleFactor;\n    const widthCSS = width / scale;\n    const heightCSS = height / scale; // The canvas element must by styled outside of three due to the offscreen\n    // canvas not being directly stylable.\n\n    this.canvas3D.style.width = `${widthCSS}px`;\n    this.canvas3D.style.height = `${heightCSS}px`; // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = Math.round(width * dpr);\n      canvas.height = Math.round(height * dpr);\n      canvas.style.width = `${widthCSS}px`;\n      canvas.style.height = `${heightCSS}px`;\n      scene.isDirty = true;\n    }\n  }\n\n  updateRendererScale() {\n    const scaleStep = this.scaleStep;\n\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS && this.scaleStep < this.lastStep) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n\n    if (scaleStep == this.scaleStep) {\n      return;\n    }\n\n    const scale = this.scaleFactor;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    const width = this.width / scale;\n    const height = this.height / scale;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n\n    for (const scene of this.scenes) {\n      const {\n        style\n      } = scene.canvas;\n      style.width = `${width}px`;\n      style.height = `${height}px`;\n      scene.isDirty = true;\n    }\n  }\n\n  registerScene(scene) {\n    this.scenes.add(scene);\n    const {\n      canvas\n    } = scene;\n    const scale = this.scaleFactor;\n    canvas.width = Math.round(this.width * this.dpr);\n    canvas.height = Math.round(this.height * this.dpr);\n    canvas.style.width = `${this.width / scale}px`;\n    canvas.style.height = `${this.height / scale}px`;\n\n    if (this.multipleScenesVisible) {\n      canvas.classList.add('show');\n    }\n\n    scene.isDirty = true;\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n\n  displayCanvas(scene) {\n    return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D;\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n\n\n  selectCanvas() {\n    let visibleScenes = 0;\n    let visibleCanvas = null;\n\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n        visibleCanvas = scene.canvas;\n      }\n    }\n\n    if (visibleCanvas == null) {\n      return;\n    }\n\n    const multipleScenesVisible = visibleScenes > 1;\n    const {\n      canvas3D\n    } = this;\n\n    if (multipleScenesVisible === this.multipleScenesVisible && (multipleScenesVisible || canvas3D.parentElement === visibleCanvas.parentElement)) {\n      return;\n    }\n\n    this.multipleScenesVisible = multipleScenesVisible;\n\n    if (multipleScenesVisible) {\n      canvas3D.classList.remove('show');\n    }\n\n    for (const scene of this.scenes) {\n      if (scene.externalRenderer != null) {\n        continue;\n      }\n\n      const canvas = scene.element[$canvas];\n\n      if (multipleScenesVisible) {\n        canvas.classList.add('show');\n        scene.isDirty = true;\n      } else if (scene.canvas === visibleCanvas) {\n        scene.canvas.parentElement.appendChild(canvas3D);\n        canvas3D.classList.add('show');\n        canvas.classList.remove('show');\n        scene.isDirty = true;\n      }\n    }\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n\n\n  orderedScenes() {\n    const scenes = [];\n\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n\n    return scenes;\n  }\n\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n\n\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !self.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n\n    if (scene.isShadowDirty()) {\n      this.threeRenderer.shadowMap.needsUpdate = true;\n    }\n  }\n\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n    this.selectCanvas();\n    this.updateRendererSize();\n    this.updateRendererScale();\n    const {\n      dpr,\n      scaleFactor\n    } = this;\n\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n\n      if (!element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!scene.isDirty) {\n        continue;\n      }\n\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.isDirty = true;\n          }\n        }\n      } // We avoid using the Three.js PixelRatio and handle it ourselves here so\n      // that we can do proper rounding and avoid white boundary pixels.\n\n\n      const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n      const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height); // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.floor(this.height * dpr) - height, width, height);\n      this.threeRenderer.render(scene, scene.camera);\n\n      if (this.multipleScenesVisible) {\n        if (scene.context == null) {\n          scene.createContext();\n        }\n\n        const context2D = scene.context;\n        context2D.clearRect(0, 0, width, height);\n        context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n      }\n\n      scene.isDirty = false;\n\n      if (element.loaded) {\n        ++scene.renderCount;\n      }\n    }\n  }\n\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.roughnessMipmapper != null) {\n      this.roughnessMipmapper.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n\n}\n\nRenderer._singleton = new Renderer({\n  powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n  debug: isDebugMode()\n});\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Converts a base64 string which represents a data url\n * into a Blob of the same contents.\n */\n\nconst dataUrlToBlob = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (base64DataUrl) {\n    return new Promise((resolve, reject) => {\n      const sliceSize = 512;\n      const typeMatch = base64DataUrl.match(/data:(.*);/);\n\n      if (!typeMatch) {\n        return reject(new Error(`${base64DataUrl} is not a valid data Url`));\n      }\n\n      const type = typeMatch[1];\n      const base64 = base64DataUrl.replace(/data:image\\/\\w+;base64,/, '');\n      const byteCharacters = atob(base64);\n      const byteArrays = [];\n\n      for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n        const slice = byteCharacters.slice(offset, offset + sliceSize);\n        const byteNumbers = new Array(slice.length);\n\n        for (let i = 0; i < slice.length; i++) {\n          byteNumbers[i] = slice.charCodeAt(i);\n        }\n\n        const byteArray = new Uint8Array(byteNumbers);\n        byteArrays.push(byteArray);\n      }\n\n      resolve(new Blob(byteArrays, {\n        type\n      }));\n    });\n  });\n\n  return function dataUrlToBlob(_x12) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a$7, _b$5;\n\nconst $ongoingActivities = Symbol('ongoingActivities');\nconst $announceTotalProgress = Symbol('announceTotalProgress');\nconst $eventDelegate = Symbol('eventDelegate');\nconst ACTIVITY_PROGRESS_WEIGHT = 0.5;\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents a abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\n\nclass ProgressTracker {\n  constructor() {\n    // NOTE(cdata): This eventDelegate hack is a quick trick to let us get the\n    // EventTarget interface without implementing or requiring a full polyfill. We\n    // should remove this once EventTarget is inheritable everywhere.\n    this[_a$7] = document.createDocumentFragment(); // NOTE(cdata): We declare each of these methods independently here so that we\n    // can inherit the correct types from EventTarget's interface. Maybe there is\n    // a better way to do this dynamically so that we don't repeat ourselves?\n\n    this.addEventListener = (...args) => this[$eventDelegate].addEventListener(...args);\n\n    this.removeEventListener = (...args) => this[$eventDelegate].removeEventListener(...args);\n\n    this.dispatchEvent = (...args) => this[$eventDelegate].dispatchEvent(...args);\n\n    this[_b$5] = new Set();\n  }\n  /**\n   * The total number of activities currently being tracked.\n   */\n\n\n  get ongoingActivityCount() {\n    return this[$ongoingActivities].size;\n  }\n  /**\n   * Registers a new activity to be tracked by the progress tracker. The method\n   * returns a special callback that should be invoked whenever new progress is\n   * ready to be reported. The progress should be reported as a value between 0\n   * and 1, where 0 would represent the beginning of the action and 1 would\n   * represent its completion.\n   *\n   * There is no built-in notion of a time-out for ongoing activities, so once\n   * an ongoing activity is begun, it is up to the consumer of this API to\n   * update the progress until that activity is no longer ongoing.\n   *\n   * Progress is only allowed to move forward for any given activity. If a lower\n   * progress is reported than the previously reported progress, it will be\n   * ignored.\n   */\n\n\n  beginActivity() {\n    const activity = {\n      progress: 0\n    };\n    this[$ongoingActivities].add(activity);\n\n    if (this.ongoingActivityCount === 1) {\n      // Announce the first progress event (which should always be 0 / 1\n      // total progress):\n      this[$announceTotalProgress]();\n    }\n\n    return progress => {\n      let nextProgress;\n      nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n\n      if (nextProgress !== activity.progress) {\n        activity.progress = nextProgress;\n        this[$announceTotalProgress]();\n      }\n\n      return activity.progress;\n    };\n  }\n\n  [(_a$7 = $eventDelegate, _b$5 = $ongoingActivities, $announceTotalProgress)]() {\n    let totalProgress = 0;\n    let statusCount = 0;\n    let completedActivities = 0;\n\n    for (const activity of this[$ongoingActivities]) {\n      const {\n        progress\n      } = activity;\n      const compoundWeight = ACTIVITY_PROGRESS_WEIGHT / Math.pow(2, statusCount++);\n      totalProgress += progress * compoundWeight;\n\n      if (progress === 1.0) {\n        completedActivities++;\n      }\n    }\n\n    if (completedActivities === this.ongoingActivityCount) {\n      totalProgress = 1.0;\n      this[$ongoingActivities].clear();\n    }\n\n    this.dispatchEvent(new CustomEvent('progress', {\n      detail: {\n        totalProgress\n      }\n    }));\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar _a$6, _b$4, _c$2, _d$1, _e, _f, _g, _h, _j, _k;\n\nconst CLEAR_MODEL_TIMEOUT_MS = 1000;\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\nconst blobCanvas = document.createElement('canvas');\nconst $template = Symbol('template');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $clearModelTimeout = Symbol('clearModelTimeout');\nconst $onContextLost = Symbol('onContextLost');\nconst $loaded = Symbol('loaded');\nconst $updateSize = Symbol('updateSize');\nconst $intersectionObserver = Symbol('intersectionObserver');\nconst $isElementInViewport = Symbol('isElementInViewport');\nconst $announceModelVisibility = Symbol('announceModelVisibility');\nconst $ariaLabel = Symbol('ariaLabel');\nconst $loadedTime = Symbol('loadedTime');\nconst $updateSource = Symbol('updateSource');\nconst $markLoaded = Symbol('markLoaded');\nconst $container = Symbol('container');\nconst $userInputElement = Symbol('input');\nconst $canvas = Symbol('canvas');\nconst $scene = Symbol('scene');\nconst $needsRender = Symbol('needsRender');\nconst $tick = Symbol('tick');\nconst $onModelLoad = Symbol('onModelLoad');\nconst $onResize = Symbol('onResize');\nconst $renderer = Symbol('renderer');\nconst $progressTracker = Symbol('progressTracker');\nconst $getLoaded = Symbol('getLoaded');\nconst $getModelIsVisible = Symbol('getModelIsVisible');\nconst $shouldAttemptPreload = Symbol('shouldAttemptPreload');\nconst $sceneIsReady = Symbol('sceneIsReady');\nconst $hasTransitioned = Symbol('hasTransitioned');\n\nconst toVector3D = v => {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n\n    toString() {\n      return `${this.x}m ${this.y}m ${this.z}m`;\n    }\n\n  };\n};\n/**\n * Definition for a basic <model-viewer> element.\n */\n\n\nclass ModelViewerElementBase extends UpdatingElement {\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    var _this17;\n\n    super();\n    _this17 = this;\n    this.alt = null;\n    this.src = null;\n    this[_a$6] = false;\n    this[_b$4] = false;\n    this[_c$2] = 0;\n    this[_d$1] = null;\n    this[_e] = debounce(() => {\n      const boundingRect = this.getBoundingClientRect();\n      this[$updateSize](boundingRect);\n    }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n    this[_f] = debounce(oldVisibility => {\n      const newVisibility = this.modelIsVisible;\n\n      if (newVisibility !== oldVisibility) {\n        this.dispatchEvent(new CustomEvent('model-visibility', {\n          detail: {\n            visible: newVisibility\n          }\n        }));\n      }\n    }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n    this[_g] = null;\n    this[_h] = null;\n    this[_j] = new ProgressTracker();\n\n    this[_k] = event => {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: {\n          type: 'webglcontextlost',\n          sourceError: event.sourceEvent\n        }\n      }));\n    }; // NOTE(cdata): It is *very important* to access this template first so that\n    // the ShadyCSS template preparation steps happen before element styling in\n    // IE11:\n\n\n    const template = this.constructor.template;\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleElement(this, {});\n    } // NOTE(cdata): The canonical ShadyCSS examples suggest that the Shadow Root\n    // should be created after the invocation of ShadyCSS.styleElement\n\n\n    this.attachShadow({\n      mode: 'open'\n    });\n    const shadowRoot = this.shadowRoot;\n    shadowRoot.appendChild(template.content.cloneNode(true));\n    this[$container] = shadowRoot.querySelector('.container');\n    this[$userInputElement] = shadowRoot.querySelector('.userInput');\n    this[$canvas] = shadowRoot.querySelector('canvas');\n    this[$defaultAriaLabel] = this[$userInputElement].getAttribute('aria-label'); // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n\n    let width, height;\n\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    } // Create the underlying ModelScene.\n\n\n    this[$scene] = new ModelScene({\n      canvas: this[$canvas],\n      element: this,\n      width,\n      height\n    });\n    this[$scene].addEventListener('model-load', /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator(function* (event) {\n        _this17[$markLoaded]();\n\n        _this17[$onModelLoad](); // Give loading async tasks a chance to complete.\n\n\n        yield timePasses();\n\n        _this17.dispatchEvent(new CustomEvent('load', {\n          detail: {\n            url: event.url\n          }\n        }));\n      });\n\n      return function (_x13) {\n        return _ref7.apply(this, arguments);\n      };\n    }()); // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect());\n    });\n\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver(entries => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver] = new IntersectionObserver(entries => {\n        for (let entry of entries) {\n          if (entry.target === this) {\n            const oldVisibility = this.modelIsVisible;\n            this[$isElementInViewport] = entry.isIntersecting;\n            this[$announceModelVisibility](oldVisibility);\n\n            if (this[$isElementInViewport] && !this[$sceneIsReady]()) {\n              this[$updateSource]();\n            }\n          }\n        }\n      }, {\n        root: null,\n        // We used to have margin here, but it was causing animated models below\n        // the fold to steal the frame budget. Weirder still, it would also\n        // cause input events to be swallowed, sometimes for seconds on the\n        // model above the fold, but only when the animated model was completely\n        // below. Setting this margin to zero fixed it.\n        rootMargin: '0px',\n        threshold: 0\n      });\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      this[$isElementInViewport] = true;\n    }\n  }\n\n  static get is() {\n    return 'model-viewer';\n  }\n  /** @nocollapse */\n\n\n  static get template() {\n    if (!this.hasOwnProperty($template)) {\n      this[$template] = makeTemplate(this.is);\n    }\n\n    return this[$template];\n  }\n  /** @export */\n\n\n  static set modelCacheSize(value) {\n    CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n  }\n  /** @export */\n\n\n  static get modelCacheSize() {\n    return CachingGLTFLoader[$evictionPolicy].evictionThreshold;\n  }\n  /** @export */\n\n\n  static set minimumRenderScale(value) {\n    if (value > 1) {\n      console.warn('<model-viewer> minimumRenderScale has been clamped to a maximum value of 1.');\n    }\n\n    if (value <= 0) {\n      console.warn('<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25.');\n    }\n\n    Renderer.singleton.minScale = value;\n  }\n  /** @export */\n\n\n  static get minimumRenderScale() {\n    return Renderer.singleton.minScale;\n  }\n  /** @export */\n\n\n  get loaded() {\n    return this[$getLoaded]();\n  }\n\n  get [(_a$6 = $isElementInViewport, _b$4 = $loaded, _c$2 = $loadedTime, _d$1 = $clearModelTimeout, _e = $fallbackResizeHandler, _f = $announceModelVisibility, _g = $resizeObserver, _h = $intersectionObserver, _j = $progressTracker, $renderer)]() {\n    return Renderer.singleton;\n  }\n  /** @export */\n\n\n  get modelIsVisible() {\n    return this[$getModelIsVisible]();\n  }\n\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].observe(this);\n    }\n\n    const renderer = this[$renderer];\n    renderer.addEventListener('contextlost', this[$onContextLost]);\n    renderer.registerScene(this[$scene]);\n\n    if (this[$clearModelTimeout] != null) {\n      self.clearTimeout(this[$clearModelTimeout]);\n      this[$clearModelTimeout] = null; // Force an update in case the model has been evicted from our GLTF cache\n      // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n\n      this.requestUpdate('src', null);\n    }\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].unobserve(this);\n    }\n\n    const renderer = this[$renderer];\n    renderer.removeEventListener('contextlost', this[$onContextLost]);\n    renderer.unregisterScene(this[$scene]);\n    this[$clearModelTimeout] = self.setTimeout(() => {\n      this[$scene].reset();\n    }, CLEAR_MODEL_TIMEOUT_MS);\n  }\n\n  updated(changedProperties) {\n    super.updated(changedProperties); // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n\n    if (changedProperties.has('src')) {\n      if (this.src == null) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$scene].reset();\n      } else if (this.src !== this[$scene].url) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$updateSource]();\n      }\n    }\n\n    if (changedProperties.has('alt')) {\n      const ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n      this[$userInputElement].setAttribute('aria-label', ariaLabel);\n    }\n  }\n  /** @export */\n\n\n  toDataURL(type, encoderOptions) {\n    return this[$renderer].displayCanvas(this[$scene]).toDataURL(type, encoderOptions);\n  }\n  /** @export */\n\n\n  toBlob(options) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      const mimeType = options ? options.mimeType : undefined;\n      const qualityArgument = options ? options.qualityArgument : undefined;\n      const idealAspect = options ? options.idealAspect : undefined;\n      const {\n        width,\n        height,\n        fieldOfViewAspect,\n        aspect\n      } = _this18[$scene];\n      const {\n        dpr,\n        scaleFactor\n      } = _this18[$renderer];\n      let outputWidth = width * scaleFactor * dpr;\n      let outputHeight = height * scaleFactor * dpr;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (idealAspect === true) {\n        if (fieldOfViewAspect > aspect) {\n          const oldHeight = outputHeight;\n          outputHeight = Math.round(outputWidth / fieldOfViewAspect);\n          offsetY = (oldHeight - outputHeight) / 2;\n        } else {\n          const oldWidth = outputWidth;\n          outputWidth = Math.round(outputHeight * fieldOfViewAspect);\n          offsetX = (oldWidth - outputWidth) / 2;\n        }\n      }\n\n      blobCanvas.width = outputWidth;\n      blobCanvas.height = outputHeight;\n\n      try {\n        return new Promise( /*#__PURE__*/function () {\n          var _ref8 = _asyncToGenerator(function* (resolve, reject) {\n            blobCanvas.getContext('2d').drawImage(_this18[$renderer].displayCanvas(_this18[$scene]), offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight);\n\n            if (blobCanvas.msToBlob) {\n              // NOTE: msToBlob only returns image/png\n              // so ensure mimeType is not specified (defaults to image/png)\n              // or is image/png, otherwise fallback to using toDataURL on IE.\n              if (!mimeType || mimeType === 'image/png') {\n                return resolve(blobCanvas.msToBlob());\n              }\n            }\n\n            if (!blobCanvas.toBlob) {\n              return resolve(yield dataUrlToBlob(blobCanvas.toDataURL(mimeType, qualityArgument)));\n            }\n\n            blobCanvas.toBlob(blob => {\n              if (!blob) {\n                return reject(new Error('Unable to retrieve canvas blob'));\n              }\n\n              resolve(blob);\n            }, mimeType, qualityArgument);\n          });\n\n          return function (_x14, _x15) {\n            return _ref8.apply(this, arguments);\n          };\n        }());\n      } finally {\n        _this18[$updateSize]({\n          width,\n          height\n        });\n      }\n    })();\n  }\n\n  registerRenderer(renderer) {\n    this[$scene].externalRenderer = renderer;\n  }\n\n  unregisterRenderer() {\n    this[$scene].externalRenderer = null;\n  }\n\n  get [$ariaLabel]() {\n    return this.alt == null || this.alt === 'null' ? this[$defaultAriaLabel] : this.alt;\n  } // NOTE(cdata): Although this may seem extremely redundant, it is required in\n  // order to support overloading when TypeScript is compiled to ES5\n  // @see https://github.com/Polymer/lit-element/pull/745\n  // @see https://github.com/microsoft/TypeScript/issues/338\n\n\n  [$getLoaded]() {\n    return this[$loaded];\n  } // @see [$getLoaded]\n\n\n  [$getModelIsVisible]() {\n    return this.loaded && this[$isElementInViewport];\n  }\n\n  [$hasTransitioned]() {\n    return this.modelIsVisible;\n  }\n\n  [$shouldAttemptPreload]() {\n    return !!this.src && this[$isElementInViewport];\n  }\n\n  [$sceneIsReady]() {\n    return this[$loaded];\n  }\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n\n\n  [$updateSize]({\n    width,\n    height\n  }) {\n    this[$container].style.width = `${width}px`;\n    this[$container].style.height = `${height}px`;\n    this[$onResize]({\n      width: parseFloat(width),\n      height: parseFloat(height)\n    });\n  }\n\n  [$tick](_time, _delta) {}\n\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n\n    this[$loaded] = true;\n    this[$loadedTime] = performance.now();\n  }\n\n  [$needsRender]() {\n    this[$scene].isDirty = true;\n  }\n\n  [$onModelLoad]() {}\n\n  [$onResize](e) {\n    this[$scene].setSize(e.width, e.height);\n  }\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based off of the `preload`\n   * attribute.\n   */\n\n\n  [(_k = $onContextLost, $updateSource)]() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this19.loaded || !_this19[$shouldAttemptPreload]()) {\n        return;\n      }\n\n      const updateSourceProgress = _this19[$progressTracker].beginActivity();\n\n      const source = _this19.src;\n\n      try {\n        yield _this19[$scene].setSource(source, progress => updateSourceProgress(progress * 0.8));\n        const detail = {\n          url: source\n        };\n\n        _this19.dispatchEvent(new CustomEvent('preload', {\n          detail\n        }));\n      } catch (error) {\n        _this19.dispatchEvent(new CustomEvent('error', {\n          detail: error\n        }));\n      } finally {\n        updateSourceProgress(0.9);\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            updateSourceProgress(1.0);\n          });\n        });\n      }\n    })();\n  }\n\n}\n\n__decorate$6([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"alt\", void 0);\n\n__decorate$6([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"src\", void 0);\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nconst MILLISECONDS_PER_SECOND = 1000.0;\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\n\nconst AnimationMixin = ModelViewerElement => {\n  var _a;\n\n  class AnimationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.autoplay = false;\n      this.animationName = undefined;\n      this.animationCrossfadeDuration = 300;\n      this[_a] = true;\n    }\n    /**\n     * Returns an array\n     */\n\n\n    get availableAnimations() {\n      if (this.loaded) {\n        return this[$scene].animationNames;\n      }\n\n      return [];\n    }\n\n    get duration() {\n      return this[$scene].duration;\n    }\n\n    get paused() {\n      return this[$paused];\n    }\n\n    get currentTime() {\n      return this[$scene].animationTime;\n    }\n\n    set currentTime(value) {\n      this[$scene].animationTime = value;\n      this[$renderer].threeRenderer.shadowMap.needsUpdate = true;\n      this[$needsRender]();\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this[$renderer].threeRenderer.shadowMap.autoUpdate = false;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play() {\n      if (this[$paused] && this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$renderer].threeRenderer.shadowMap.autoUpdate = true;\n\n        if (!this[$scene].hasActiveAnimation) {\n          this[$changeAnimation]();\n        }\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    [(_a = $paused, $onModelLoad)]() {\n      super[$onModelLoad]();\n      this[$paused] = true;\n\n      if (this.autoplay) {\n        this[$changeAnimation]();\n        this.play();\n      }\n    }\n\n    [$tick](_time, delta) {\n      super[$tick](_time, delta);\n\n      if (this[$paused] || !this[$hasTransitioned]() && !this[$renderer].isPresenting) {\n        return;\n      }\n\n      this[$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);\n      this[$needsRender]();\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    [$updateSource]() {\n      var _superprop_get = _prop => super[_prop],\n          _this20 = this;\n\n      return _asyncToGenerator(function* () {\n        // If we are loading a new model, we need to stop the animation of\n        // the current one (if any is playing). Otherwise, we might lose\n        // the reference to the scene root and running actions start to\n        // throw exceptions and/or behave in unexpected ways:\n        _this20[$scene].stopAnimation();\n\n        return _superprop_get($updateSource).call(_this20);\n      })();\n    }\n\n    [$changeAnimation]() {\n      this[$scene].playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND); // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n\n  }\n\n  __decorate$5([property({\n    type: Boolean\n  })], AnimationModelViewerElement.prototype, \"autoplay\", void 0);\n\n  __decorate$5([property({\n    type: String,\n    attribute: 'animation-name'\n  })], AnimationModelViewerElement.prototype, \"animationName\", void 0);\n\n  __decorate$5([property({\n    type: Number,\n    attribute: 'animation-crossfade-duration'\n  })], AnimationModelViewerElement.prototype, \"animationCrossfadeDuration\", void 0);\n\n  return AnimationModelViewerElement;\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot'); // Used internally by positionAndNormalFromPoint()\n\nconst pixelPosition = new Vector2();\nconst worldToModel = new Matrix4();\nconst worldToModelNormal = new Matrix3();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\n\nconst AnnotationMixin = ModelViewerElement => {\n  var _a, _b, _c;\n\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Map();\n\n      this[_b] = mutations => {\n        mutations.forEach(mutation => {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {\n            mutation.addedNodes.forEach(node => {\n              this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach(node => {\n              this[$removeHotspot](node);\n            });\n            this[$needsRender]();\n          }\n        });\n      };\n\n      this[_c] = new MutationObserver(this[$mutationCallback]);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n\n      const {\n        ShadyDOM\n      } = self;\n\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {\n          childList: true\n        });\n      } else {\n        this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      const {\n        ShadyDOM\n      } = self;\n\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n\n    [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, $tick)](time, delta) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const {\n        annotationRenderer\n      } = scene;\n      const camera = scene.getCamera();\n\n      if (scene.isDirty) {\n        scene.updateHotspots(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n\n\n    updateHotspot(config) {\n      const hotspot = this[$hotspotMap].get(config.name);\n\n      if (hotspot == null) {\n        return;\n      }\n\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      this[$needsRender]();\n    }\n    /**\n     * This method returns the model position and normal of the point on the\n     * mesh corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The position and normal are returned as strings in\n     * the format suitable for putting in a hotspot's data-position and\n     * data-normal attributes. If the mesh is not hit, the result is null.\n     */\n\n\n    positionAndNormalFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const {\n        width,\n        height,\n        target\n      } = scene;\n      pixelPosition.set(pixelX / width, pixelY / height).multiplyScalar(2).subScalar(1);\n      pixelPosition.y *= -1;\n      const hit = scene.positionAndNormalFromPoint(pixelPosition);\n\n      if (hit == null) {\n        return null;\n      }\n\n      worldToModel.copy(target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      worldToModelNormal.getNormalMatrix(worldToModel);\n      const normal = toVector3D(hit.normal.applyNormalMatrix(worldToModelNormal));\n      return {\n        position: position,\n        normal: normal\n      };\n    }\n\n    [$addHotspot](node) {\n      if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n\n      let hotspot = this[$hotspotMap].get(node.slot);\n\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n\n      this[$scene].isDirty = true;\n    }\n\n    [$removeHotspot](node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n\n      const hotspot = this[$hotspotMap].get(node.slot);\n\n      if (!hotspot) {\n        return;\n      }\n\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n\n      this[$scene].isDirty = true;\n    }\n\n  }\n\n  return AnnotationModelViewerElement;\n};\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\nversion 0.6.9\n*/\n\n\nvar durl = function (c) {\n  return URL.createObjectURL(new Blob([c], {\n    type: 'text/javascript'\n  }));\n};\n\ntry {\n  URL.revokeObjectURL(durl(''));\n} catch (e) {\n  // We're in Deno or a very old browser\n  durl = function (c) {\n    return 'data:application/javascript;charset=UTF-8,' + encodeURI(c);\n  };\n} // aliases for shorter compressed code (most minifers don't do this)\n\n\nvar u8 = Uint8Array,\n    u16 = Uint16Array,\n    u32 = Uint32Array; // fixed length extra bits\n\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // code length index map\n\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // get base, reverse index map from extra bits\n\nvar freb = function (eb, start) {\n  var b = new u16(31);\n\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  var r = new u32(b[30]);\n\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n\n  return [b, r];\n};\n\nvar _a$5 = freb(fleb, 2),\n    fl = _a$5[0],\n    revfl = _a$5[1]; // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\n\nfl[28] = 258, revfl[258] = 28;\n\nvar _b$3 = freb(fdeb, 0),\n    revfd = _b$3[1]; // map of value to reverse (assuming 16 bits)\n\n\nvar rev = new u16(32768);\n\nfor (var i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nvar hMap = function (cd, mb, r) {\n  var s = cd.length; // index\n\n  var i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  var l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) ++l[cd[i] - 1]; // u16 \"map\": index -> minimum code for bit length = index\n\n\n  var le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  var co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    var rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        var sv = i << 4 | cd[i]; // free bits\n\n        var r_1 = mb - cd[i]; // start value\n\n        var v = le[cd[i] - 1]++ << r_1; // m is end value\n\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n      }\n    }\n  }\n\n  return co;\n}; // fixed length tree\n\n\nvar flt = new u8(288);\n\nfor (var i = 0; i < 144; ++i) flt[i] = 8;\n\nfor (var i = 144; i < 256; ++i) flt[i] = 9;\n\nfor (var i = 256; i < 280; ++i) flt[i] = 7;\n\nfor (var i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree\n\n\nvar fdt = new u8(32);\n\nfor (var i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map\n\n\nvar flm = /*#__PURE__*/hMap(flt, 9, 0); // fixed distance map\n\nvar fdm = /*#__PURE__*/hMap(fdt, 5, 0); // get end of byte\n\nvar shft = function (p) {\n  return (p / 8 | 0) + (p & 7 && 1);\n}; // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nvar slc = function (v, s, e) {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // starting at p, write the minimum number of bits that can hold v to d\n\n\nvar wbits = function (d, p, v) {\n  v <<= p & 7;\n  var o = p / 8 | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n}; // starting at p, write the minimum number of bits (>8) that can hold v to d\n\n\nvar wbits16 = function (d, p, v) {\n  v <<= p & 7;\n  var o = p / 8 | 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n  d[o + 2] |= v >>> 16;\n}; // creates code lengths from a frequency table\n\n\nvar hTree = function (d, mb) {\n  // Need extra info to make a tree\n  var t = [];\n\n  for (var i = 0; i < d.length; ++i) {\n    if (d[i]) t.push({\n      s: i,\n      f: d[i]\n    });\n  }\n\n  var s = t.length;\n  var t2 = t.slice();\n  if (!s) return [et, 0];\n\n  if (s == 1) {\n    var v = new u8(t[0].s + 1);\n    v[t[0].s] = 1;\n    return [v, 1];\n  }\n\n  t.sort(function (a, b) {\n    return a.f - b.f;\n  }); // after i2 reaches last ind, will be stopped\n  // freq must be greater than largest possible number of symbols\n\n  t.push({\n    s: -1,\n    f: 25001\n  });\n  var l = t[0],\n      r = t[1],\n      i0 = 0,\n      i1 = 1,\n      i2 = 2;\n  t[0] = {\n    s: -1,\n    f: l.f + r.f,\n    l: l,\n    r: r\n  }; // efficient algorithm from UZIP.js\n  // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n  // symbols that combined have high freq, will start processing i2 (high-freq,\n  // non-composite) symbols instead\n  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n\n  while (i1 != s - 1) {\n    l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n    t[i1++] = {\n      s: -1,\n      f: l.f + r.f,\n      l: l,\n      r: r\n    };\n  }\n\n  var maxSym = t2[0].s;\n\n  for (var i = 1; i < s; ++i) {\n    if (t2[i].s > maxSym) maxSym = t2[i].s;\n  } // code lengths\n\n\n  var tr = new u16(maxSym + 1); // max bits in tree\n\n  var mbt = ln(t[i1 - 1], tr, 0);\n\n  if (mbt > mb) {\n    // more algorithms from UZIP.js\n    // TODO: find out how this code works (debt)\n    //  ind    debt\n    var i = 0,\n        dt = 0; //    left            cost\n\n    var lft = mbt - mb,\n        cst = 1 << lft;\n    t2.sort(function (a, b) {\n      return tr[b.s] - tr[a.s] || a.f - b.f;\n    });\n\n    for (; i < s; ++i) {\n      var i2_1 = t2[i].s;\n\n      if (tr[i2_1] > mb) {\n        dt += cst - (1 << mbt - tr[i2_1]);\n        tr[i2_1] = mb;\n      } else break;\n    }\n\n    dt >>>= lft;\n\n    while (dt > 0) {\n      var i2_2 = t2[i].s;\n      if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;else ++i;\n    }\n\n    for (; i >= 0 && dt; --i) {\n      var i2_3 = t2[i].s;\n\n      if (tr[i2_3] == mb) {\n        --tr[i2_3];\n        ++dt;\n      }\n    }\n\n    mbt = mb;\n  }\n\n  return [new u8(tr), mbt];\n}; // get the max length and assign length codes\n\n\nvar ln = function (n, l, d) {\n  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n}; // length codes generation\n\n\nvar lc = function (c) {\n  var s = c.length; // Note that the semicolon was intentional\n\n  while (s && !c[--s]);\n\n  var cl = new u16(++s); //  ind      num         streak\n\n  var cli = 0,\n      cln = c[0],\n      cls = 1;\n\n  var w = function (v) {\n    cl[cli++] = v;\n  };\n\n  for (var i = 1; i <= s; ++i) {\n    if (c[i] == cln && i != s) ++cls;else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138) w(32754);\n\n        if (cls > 2) {\n          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w(cln), --cls;\n\n        for (; cls > 6; cls -= 6) w(8304);\n\n        if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n      }\n\n      while (cls--) w(cln);\n\n      cls = 1;\n      cln = c[i];\n    }\n  }\n\n  return [cl.subarray(0, cli), s];\n}; // calculate the length of output from tree, code lengths\n\n\nvar clen = function (cf, cl) {\n  var l = 0;\n\n  for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];\n\n  return l;\n}; // writes a fixed block\n// returns the new bit pos\n\n\nvar wfblk = function (out, pos, dat) {\n  // no need to write 00 as type: TypedArray defaults to 0\n  var s = dat.length;\n  var o = shft(pos + 2);\n  out[o] = s & 255;\n  out[o + 1] = s >>> 8;\n  out[o + 2] = out[o] ^ 255;\n  out[o + 3] = out[o + 1] ^ 255;\n\n  for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];\n\n  return (o + 4 + s) * 8;\n}; // writes a block\n\n\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n  wbits(out, p++, final);\n  ++lf[256];\n\n  var _a = hTree(lf, 15),\n      dlt = _a[0],\n      mlb = _a[1];\n\n  var _b = hTree(df, 15),\n      ddt = _b[0],\n      mdb = _b[1];\n\n  var _c = lc(dlt),\n      lclt = _c[0],\n      nlc = _c[1];\n\n  var _d = lc(ddt),\n      lcdt = _d[0],\n      ndc = _d[1];\n\n  var lcfreq = new u16(19);\n\n  for (var i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;\n\n  for (var i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;\n\n  var _e = hTree(lcfreq, 7),\n      lct = _e[0],\n      mlcb = _e[1];\n\n  var nlcc = 19;\n\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n\n  var flen = bl + 5 << 3;\n  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n  if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n  var lm, ll, dm, dl;\n  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n\n  if (dtlen < ftlen) {\n    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n    var llm = hMap(lct, mlcb, 0);\n    wbits(out, p, nlc - 257);\n    wbits(out, p + 5, ndc - 1);\n    wbits(out, p + 10, nlcc - 4);\n    p += 14;\n\n    for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);\n\n    p += 3 * nlcc;\n    var lcts = [lclt, lcdt];\n\n    for (var it = 0; it < 2; ++it) {\n      var clct = lcts[it];\n\n      for (var i = 0; i < clct.length; ++i) {\n        var len = clct[i] & 31;\n        wbits(out, p, llm[len]), p += lct[len];\n        if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n      }\n    }\n  } else {\n    lm = flm, ll = flt, dm = fdm, dl = fdt;\n  }\n\n  for (var i = 0; i < li; ++i) {\n    if (syms[i] > 255) {\n      var len = syms[i] >>> 18 & 31;\n      wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n      if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n      var dst = syms[i] & 31;\n      wbits16(out, p, dm[dst]), p += dl[dst];\n      if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n    } else {\n      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n    }\n  }\n\n  wbits16(out, p, lm[256]);\n  return p + ll[256];\n}; // deflate options (nice << 13) | chain\n\n\nvar deo = /*#__PURE__*/new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]); // empty\n\nvar et = /*#__PURE__*/new u8(0); // compresses data into a raw DEFLATE buffer\n\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n  var s = dat.length;\n  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post); // writing to this writes to the output buffer\n\n  var w = o.subarray(pre, o.length - post);\n  var pos = 0;\n\n  if (!lvl || s < 8) {\n    for (var i = 0; i <= s; i += 65535) {\n      // end\n      var e = i + 65535;\n\n      if (e < s) {\n        // write full block\n        pos = wfblk(w, pos, dat.subarray(i, e));\n      } else {\n        // write final block\n        w[i] = lst;\n        pos = wfblk(w, pos, dat.subarray(i, s));\n      }\n    }\n  } else {\n    var opt = deo[lvl - 1];\n    var n = opt >>> 13,\n        c = opt & 8191;\n    var msk_1 = (1 << plvl) - 1; //    prev 2-byte val map    curr 2-byte val map\n\n    var prev = new u16(32768),\n        head = new u16(msk_1 + 1);\n    var bs1_1 = Math.ceil(plvl / 3),\n        bs2_1 = 2 * bs1_1;\n\n    var hsh = function (i) {\n      return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n    }; // 24576 is an arbitrary number of maximum symbols per block\n    // 424 buffer for last block\n\n\n    var syms = new u32(25000); // length/literal freq   distance freq\n\n    var lf = new u16(288),\n        df = new u16(32); //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n\n    var lc_1 = 0,\n        eb = 0,\n        i = 0,\n        li = 0,\n        wi = 0,\n        bs = 0;\n\n    for (; i < s; ++i) {\n      // hash value\n      // deopt when i > s - 3 - at end, deopt acceptable\n      var hv = hsh(i); // index mod 32768    previous index mod\n\n      var imod = i & 32767,\n          pimod = head[hv];\n      prev[imod] = pimod;\n      head[hv] = imod; // We always should modify head and prev, but only add symbols if\n      // this data is not yet processed (\"wait\" for wait index)\n\n      if (wi <= i) {\n        // bytes remaining\n        var rem = s - i;\n\n        if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n          li = lc_1 = eb = 0, bs = i;\n\n          for (var j = 0; j < 286; ++j) lf[j] = 0;\n\n          for (var j = 0; j < 30; ++j) df[j] = 0;\n        } //  len    dist   chain\n\n\n        var l = 2,\n            d = 0,\n            ch_1 = c,\n            dif = imod - pimod & 32767;\n\n        if (rem > 2 && hv == hsh(i - dif)) {\n          var maxn = Math.min(n, rem) - 1;\n          var maxd = Math.min(32767, i); // max possible length\n          // not capped at dif because decompressors implement \"rolling\" index population\n\n          var ml = Math.min(258, rem);\n\n          while (dif <= maxd && --ch_1 && imod != pimod) {\n            if (dat[i + l] == dat[i + l - dif]) {\n              var nl = 0;\n\n              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n\n              if (nl > l) {\n                l = nl, d = dif; // break out early when we reach \"nice\" (we are satisfied enough)\n\n                if (nl > maxn) break; // now, find the rarest 2-byte sequence within this\n                // length of literals and search for that instead.\n                // Much faster than just using the start\n\n                var mmd = Math.min(dif, nl - 2);\n                var md = 0;\n\n                for (var j = 0; j < mmd; ++j) {\n                  var ti = i - dif + j + 32768 & 32767;\n                  var pti = prev[ti];\n                  var cd = ti - pti + 32768 & 32767;\n                  if (cd > md) md = cd, pimod = ti;\n                }\n              }\n            } // check the previous match\n\n\n            imod = pimod, pimod = prev[imod];\n            dif += imod - pimod + 32768 & 32767;\n          }\n        } // d will be nonzero only when a match was found\n\n\n        if (d) {\n          // store both dist and len data in one Uint32\n          // Make sure this is recognized as a len/dist with 28th bit (2^28)\n          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n          var lin = revfl[l] & 31,\n              din = revfd[d] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i + l;\n          ++lc_1;\n        } else {\n          syms[li++] = dat[i];\n          ++lf[dat[i]];\n        }\n      }\n    }\n\n    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos); // this is the easiest way to avoid needing to maintain state\n\n    if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n  }\n\n  return slc(o, 0, pre + shft(pos) + post);\n}; // CRC32 table\n\n\nvar crct = /*#__PURE__*/function () {\n  var t = new u32(256);\n\n  for (var i = 0; i < 256; ++i) {\n    var c = i,\n        k = 9;\n\n    while (--k) c = (c & 1 && 0xEDB88320) ^ c >>> 1;\n\n    t[i] = c;\n  }\n\n  return t;\n}(); // CRC32\n\n\nvar crc = function () {\n  var c = -1;\n  return {\n    p: function (d) {\n      // closures have awful performance\n      var cr = c;\n\n      for (var i = 0; i < d.length; ++i) cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n\n      c = cr;\n    },\n    d: function () {\n      return ~c;\n    }\n  };\n}; // deflate with opts\n\n\nvar dopt = function (dat, opt, pre, post, st) {\n  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n}; // Walmart object spread\n\n\nvar mrg = function (a, b) {\n  var o = {};\n\n  for (var k in a) o[k] = a[k];\n\n  for (var k in b) o[k] = b[k];\n\n  return o;\n}; // write bytes\n\n\nvar wbytes = function (d, b, v) {\n  for (; v; ++b) d[b] = v, v >>>= 8;\n};\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\n\n\nfunction deflateSync(data, opts) {\n  return dopt(data, opts || {}, 0, 0);\n} // flatten a directory structure\n\n\nvar fltn = function (d, p, t, o) {\n  for (var k in d) {\n    var val = d[k],\n        n = p + k;\n    if (val instanceof u8) t[n] = [val, o];else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])];else fltn(val, n + '/', t, o);\n  }\n}; // text encoder\n\n\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/new TextEncoder(); // text decoder\n\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/new TextDecoder(); // text decoder stream\n\nvar tds = 0;\n\ntry {\n  td.decode(et, {\n    stream: true\n  });\n  tds = 1;\n} catch (e) {}\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\n\n\nfunction strToU8(str, latin1) {\n  if (latin1) {\n    var ar_1 = new u8(str.length);\n\n    for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);\n\n    return ar_1;\n  }\n\n  if (te) return te.encode(str);\n  var l = str.length;\n  var ar = new u8(str.length + (str.length >> 1));\n  var ai = 0;\n\n  var w = function (v) {\n    ar[ai++] = v;\n  };\n\n  for (var i = 0; i < l; ++i) {\n    if (ai + 5 > ar.length) {\n      var n = new u8(ai + 8 + (l - i << 1));\n      n.set(ar);\n      ar = n;\n    }\n\n    var c = str.charCodeAt(i);\n    if (c < 128 || latin1) w(c);else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n  }\n\n  return slc(ar, 0, ai);\n} // extra field length\n\n\nvar exfl = function (ex) {\n  var le = 0;\n\n  if (ex) {\n    for (var k in ex) {\n      var l = ex[k].length;\n      if (l > 65535) throw 'extra field too long';\n      le += l + 4;\n    }\n  }\n\n  return le;\n}; // write zip header\n\n\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n  var fl = fn.length,\n      ex = f.extra,\n      col = co && co.length;\n  var exl = exfl(ex);\n  wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n  if (ce != null) d[b++] = 20, d[b++] = f.os;\n  d[b] = 20, b += 2; // spec compliance? what's that?\n\n  d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n  var dt = new Date(f.mtime == null ? Date.now() : f.mtime),\n      y = dt.getFullYear() - 1980;\n  if (y < 0 || y > 119) throw 'date not in range 1980-2099';\n  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n\n  if (c != null) {\n    wbytes(d, b, f.crc);\n    wbytes(d, b + 4, c);\n    wbytes(d, b + 8, f.size);\n  }\n\n  wbytes(d, b + 12, fl);\n  wbytes(d, b + 14, exl), b += 16;\n\n  if (ce != null) {\n    wbytes(d, b, col);\n    wbytes(d, b + 6, f.attrs);\n    wbytes(d, b + 10, ce), b += 14;\n  }\n\n  d.set(fn, b);\n  b += fl;\n\n  if (exl) {\n    for (var k in ex) {\n      var exf = ex[k],\n          l = exf.length;\n      wbytes(d, b, +k);\n      wbytes(d, b + 2, l);\n      d.set(exf, b + 4), b += 4 + l;\n    }\n  }\n\n  if (col) d.set(co, b), b += col;\n  return b;\n}; // write zip footer (end of central directory)\n\n\nvar wzf = function (o, b, c, d, e) {\n  wbytes(o, b, 0x6054B50); // skip disk\n\n  wbytes(o, b + 8, c);\n  wbytes(o, b + 10, c);\n  wbytes(o, b + 12, d);\n  wbytes(o, b + 16, e);\n};\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\n\n\nfunction zipSync(data, opts) {\n  if (!opts) opts = {};\n  var r = {};\n  var files = [];\n  fltn(data, '', r, opts);\n  var o = 0;\n  var tot = 0;\n\n  for (var fn in r) {\n    var _a = r[fn],\n        file = _a[0],\n        p = _a[1];\n    var compression = p.level == 0 ? 0 : 8;\n    var f = strToU8(fn),\n        s = f.length;\n    var com = p.comment,\n        m = com && strToU8(com),\n        ms = m && m.length;\n    var exl = exfl(p.extra);\n    if (s > 65535) throw 'filename too long';\n    var d = compression ? deflateSync(file, p) : file,\n        l = d.length;\n    var c = crc();\n    c.p(file);\n    files.push(mrg(p, {\n      size: file.length,\n      crc: c.d(),\n      c: d,\n      f: f,\n      m: m,\n      u: s != fn.length || m && com.length != ms,\n      o: o,\n      compression: compression\n    }));\n    o += 30 + s + exl + l;\n    tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n  }\n\n  var out = new u8(tot + 22),\n      oe = o,\n      cdl = tot - o;\n\n  for (var i = 0; i < files.length; ++i) {\n    var f = files[i];\n    wzh(out, f.o, f, f.f, f.u, f.c.length);\n    var badd = 30 + f.f.length + exfl(f.extra);\n    out.set(f.c, f.o + badd);\n    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n  }\n\n  wzf(out, o, files.length, cdl, oe);\n  return out;\n}\n\nclass USDZExporter {\n  parse(scene) {\n    return _asyncToGenerator(function* () {\n      const files = {};\n      const modelFileName = 'model.usda'; // model file should be first in USDZ archive so we init it here\n\n      files[modelFileName] = null;\n      let output = buildHeader();\n      const materials = {};\n      const textures = {};\n      scene.traverseVisible(object => {\n        if (object.isMesh && object.material.isMeshStandardMaterial) {\n          const geometry = object.geometry;\n          const material = object.material;\n          const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd';\n\n          if (!(geometryFileName in files)) {\n            const meshObject = buildMeshObject(geometry);\n            files[geometryFileName] = buildUSDFileAsString(meshObject);\n          }\n\n          if (!(material.uuid in materials)) {\n            materials[material.uuid] = material;\n          }\n\n          output += buildXform(object, geometry, material);\n        }\n      });\n      output += buildMaterials(materials, textures);\n      files[modelFileName] = strToU8(output);\n      output = null;\n\n      for (const id in textures) {\n        const texture = textures[id];\n        const color = id.split('_')[1];\n        const isRGBA = texture.format === 1023;\n        const canvas = imageToCanvas(texture.image, color);\n        const blob = yield new Promise(resolve => canvas.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1));\n        files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(yield blob.arrayBuffer());\n      } // 64 byte alignment\n      // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n      let offset = 0;\n\n      for (const filename in files) {\n        const file = files[filename];\n        const headerSize = 34 + filename.length;\n        offset += headerSize;\n        const offsetMod64 = offset & 63;\n\n        if (offsetMod64 !== 4) {\n          const padLength = 64 - offsetMod64;\n          const padding = new Uint8Array(padLength);\n          files[filename] = [file, {\n            extra: {\n              12345: padding\n            }\n          }];\n        }\n\n        offset = file.length;\n      }\n\n      return zipSync(files, {\n        level: 0\n      });\n    })();\n  }\n\n}\n\nfunction imageToCanvas(image, color) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = 1024 / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n    if (color !== undefined) {\n      const hex = parseInt(color, 16);\n      const r = (hex >> 16 & 255) / 255;\n      const g = (hex >> 8 & 255) / 255;\n      const b = (hex & 255) / 255;\n      const imagedata = context.getImageData(0, 0, canvas.width, canvas.height);\n      const data = imagedata.data;\n\n      for (let i = 0; i < data.length; i += 4) {\n        data[i + 0] = data[i + 0] * r;\n        data[i + 1] = data[i + 1] * g;\n        data[i + 2] = data[i + 2] * b;\n      }\n\n      context.putImageData(imagedata, 0, 0);\n    }\n\n    return canvas;\n  }\n} //\n\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n  return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n}\n\nfunction buildUSDFileAsString(dataToInsert) {\n  let output = buildHeader();\n  output += dataToInsert;\n  return strToU8(output);\n} // Xform\n\n\nfunction buildXform(object, geometry, material) {\n  const name = 'Object_' + object.id;\n  const transform = buildMatrix(object.matrixWorld);\n\n  if (object.matrixWorld.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n  }\n\n  return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    rel material:binding = </Materials/Material_${material.id}>\n}\n\n`;\n}\n\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\n\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n} // Mesh\n\n\nfunction buildMeshObject(geometry) {\n  const mesh = buildMesh(geometry);\n  return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`;\n}\n\nfunction buildMesh(geometry) {\n  const name = 'Geometry';\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n  return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n}\n\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\n\nfunction buildMeshVertexIndices(geometry) {\n  if (geometry.index !== null) {\n    return geometry.index.array.join(', ');\n  }\n\n  const array = [];\n  const length = geometry.attributes.position.count;\n\n  for (let i = 0; i < length; i++) {\n    array.push(i);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 3) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${data[i + 1].toPrecision(PRECISION)}, ${data[i + 2].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector2Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: UVs missing.');\n    return Array(count).fill('(0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 2) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${1 - data[i + 1].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n} // Materials\n\n\nfunction buildMaterials(materials, textures) {\n  const array = [];\n\n  for (const uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material, textures));\n  }\n\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildMaterial(material, textures) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n  const pad = '            ';\n  const inputs = [];\n  const samplers = [];\n\n  function buildTexture(texture, mapType, color) {\n    const id = texture.id + (color ? '_' + color.getHexString() : '');\n    const isRGBA = texture.format === 1023;\n    textures[id] = texture;\n    return `\n        def Shader \"Transform2d_${mapType}\" (\n            sdrMetadata = {\n                string role = \"math\"\n            }\n        )\n        {\n            uniform token info:id = \"UsdTransform2d\"\n            float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${buildVector2(texture.repeat)}\n            float2 inputs:translation = ${buildVector2(texture.offset)}\n            float2 outputs:result\n        }\n\n        def Shader \"Texture_${texture.id}_${mapType}\"\n        {\n            uniform token info:id = \"UsdUVTexture\"\n            asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n            float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n            token inputs:wrapS = \"repeat\"\n            token inputs:wrapT = \"repeat\"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`;\n  }\n\n  if (material.map !== null) {\n    inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n    samplers.push(buildTexture(material.map, 'diffuse', material.color));\n  } else {\n    inputs.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n\n  if (material.emissiveMap !== null) {\n    inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n    samplers.push(buildTexture(material.emissiveMap, 'emissive'));\n  } else if (material.emissive.getHex() > 0) {\n    inputs.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n\n  if (material.normalMap !== null) {\n    inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n    samplers.push(buildTexture(material.normalMap, 'normal'));\n  }\n\n  if (material.aoMap !== null) {\n    inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n    samplers.push(buildTexture(material.aoMap, 'occlusion'));\n  }\n\n  if (material.roughnessMap !== null && material.roughness === 1) {\n    inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n    samplers.push(buildTexture(material.roughnessMap, 'roughness'));\n  } else {\n    inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n\n  if (material.metalnessMap !== null && material.metalness === 1) {\n    inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n    samplers.push(buildTexture(material.metalnessMap, 'metallic'));\n  } else {\n    inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n\n  inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n\n  if (material.isMeshPhysicalMaterial) {\n    inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n    inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n    inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n  }\n\n  return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${samplers.join('\\n')}\n\n    }\n`;\n}\n\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\n\nfunction buildVector2(vector) {\n  return `(${vector.x}, ${vector.y})`;\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * For our purposes, an enumeration is a fixed set of CSS-expression-compatible\n * names. When serialized, a selected subset of the members may be specified as\n * whitespace-separated strings. An enumeration deserializer is a function that\n * parses a serialized subset of an enumeration and returns any members that are\n * found as a Set.\n *\n * The following example will produce a deserializer for the days of the\n * week:\n *\n * const deserializeDaysOfTheWeek = enumerationDeserializer([\n *   'Monday',\n *   'Tuesday',\n *   'Wednesday',\n *   'Thursday',\n *   'Friday',\n *   'Saturday',\n *   'Sunday'\n * ]);\n */\n\n\nconst enumerationDeserializer = allowedNames => valueString => {\n  try {\n    const expressions = parseExpressions(valueString);\n    const names = (expressions.length ? expressions[0].terms : []).filter(valueNode => valueNode && valueNode.type === 'ident').map(valueNode => valueNode.value).filter(name => allowedNames.indexOf(name) > -1); // NOTE(cdata): IE11 does not support constructing a Set directly from\n    // an iterable, so we need to manually add all the items:\n\n    const result = new Set();\n\n    for (const name of names) {\n      result.add(name);\n    }\n\n    return result;\n  } catch (_error) {}\n\n  return new Set();\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nlet isWebXRBlocked = false;\nlet isSceneViewerBlocked = false;\nconst noArViewerSigil = '#model-viewer-no-ar-fallback';\nconst deserializeARModes = enumerationDeserializer(['quick-look', 'scene-viewer', 'webxr', 'none']);\nconst DEFAULT_AR_MODES = 'webxr scene-viewer';\nconst ARMode = {\n  QUICK_LOOK: 'quick-look',\n  SCENE_VIEWER: 'scene-viewer',\n  WEBXR: 'webxr',\n  NONE: 'none'\n};\nconst $arButtonContainer = Symbol('arButtonContainer');\nconst $enterARWithWebXR = Symbol('enterARWithWebXR');\nconst $openSceneViewer = Symbol('openSceneViewer');\nconst $openIOSARQuickLook = Symbol('openIOSARQuickLook');\nconst $canActivateAR = Symbol('canActivateAR');\nconst $arMode = Symbol('arMode');\nconst $arModes = Symbol('arModes');\nconst $arAnchor = Symbol('arAnchor');\nconst $preload = Symbol('preload');\nconst $onARButtonContainerClick = Symbol('onARButtonContainerClick');\nconst $onARStatus = Symbol('onARStatus');\nconst $onARTracking = Symbol('onARTracking');\nconst $onARTap = Symbol('onARTap');\nconst $selectARMode = Symbol('selectARMode');\nconst $triggerLoad = Symbol('triggerLoad');\n\nconst ARMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  class ARModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.ar = false;\n      this.arScale = 'auto';\n      this.arPlacement = 'floor';\n      this.arModes = DEFAULT_AR_MODES;\n      this.iosSrc = null;\n      this.xrEnvironment = false;\n      this[_a] = false; // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n\n      this[_b] = this.shadowRoot.querySelector('.ar-button');\n      this[_c] = document.createElement('a');\n      this[_d] = new Set();\n      this[_e] = ARMode.NONE;\n      this[_f] = false;\n\n      this[_g] = event => {\n        event.preventDefault();\n        this.activateAR();\n      };\n\n      this[_h] = ({\n        status\n      }) => {\n        if (status === ARStatus.NOT_PRESENTING || this[$renderer].arRenderer.presentedScene === this[$scene]) {\n          this.setAttribute('ar-status', status);\n          this.dispatchEvent(new CustomEvent('ar-status', {\n            detail: {\n              status\n            }\n          }));\n\n          if (status === ARStatus.NOT_PRESENTING) {\n            this.removeAttribute('ar-tracking');\n          } else if (status === ARStatus.SESSION_STARTED) {\n            this.setAttribute('ar-tracking', ARTracking.TRACKING);\n          }\n        }\n      };\n\n      this[_j] = ({\n        status\n      }) => {\n        this.setAttribute('ar-tracking', status);\n        this.dispatchEvent(new CustomEvent('ar-tracking', {\n          detail: {\n            status\n          }\n        }));\n      };\n\n      this[_k] = event => {\n        if (event.data == '_apple_ar_quicklook_button_tapped') {\n          this.dispatchEvent(new CustomEvent('quick-look-button-tapped'));\n        }\n      };\n    }\n\n    get canActivateAR() {\n      return this[$arMode] !== ARMode.NONE;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this[$renderer].arRenderer.addEventListener('status', this[$onARStatus]);\n      this.setAttribute('ar-status', ARStatus.NOT_PRESENTING);\n      this[$renderer].arRenderer.addEventListener('tracking', this[$onARTracking]);\n      this[$arAnchor].addEventListener('message', this[$onARTap]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$renderer].arRenderer.removeEventListener('status', this[$onARStatus]);\n      this[$renderer].arRenderer.removeEventListener('tracking', this[$onARTracking]);\n      this[$arAnchor].removeEventListener('message', this[$onARTap]);\n    }\n\n    update(changedProperties) {\n      var _superprop_getUpdate = () => super.update,\n          _this21 = this;\n\n      return _asyncToGenerator(function* () {\n        _superprop_getUpdate().call(_this21, changedProperties);\n\n        if (changedProperties.has('arScale')) {\n          _this21[$scene].canScale = _this21.arScale !== 'fixed';\n        }\n\n        if (changedProperties.has('arPlacement')) {\n          _this21[$scene].setShadowIntensity(_this21[$scene].shadowIntensity);\n\n          _this21[$needsRender]();\n        }\n\n        if (!changedProperties.has('ar') && !changedProperties.has('arModes') && !changedProperties.has('iosSrc')) {\n          return;\n        }\n\n        if (changedProperties.has('arModes')) {\n          _this21[$arModes] = deserializeARModes(_this21.arModes);\n        }\n\n        _this21[$selectARMode]();\n      })();\n    }\n    /**\n     * Activates AR. Note that for any mode that is not WebXR-based, this\n     * method most likely has to be called synchronous from a user\n     * interaction handler. Otherwise, attempts to activate modes that\n     * require user interaction will most likely be ignored.\n     */\n\n\n    activateAR() {\n      var _this22 = this;\n\n      return _asyncToGenerator(function* () {\n        switch (_this22[$arMode]) {\n          case ARMode.QUICK_LOOK:\n            _this22[$openIOSARQuickLook]();\n\n            break;\n\n          case ARMode.WEBXR:\n            yield _this22[$enterARWithWebXR]();\n            break;\n\n          case ARMode.SCENE_VIEWER:\n            _this22[$openSceneViewer]();\n\n            break;\n\n          default:\n            console.warn('No AR Mode can be activated. This is probably due to missing \\\nconfiguration or device capabilities');\n            break;\n        }\n      })();\n    }\n\n    [(_a = $canActivateAR, _b = $arButtonContainer, _c = $arAnchor, _d = $arModes, _e = $arMode, _f = $preload, _g = $onARButtonContainerClick, _h = $onARStatus, _j = $onARTracking, _k = $onARTap, $selectARMode)]() {\n      var _this23 = this;\n\n      return _asyncToGenerator(function* () {\n        _this23[$arMode] = ARMode.NONE;\n\n        if (_this23.ar) {\n          if (_this23.src != null) {\n            for (const value of _this23[$arModes]) {\n              if (value === 'webxr' && IS_WEBXR_AR_CANDIDATE && !isWebXRBlocked && (yield _this23[$renderer].arRenderer.supportsPresentation())) {\n                _this23[$arMode] = ARMode.WEBXR;\n                break;\n              }\n\n              if (value === 'scene-viewer' && IS_SCENEVIEWER_CANDIDATE && !isSceneViewerBlocked) {\n                _this23[$arMode] = ARMode.SCENE_VIEWER;\n                break;\n              }\n\n              if (value === 'quick-look' && IS_AR_QUICKLOOK_CANDIDATE) {\n                _this23[$arMode] = ARMode.QUICK_LOOK;\n                break;\n              }\n            }\n          } // The presence of ios-src overrides the absence of quick-look\n          // ar-mode.\n\n\n          if (!_this23.canActivateAR && _this23.iosSrc != null && IS_AR_QUICKLOOK_CANDIDATE) {\n            _this23[$arMode] = ARMode.QUICK_LOOK;\n          }\n        }\n\n        if (_this23.canActivateAR) {\n          _this23[$arButtonContainer].classList.add('enabled');\n\n          _this23[$arButtonContainer].addEventListener('click', _this23[$onARButtonContainerClick]);\n        } else if (_this23[$arButtonContainer].classList.contains('enabled')) {\n          _this23[$arButtonContainer].removeEventListener('click', _this23[$onARButtonContainerClick]);\n\n          _this23[$arButtonContainer].classList.remove('enabled'); // If AR went from working to not, notify the element.\n\n\n          const status = ARStatus.FAILED;\n\n          _this23.setAttribute('ar-status', status);\n\n          _this23.dispatchEvent(new CustomEvent('ar-status', {\n            detail: {\n              status\n            }\n          }));\n        }\n      })();\n    }\n\n    [$enterARWithWebXR]() {\n      var _this24 = this;\n\n      return _asyncToGenerator(function* () {\n        console.log('Attempting to present in AR with WebXR...');\n        yield _this24[$triggerLoad]();\n\n        try {\n          _this24[$arButtonContainer].removeEventListener('click', _this24[$onARButtonContainerClick]);\n\n          const {\n            arRenderer\n          } = _this24[$renderer];\n          arRenderer.placeOnWall = _this24.arPlacement === 'wall';\n          yield arRenderer.present(_this24[$scene], _this24.xrEnvironment);\n        } catch (error) {\n          console.warn('Error while trying to present in AR with WebXR');\n          console.error(error);\n          yield _this24[$renderer].arRenderer.stopPresenting();\n          isWebXRBlocked = true;\n          console.warn('Falling back to next ar-mode');\n          yield _this24[$selectARMode]();\n\n          _this24.activateAR();\n        } finally {\n          _this24[$selectARMode]();\n        }\n      })();\n    }\n\n    [$triggerLoad]() {\n      var _this25 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this25.loaded) {\n          _this25[$preload] = true;\n\n          _this25[$updateSource]();\n\n          yield waitForEvent(_this25, 'load');\n          _this25[$preload] = false;\n        }\n      })();\n    }\n\n    [$shouldAttemptPreload]() {\n      return super[$shouldAttemptPreload]() || this[$preload];\n    }\n    /**\n     * Takes a URL and a title string, and attempts to launch Scene Viewer on\n     * the current device.\n     */\n\n\n    [$openSceneViewer]() {\n      const location = self.location.toString();\n      const locationUrl = new URL(location);\n      const modelUrl = new URL(this.src, location);\n      const params = new URLSearchParams(modelUrl.search);\n      locationUrl.hash = noArViewerSigil; // modelUrl can contain title/link/sound etc.\n\n      params.set('mode', 'ar_preferred');\n\n      if (!params.has('disable_occlusion')) {\n        params.set('disable_occlusion', 'true');\n      }\n\n      if (this.arScale === 'fixed') {\n        params.set('resizable', 'false');\n      }\n\n      if (this.arPlacement === 'wall') {\n        params.set('enable_vertical_placement', 'true');\n      }\n\n      if (params.has('sound')) {\n        const soundUrl = new URL(params.get('sound'), location);\n        params.set('sound', soundUrl.toString());\n      }\n\n      if (params.has('link')) {\n        const linkUrl = new URL(params.get('link'), location);\n        params.set('link', linkUrl.toString());\n      }\n\n      const intent = `intent://arvr.google.com/scene-viewer/1.0?${params.toString() + '&file=' + encodeURIComponent(modelUrl.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(locationUrl.toString())};end;`;\n\n      const undoHashChange = () => {\n        if (self.location.hash === noArViewerSigil) {\n          isSceneViewerBlocked = true; // The new history will be the current URL with a new hash.\n          // Go back one step so that we reset to the expected URL.\n          // NOTE(cdata): this should not invoke any browser-level navigation\n          // because hash-only changes modify the URL in-place without\n          // navigating:\n\n          self.history.back();\n          console.warn('Error while trying to present in AR with Scene Viewer');\n          console.warn('Falling back to next ar-mode');\n          this[$selectARMode](); // Would be nice to activateAR() here, but webXR fails due to not\n          // seeing a user activation.\n        }\n      };\n\n      self.addEventListener('hashchange', undoHashChange, {\n        once: true\n      });\n      this[$arAnchor].setAttribute('href', intent);\n      console.log('Attempting to present in AR with Scene Viewer...');\n      this[$arAnchor].click();\n    }\n    /**\n     * Takes a URL to a USDZ file and sets the appropriate fields so that\n     * Safari iOS can intent to their AR Quick Look.\n     */\n\n\n    [$openIOSARQuickLook]() {\n      var _this26 = this;\n\n      return _asyncToGenerator(function* () {\n        const generateUsdz = !_this26.iosSrc;\n\n        _this26[$arButtonContainer].classList.remove('enabled');\n\n        const objectURL = generateUsdz ? yield _this26.prepareUSDZ() : _this26.iosSrc;\n        const modelUrl = new URL(objectURL, self.location.toString());\n\n        if (_this26.arScale === 'fixed') {\n          if (modelUrl.hash) {\n            modelUrl.hash += '&';\n          }\n\n          modelUrl.hash += 'allowsContentScaling=0';\n        }\n\n        const anchor = _this26[$arAnchor];\n        anchor.setAttribute('rel', 'ar');\n        const img = document.createElement('img');\n        anchor.appendChild(img);\n        anchor.setAttribute('href', modelUrl.toString());\n\n        if (generateUsdz) {\n          anchor.setAttribute('download', 'model.usdz');\n        }\n\n        console.log('Attempting to present in AR with Quick Look...');\n        anchor.click();\n        anchor.removeChild(img);\n\n        if (generateUsdz) {\n          URL.revokeObjectURL(objectURL);\n        }\n\n        _this26[$arButtonContainer].classList.add('enabled');\n      })();\n    }\n\n    prepareUSDZ() {\n      var _this27 = this;\n\n      return _asyncToGenerator(function* () {\n        const updateSourceProgress = _this27[$progressTracker].beginActivity();\n\n        yield _this27[$triggerLoad]();\n        const scene = _this27[$scene];\n        const shadow = scene.shadow;\n        let visible = false; // Remove shadow from export\n\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n\n        updateSourceProgress(0.2);\n        const exporter = new USDZExporter();\n        const arraybuffer = yield exporter.parse(scene.modelContainer);\n        const blob = new Blob([arraybuffer], {\n          type: 'model/vnd.usdz+zip'\n        });\n        const url = URL.createObjectURL(blob);\n        updateSourceProgress(1);\n\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n\n        return url;\n      })();\n    }\n\n  }\n\n  __decorate$4([property({\n    type: Boolean,\n    attribute: 'ar'\n  })], ARModelViewerElement.prototype, \"ar\", void 0);\n\n  __decorate$4([property({\n    type: String,\n    attribute: 'ar-scale'\n  })], ARModelViewerElement.prototype, \"arScale\", void 0);\n\n  __decorate$4([property({\n    type: String,\n    attribute: 'ar-placement'\n  })], ARModelViewerElement.prototype, \"arPlacement\", void 0);\n\n  __decorate$4([property({\n    type: String,\n    attribute: 'ar-modes'\n  })], ARModelViewerElement.prototype, \"arModes\", void 0);\n\n  __decorate$4([property({\n    type: String,\n    attribute: 'ios-src'\n  })], ARModelViewerElement.prototype, \"iosSrc\", void 0);\n\n  __decorate$4([property({\n    type: Boolean,\n    attribute: 'xr-environment'\n  })], ARModelViewerElement.prototype, \"xrEnvironment\", void 0);\n\n  return ARModelViewerElement;\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a$4, _b$2, _c$1;\n\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\n\nclass Evaluator {\n  constructor() {\n    this[_a$4] = null;\n  }\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n\n\n  static evaluatableFor(node, basis = ZERO) {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node, basis);\n      }\n\n      return node;\n    }\n\n    switch (node.name.value) {\n      case 'calc':\n        return new CalcEvaluator(node, basis);\n\n      case 'env':\n        return new EnvEvaluator(node);\n    }\n\n    return ZERO;\n  }\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n\n\n  static evaluate(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n\n    return evaluatable;\n  }\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n\n\n  static isConstant(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n\n    return true;\n  }\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n\n\n  static applyIntrinsics(evaluated, intrinsics) {\n    const {\n      basis,\n      keywords\n    } = intrinsics;\n    const {\n      auto\n    } = keywords;\n    return basis.map((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index]; // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n\n      let evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode; // Any ident node is considered a keyword:\n\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value; // Substitute any keywords for concrete values first:\n\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      } // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n\n\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      } // For percentages, we always apply the percentage to the basis value:\n\n\n      if (evaluatedNode.unit === '%') {\n        return numberNode(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      } // Otherwise, normalize whatever we have:\n\n\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode); // If the normalized units do not match, return the basis as a fallback:\n\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      } // Finally, return the evaluated node with intrinsics applied:\n\n\n      return evaluatedNode;\n    });\n  }\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n\n\n  get isConstant() {\n    return false;\n  }\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n\n\n  evaluate() {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n\n    return this[$lastValue];\n  }\n\n}\n\n_a$4 = $lastValue;\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\n\nclass PercentageEvaluator extends Evaluator {\n  constructor(percentage, basis) {\n    super();\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n\n  get isConstant() {\n    return true;\n  }\n\n  [$evaluate]() {\n    return numberNode(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);\n  }\n\n}\n\nconst $identNode = Symbol('identNode');\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\n\nclass EnvEvaluator extends Evaluator {\n  constructor(envFunction) {\n    super();\n    this[_b$2] = null;\n    const identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n\n  get isConstant() {\n    return false;\n  }\n\n  [(_b$2 = $identNode, $evaluate)]() {\n    if (this[$identNode] != null) {\n      switch (this[$identNode].value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition / (verticalScrollMax - window.innerHeight) || 0;\n          return {\n            type: 'number',\n            number: scrollY,\n            unit: null\n          };\n      }\n    }\n\n    return ZERO;\n  }\n\n}\n\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evalutor');\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\n\nclass CalcEvaluator extends Evaluator {\n  constructor(calcFunction, basis = ZERO) {\n    super();\n    this[_c$1] = null;\n\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n\n    const terms = calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms = [];\n\n    while (terms.length) {\n      const term = terms.shift();\n\n      if (secondOrderTerms.length > 0) {\n        const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];\n\n        if (previousTerm.type === 'operator' && IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop();\n          const leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return;\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n\n      if (operator.type !== 'operator') {\n        return;\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));\n    } // There should only be one combined evaluator at this point:\n\n\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0];\n    }\n  }\n\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);\n  }\n\n  [(_c$1 = $evaluator, $evaluate)]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) : ZERO;\n  }\n\n}\n\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\n\nclass OperatorEvaluator extends Evaluator {\n  constructor(operator, left, right) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right]);\n  }\n\n  [$evaluate]() {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {\n      number: leftValue,\n      unit: leftUnit\n    } = leftNode;\n    const {\n      number: rightValue,\n      unit: rightUnit\n    } = rightNode; // Disallow operations for mismatched normalized units e.g., m and rad:\n\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    } // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n\n\n    const unit = leftUnit || rightUnit;\n    let value;\n\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n\n      case '-':\n        value = leftValue - rightValue;\n        break;\n\n      case '/':\n        value = leftValue / rightValue;\n        break;\n\n      case '*':\n        value = leftValue * rightValue;\n        break;\n\n      default:\n        return ZERO;\n    }\n\n    return {\n      type: 'number',\n      number: value,\n      unit\n    };\n  }\n\n}\n\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\n\nclass StyleEvaluator extends Evaluator {\n  constructor(expressions, intrinsics) {\n    super();\n    this[$intrinsics] = intrinsics;\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n    this[$evaluatables] = intrinsics.basis.map((basisNode, index) => {\n      const term = terms[index];\n\n      if (term == null) {\n        return {\n          type: 'ident',\n          value: 'auto'\n        };\n      }\n\n      if (term.type === 'ident') {\n        return term;\n      }\n\n      return Evaluator.evaluatableFor(term, basisNode);\n    });\n  }\n\n  get isConstant() {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map(evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(numberNode => numberNode.number);\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a$3, _b$1, _c, _d;\n\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance anlyses) as well as potential memory leaks.\n */\n\nclass ScrollObserver {\n  constructor(callback) {\n    this[$scrollCallback] = callback;\n  }\n\n  static [$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n\n  static [(_a$3 = $instances, $activateListener)]() {\n    window.addEventListener('scroll', this[$notifyInstances], {\n      passive: true\n    });\n  }\n\n  static [$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n\n\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n\n    ScrollObserver[$instances].add(this);\n  }\n  /**\n   * Stop listening for scroll events.\n   */\n\n\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n\n  [$notify]() {\n    this[$scrollCallback]();\n  }\n\n}\n\nScrollObserver[_a$3] = new Set();\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\nconst $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\n\nclass StyleEffector {\n  constructor(callback) {\n    this[_b$1] = {};\n    this[_c] = new ASTWalker(['function']);\n\n    this[_d] = () => {\n      this[$computeStyleCallback]({\n        relatedState: 'window-scroll'\n      });\n    };\n\n    this[$computeStyleCallback] = callback;\n  }\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n\n\n  observeEffectsFor(ast) {\n    const newDependencies = {};\n    const oldDependencies = this[$dependencies];\n    this[$astWalker].walk(ast, functionNode => {\n      const {\n        name\n      } = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n\n      if (name.value !== 'env' || firstTerm == null || firstTerm.type !== 'ident') {\n        return;\n      }\n\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ? oldDependencies['window-scroll'] : new ScrollObserver(this[$onScroll]);\n            observer.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n\n          break;\n      }\n    });\n\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState];\n      observer.disconnect();\n    }\n\n    this[$dependencies] = newDependencies;\n  }\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n\n\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer = this[$dependencies][environmentState];\n      observer.disconnect();\n    }\n  }\n\n}\n\n_b$1 = $dependencies, _c = $astWalker, _d = $onScroll;\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\n\nconst style = config => {\n  const observeEffects = config.observeEffects || false;\n  const getIntrinsics = config.intrinsics instanceof Function ? config.intrinsics : () => config.intrinsics;\n  return (proto, propertyName) => {\n    const originalUpdated = proto.updated;\n    const originalConnectedCallback = proto.connectedCallback;\n    const originalDisconnectedCallback = proto.disconnectedCallback;\n    const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n    const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n    const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n    const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n    Object.defineProperties(proto, {\n      [$styleEffector]: {\n        value: null,\n        writable: true\n      },\n      [$styleEvaluator]: {\n        value: null,\n        writable: true\n      },\n      [$updateEvaluator]: {\n        value: function () {\n          const ast = parseExpressions(this[propertyName]);\n          this[$styleEvaluator] = new StyleEvaluator(ast, getIntrinsics(this));\n\n          if (this[$styleEffector] == null && observeEffects) {\n            this[$styleEffector] = new StyleEffector(() => this[$evaluateAndSync]());\n          }\n\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].observeEffectsFor(ast);\n          }\n        }\n      },\n      [$evaluateAndSync]: {\n        value: function () {\n          if (this[$styleEvaluator] == null) {\n            return;\n          }\n\n          const result = this[$styleEvaluator].evaluate(); // @see https://github.com/microsoft/TypeScript/pull/30769\n          // @see https://github.com/Microsoft/TypeScript/issues/1863\n\n          this[config.updateHandler](result);\n        }\n      },\n      updated: {\n        value: function (changedProperties) {\n          // Always invoke updates to styles first. This gives a class that\n          // uses this decorator the opportunity to override the effect, or\n          // respond to it, in its own implementation of `updated`.\n          if (changedProperties.has(propertyName)) {\n            this[$updateEvaluator]();\n            this[$evaluateAndSync]();\n          }\n\n          originalUpdated.call(this, changedProperties);\n        }\n      },\n      connectedCallback: {\n        value: function () {\n          originalConnectedCallback.call(this);\n          this.requestUpdate(propertyName, this[propertyName]);\n        }\n      },\n      disconnectedCallback: {\n        value: function () {\n          originalDisconnectedCallback.call(this);\n\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].dispose();\n            this[$styleEffector] = null;\n          }\n        }\n      }\n    });\n  };\n};\n/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  interactionPolicy: 'always-allow',\n  touchAction: 'pan-y'\n}); // Constants\n\nconst TOUCH_EVENT_RE = /^touch(start|end|move)$/;\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\nconst KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nconst ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\n\nclass SmoothControls extends EventDispatcher {\n  constructor(camera, element) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this.sensitivity = 1;\n    this._interactionEnabled = false;\n    this._disableZoom = false;\n    this.isUserChange = false;\n    this.isUserPointing = false; // Internal orbital position state\n\n    this.spherical = new Spherical();\n    this.goalSpherical = new Spherical();\n    this.thetaDamper = new Damper();\n    this.phiDamper = new Damper();\n    this.radiusDamper = new Damper();\n    this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);\n    this.goalLogFov = this.logFov;\n    this.fovDamper = new Damper(); // Pointer state\n\n    this.pointerIsDown = false;\n    this.lastPointerPosition = {\n      clientX: 0,\n      clientY: 0\n    };\n    this.touchMode = 'rotate';\n    this.touchDecided = false;\n\n    this.onPointerMove = event => {\n      if (!this.pointerIsDown || !this.canInteract) {\n        return;\n      } // NOTE(cdata): We test event.type as some browsers do not have a global\n      // TouchEvent contructor.\n\n\n      if (TOUCH_EVENT_RE.test(event.type)) {\n        const {\n          touches\n        } = event;\n\n        switch (this.touchMode) {\n          case 'zoom':\n            if (this.lastTouches.length > 1 && touches.length > 1) {\n              const lastTouchDistance = this.twoTouchDistance(this.lastTouches[0], this.lastTouches[1]);\n              const touchDistance = this.twoTouchDistance(touches[0], touches[1]);\n              const deltaZoom = ZOOM_SENSITIVITY * (lastTouchDistance - touchDistance) / 10.0;\n              this.userAdjustOrbit(0, 0, deltaZoom);\n            }\n\n            break;\n\n          case 'rotate':\n            const {\n              touchAction\n            } = this._options;\n\n            if (!this.touchDecided && touchAction !== 'none') {\n              this.touchDecided = true;\n              const {\n                clientX,\n                clientY\n              } = touches[0];\n              const dx = Math.abs(clientX - this.lastPointerPosition.clientX);\n              const dy = Math.abs(clientY - this.lastPointerPosition.clientY); // If motion is mostly vertical, assume scrolling is the intent.\n\n              if (touchAction === 'pan-y' && dy > dx || touchAction === 'pan-x' && dx > dy) {\n                this.touchMode = 'scroll';\n                return;\n              }\n            }\n\n            this.handleSinglePointerMove(touches[0]);\n            break;\n\n          case 'scroll':\n            return;\n        }\n\n        this.lastTouches = touches;\n      } else {\n        this.handleSinglePointerMove(event);\n      }\n\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    this.onPointerDown = event => {\n      this.pointerIsDown = true;\n      this.isUserPointing = false;\n\n      if (TOUCH_EVENT_RE.test(event.type)) {\n        const {\n          touches\n        } = event;\n        this.touchDecided = false;\n\n        switch (touches.length) {\n          default:\n          case 1:\n            this.touchMode = 'rotate';\n            this.handleSinglePointerDown(touches[0]);\n            break;\n\n          case 2:\n            this.touchMode = this._disableZoom ? 'scroll' : 'zoom';\n            break;\n        }\n\n        this.lastTouches = touches;\n      } else {\n        this.handleSinglePointerDown(event);\n      }\n    };\n\n    this.onPointerUp = _event => {\n      this.element.style.cursor = 'grab';\n      this.pointerIsDown = false;\n\n      if (this.isUserPointing) {\n        this.dispatchEvent({\n          type: 'pointer-change-end',\n          pointer: Object.assign({}, this.lastPointerPosition)\n        });\n      }\n    };\n\n    this.onWheel = event => {\n      if (!this.canInteract) {\n        return;\n      }\n\n      const deltaZoom = event.deltaY * (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY / 30;\n      this.userAdjustOrbit(0, 0, deltaZoom);\n\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    this.onKeyDown = event => {\n      // We track if the key is actually one we respond to, so as not to\n      // accidentally clober unrelated key inputs when the <model-viewer> has\n      // focus.\n      let relevantKey = false;\n\n      switch (event.keyCode) {\n        case KeyCode.PAGE_UP:\n          relevantKey = true;\n          this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY);\n          break;\n\n        case KeyCode.PAGE_DOWN:\n          relevantKey = true;\n          this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY);\n          break;\n\n        case KeyCode.UP:\n          relevantKey = true;\n          this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n          break;\n\n        case KeyCode.DOWN:\n          relevantKey = true;\n          this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n          break;\n\n        case KeyCode.LEFT:\n          relevantKey = true;\n          this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n          break;\n\n        case KeyCode.RIGHT:\n          relevantKey = true;\n          this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n          break;\n      }\n\n      if (relevantKey && event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    this._options = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n\n  get interactionEnabled() {\n    return this._interactionEnabled;\n  }\n\n  enableInteraction() {\n    if (this._interactionEnabled === false) {\n      const {\n        element\n      } = this;\n      element.addEventListener('mousemove', this.onPointerMove);\n      element.addEventListener('mousedown', this.onPointerDown);\n\n      if (!this._disableZoom) {\n        element.addEventListener('wheel', this.onWheel);\n      }\n\n      element.addEventListener('keydown', this.onKeyDown);\n      element.addEventListener('touchstart', this.onPointerDown, {\n        passive: true\n      });\n      element.addEventListener('touchmove', this.onPointerMove);\n      self.addEventListener('mouseup', this.onPointerUp);\n      self.addEventListener('touchend', this.onPointerUp);\n      this.element.style.cursor = 'grab';\n      this._interactionEnabled = true;\n    }\n  }\n\n  disableInteraction() {\n    if (this._interactionEnabled === true) {\n      const {\n        element\n      } = this;\n      element.removeEventListener('mousemove', this.onPointerMove);\n      element.removeEventListener('mousedown', this.onPointerDown);\n\n      if (!this._disableZoom) {\n        element.removeEventListener('wheel', this.onWheel);\n      }\n\n      element.removeEventListener('keydown', this.onKeyDown);\n      element.removeEventListener('touchstart', this.onPointerDown);\n      element.removeEventListener('touchmove', this.onPointerMove);\n      self.removeEventListener('mouseup', this.onPointerUp);\n      self.removeEventListener('touchend', this.onPointerUp);\n      element.style.cursor = '';\n      this._interactionEnabled = false;\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n\n\n  get options() {\n    return this._options;\n  }\n\n  set disableZoom(disable) {\n    if (this._disableZoom != disable) {\n      this._disableZoom = disable;\n\n      if (disable === true) {\n        this.element.removeEventListener('wheel', this.onWheel);\n      } else {\n        this.element.addEventListener('wheel', this.onWheel);\n      }\n    }\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n\n\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this.spherical);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n\n\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the _options of the controls. Configured _options will be\n   * merged with whatever _options have already been configured for this\n   * controls instance.\n   */\n\n\n  applyOptions(_options) {\n    Object.assign(this._options, _options); // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this.goalLogFov));\n  }\n  /**\n   * Sets the near and far planes of the camera.\n   */\n\n\n  updateNearFar(nearPlane, farPlane) {\n    this.camera.near = Math.max(nearPlane, farPlane / 1000);\n    this.camera.far = farPlane;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Sets the aspect ratio of the camera\n   */\n\n\n  updateAspect(aspect) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening _options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n\n\n  setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this._options;\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n\n    if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n      this.spherical.theta = this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n    }\n\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n\n    this.goalSpherical.theta = nextTheta;\n    this.goalSpherical.phi = nextPhi;\n    this.goalSpherical.radius = nextRadius;\n    this.goalSpherical.makeSafe();\n    this.isUserChange = false;\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n\n\n  setRadius(radius) {\n    this.goalSpherical.radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n\n\n  setFieldOfView(fov) {\n    const {\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n    this.goalLogFov = Math.log(fov);\n  }\n  /**\n   * Sets the smoothing decay time.\n   */\n\n\n  setDamperDecayTime(decayMilliseconds) {\n    this.thetaDamper.setDecayTime(decayMilliseconds);\n    this.phiDamper.setDecayTime(decayMilliseconds);\n    this.radiusDamper.setDecayTime(decayMilliseconds);\n    this.fovDamper.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n\n\n  adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    const dTheta = this.spherical.theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n    const deltaRatio = deltaZoom === 0 ? 0 : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) / (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) - this.goalLogFov);\n    const goalRadius = radius + deltaZoom * Math.min(isFinite(deltaRatio) ? deltaRatio : Infinity, maximumRadius - minimumRadius);\n    this.setOrbit(goalTheta, goalPhi, goalRadius);\n\n    if (deltaZoom !== 0) {\n      const goalLogFov = this.goalLogFov + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n    }\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n\n\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n\n\n  update(_time, delta) {\n    if (this.isStationary()) {\n      return;\n    }\n\n    const {\n      maximumPolarAngle,\n      maximumRadius\n    } = this._options;\n    const dTheta = this.spherical.theta - this.goalSpherical.theta;\n\n    if (Math.abs(dTheta) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle)) {\n      this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n\n    this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);\n    this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);\n    this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);\n    this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n    this.moveCamera();\n  }\n\n  isStationary() {\n    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;\n  }\n\n  moveCamera() {\n    // Derive the new camera position from the updated spherical:\n    this.spherical.makeSafe();\n    this.camera.position.setFromSpherical(this.spherical);\n    this.camera.setRotationFromEuler(new Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));\n\n    if (this.camera.fov !== Math.exp(this.logFov)) {\n      this.camera.fov = Math.exp(this.logFov);\n      this.camera.updateProjectionMatrix();\n    }\n\n    const source = this.isUserChange ? ChangeSource.USER_INTERACTION : ChangeSource.NONE;\n    this.dispatchEvent({\n      type: 'change',\n      source\n    });\n  }\n\n  get canInteract() {\n    if (this._options.interactionPolicy == 'allow-when-focused') {\n      const rootNode = this.element.getRootNode();\n      return rootNode.activeElement === this.element;\n    }\n\n    return this._options.interactionPolicy === 'always-allow';\n  }\n\n  userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    this.adjustOrbit(deltaTheta * this.sensitivity, deltaPhi * this.sensitivity, deltaZoom);\n    this.isUserChange = true; // Always make sure that an initial event is triggered in case there is\n    // contention between user interaction and imperative changes. This initial\n    // event will give external observers that chance to observe that\n    // interaction occurred at all:\n\n    this.dispatchEvent({\n      type: 'change',\n      source: ChangeSource.USER_INTERACTION\n    });\n  } // Wraps to bewteen -pi and pi\n\n\n  wrapAngle(radians) {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n\n  pixelLengthToSphericalAngle(pixelLength) {\n    return 2 * Math.PI * pixelLength / this.element.clientHeight;\n  }\n\n  twoTouchDistance(touchOne, touchTwo) {\n    const {\n      clientX: xOne,\n      clientY: yOne\n    } = touchOne;\n    const {\n      clientX: xTwo,\n      clientY: yTwo\n    } = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n\n  handleSinglePointerMove(pointer) {\n    const {\n      clientX,\n      clientY\n    } = pointer;\n    const deltaTheta = this.pixelLengthToSphericalAngle(clientX - this.lastPointerPosition.clientX);\n    const deltaPhi = this.pixelLengthToSphericalAngle(clientY - this.lastPointerPosition.clientY);\n    this.lastPointerPosition.clientX = clientX;\n    this.lastPointerPosition.clientY = clientY;\n\n    if (this.isUserPointing === false) {\n      this.isUserPointing = true;\n      this.dispatchEvent({\n        type: 'pointer-change-start',\n        pointer: Object.assign({}, pointer)\n      });\n    }\n\n    this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n  }\n\n  handleSinglePointerDown(pointer) {\n    this.lastPointerPosition.clientX = pointer.clientX;\n    this.lastPointerPosition.clientY = pointer.clientY;\n    this.element.style.cursor = 'grabbing';\n  }\n\n}\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Adapted from https://gist.github.com/gre/1650294\n\n\nconst easeInOutQuad = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\n\n\nconst interpolate = (start, end, ease = easeInOutQuad) => time => start + (end - start) * ease(time);\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\n\n\nconst sequence = (tracks, weights) => {\n  const totalWeight = weights.reduce((total, weight) => total + weight, 0);\n  const ratios = weights.map(weight => weight / totalWeight);\n  return time => {\n    let start = 0;\n    let ratio = Infinity;\n\n    let track = () => 0;\n\n    for (let i = 0; i < ratios.length; ++i) {\n      ratio = ratios[i];\n      track = tracks[i];\n\n      if (time <= start + ratio) {\n        break;\n      }\n\n      start += ratio;\n    }\n\n    return track((time - start) / ratio);\n  };\n};\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\n\n\nconst timeline = (initialValue, keyframes) => {\n  const tracks = [];\n  const weights = [];\n  let lastValue = initialValue;\n\n  for (let i = 0; i < keyframes.length; ++i) {\n    const keyframe = keyframes[i];\n    const {\n      value,\n      frames\n    } = keyframe;\n    const ease = keyframe.ease || easeInOutQuad;\n    const track = interpolate(lastValue, value, ease);\n    tracks.push(track);\n    weights.push(frames);\n    lastValue = value;\n  }\n\n  return sequence(tracks, weights);\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}; // NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/google/model-viewer/issues/839\n\n\nconst PROMPT_ANIMATION_TIME = 5000; // For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the keyframe.\n\nconst wiggle = timeline(0, [{\n  frames: 5,\n  value: -1\n}, {\n  frames: 1,\n  value: -1\n}, {\n  frames: 8,\n  value: 1\n}, {\n  frames: 1,\n  value: 1\n}, {\n  frames: 5,\n  value: 0\n}, {\n  frames: 18,\n  value: 0\n}]);\nconst fade = timeline(0, [{\n  frames: 1,\n  value: 1\n}, {\n  frames: 5,\n  value: 1\n}, {\n  frames: 1,\n  value: 0\n}, {\n  frames: 6,\n  value: 0\n}]);\nconst DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\nconst MINIMUM_RADIUS_RATIO = 1.1 * SAFE_RADIUS_RATIO;\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nconst DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nconst INTERACTION_PROMPT = 'Use mouse, touch or arrow keys to control the camera!';\nconst InteractionPromptStrategy = {\n  AUTO: 'auto',\n  WHEN_FOCUSED: 'when-focused',\n  NONE: 'none'\n};\nconst InteractionPromptStyle = {\n  BASIC: 'basic',\n  WIGGLE: 'wiggle'\n};\nconst InteractionPolicy = {\n  ALWAYS_ALLOW: 'always-allow',\n  WHEN_FOCUSED: 'allow-when-focused'\n};\nconst TouchAction = {\n  PAN_Y: 'pan-y',\n  PAN_X: 'pan-x',\n  NONE: 'none'\n};\n\nconst fieldOfViewIntrinsics = element => {\n  return {\n    basis: [numberNode(element[$zoomAdjustedFieldOfView] * Math.PI / 180, 'rad')],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\n\nconst minFieldOfViewIntrinsics = {\n  basis: [degreesToRadians(numberNode(25, 'deg'))],\n  keywords: {\n    auto: [null]\n  }\n};\n\nconst maxFieldOfViewIntrinsics = element => {\n  const scene = element[$scene];\n  return {\n    basis: [degreesToRadians(numberNode(45, 'deg'))],\n    keywords: {\n      auto: [numberNode(scene.framedFieldOfView, 'deg')]\n    }\n  };\n};\n\nconst cameraOrbitIntrinsics = (() => {\n  const defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms;\n  const theta = normalizeUnit(defaultTerms[0]);\n  const phi = normalizeUnit(defaultTerms[1]);\n  return element => {\n    const radius = element[$scene].idealCameraDistance;\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {\n        auto: [null, null, numberNode(105, '%')]\n      }\n    };\n  };\n})();\n\nconst minCameraOrbitIntrinsics = element => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].idealCameraDistance;\n  return {\n    basis: [numberNode(-Infinity, 'rad'), numberNode(Math.PI / 8, 'rad'), numberNode(radius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nconst maxCameraOrbitIntrinsics = element => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n  return {\n    basis: [numberNode(Infinity, 'rad'), numberNode(Math.PI - Math.PI / 8, 'rad'), numberNode(defaultRadius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nconst cameraTargetIntrinsics = element => {\n  const center = element[$scene].boundingBox.getCenter(new Vector3());\n  return {\n    basis: [numberNode(center.x, 'm'), numberNode(center.y, 'm'), numberNode(center.z, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\nconst $controls = Symbol('controls');\nconst $promptElement = Symbol('promptElement');\nconst $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\nconst $onBlur = Symbol('onBlur');\nconst $onFocus = Symbol('onFocus');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $focusedTime = Symbol('focusedTime');\nconst $zoomAdjustedFieldOfView = Symbol('zoomAdjustedFieldOfView');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $initialized = Symbol('initialized');\nconst $maintainThetaPhi = Symbol('maintainThetaPhi');\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\n\nconst ControlsMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;\n\n  class ControlsModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.cameraControls = false;\n      this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      this.cameraTarget = DEFAULT_CAMERA_TARGET;\n      this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      this.minCameraOrbit = 'auto';\n      this.maxCameraOrbit = 'auto';\n      this.minFieldOfView = 'auto';\n      this.maxFieldOfView = 'auto';\n      this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;\n      this.interactionPrompt = InteractionPromptStrategy.AUTO;\n      this.interactionPolicy = InteractionPolicy.ALWAYS_ALLOW;\n      this.orbitSensitivity = 1;\n      this.touchAction = TouchAction.PAN_Y;\n      this.disableZoom = false;\n      this.interpolationDecay = DECAY_MILLISECONDS;\n      this.bounds = 'legacy';\n      this[_a] = this.shadowRoot.querySelector('.interaction-prompt');\n      this[_b] = this.shadowRoot.querySelector('.interaction-prompt > .animated-container');\n      this[_c] = Infinity;\n      this[_d] = 0;\n      this[_e] = Infinity;\n      this[_f] = false;\n      this[_g] = false;\n      this[_h] = new SmoothControls(this[$scene].camera, this[$userInputElement]);\n      this[_j] = 0;\n      this[_k] = new Spherical();\n      this[_l] = false;\n      this[_m] = false;\n      this[_o] = false;\n\n      this[_p] = () => {\n        const input = this[$userInputElement];\n\n        if (!isFinite(this[$focusedTime])) {\n          this[$focusedTime] = performance.now();\n        } // NOTE(cdata): On every re-focus, we switch the aria-label back to\n        // the original, non-prompt label if appropriate. If the user has\n        // already interacted, they no longer need to hear the prompt.\n        // Otherwise, they will hear it again after the idle prompt threshold\n        // has been crossed.\n\n\n        const ariaLabel = this[$ariaLabel];\n\n        if (input.getAttribute('aria-label') !== ariaLabel) {\n          input.setAttribute('aria-label', ariaLabel);\n        }\n\n        if (this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        }\n      };\n\n      this[_q] = () => {\n        if (this.interactionPrompt !== InteractionPromptStrategy.WHEN_FOCUSED) {\n          return;\n        }\n\n        this[$waitingToPromptUser] = false;\n        this[$promptElement].classList.remove('visible');\n        this[$promptElementVisibleTime] = Infinity;\n        this[$focusedTime] = Infinity;\n      };\n\n      this[_r] = ({\n        source\n      }) => {\n        this[$updateAria]();\n        this[$needsRender]();\n\n        if (source === ChangeSource.USER_INTERACTION) {\n          this[$userHasInteracted] = true;\n          this[$deferInteractionPrompt]();\n        }\n\n        this.dispatchEvent(new CustomEvent('camera-change', {\n          detail: {\n            source\n          }\n        }));\n      };\n\n      this[_s] = event => {\n        if (event.type === 'pointer-change-start') {\n          this[$container].classList.add('pointer-tumbling');\n        } else {\n          this[$container].classList.remove('pointer-tumbling');\n        }\n      };\n    }\n\n    getCameraOrbit() {\n      const {\n        theta,\n        phi,\n        radius\n      } = this[$lastSpherical];\n      return {\n        theta,\n        phi,\n        radius,\n\n        toString() {\n          return `${this.theta}rad ${this.phi}rad ${this.radius}m`;\n        }\n\n      };\n    }\n\n    getCameraTarget() {\n      return toVector3D(this[$renderer].isPresenting ? this[$renderer].arRenderer.target : this[$scene].getTarget());\n    }\n\n    getFieldOfView() {\n      return this[$controls].getFieldOfView();\n    } // Provided so user code does not have to parse these from attributes.\n\n\n    getMinimumFieldOfView() {\n      return this[$controls].options.minimumFieldOfView;\n    }\n\n    getMaximumFieldOfView() {\n      return this[$controls].options.maximumFieldOfView;\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this[$controls].addEventListener('change', this[$onChange]);\n      this[$controls].addEventListener('pointer-change-start', this[$onPointerChange]);\n      this[$controls].addEventListener('pointer-change-end', this[$onPointerChange]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$controls].removeEventListener('change', this[$onChange]);\n      this[$controls].removeEventListener('pointer-change-start', this[$onPointerChange]);\n      this[$controls].removeEventListener('pointer-change-end', this[$onPointerChange]);\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      const controls = this[$controls];\n      const input = this[$userInputElement];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n\n          input.addEventListener('focus', this[$onFocus]);\n          input.addEventListener('blur', this[$onBlur]);\n        } else {\n          input.removeEventListener('focus', this[$onFocus]);\n          input.removeEventListener('blur', this[$onBlur]);\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('disableZoom')) {\n        controls.disableZoom = this.disableZoom;\n      }\n\n      if (changedProperties.has('bounds')) {\n        this[$scene].tightBounds = this.bounds === 'tight';\n      }\n\n      if (changedProperties.has('interactionPrompt') || changedProperties.has('cameraControls') || changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptElement].classList.toggle('wiggle', this.interactionPromptStyle === InteractionPromptStyle.WIGGLE);\n      }\n\n      if (changedProperties.has('interactionPolicy')) {\n        const interactionPolicy = this.interactionPolicy;\n        controls.applyOptions({\n          interactionPolicy\n        });\n      }\n\n      if (changedProperties.has('touchAction')) {\n        const touchAction = this.touchAction;\n        controls.applyOptions({\n          touchAction\n        });\n      }\n\n      if (changedProperties.has('orbitSensitivity')) {\n        controls.sensitivity = this.orbitSensitivity;\n      }\n\n      if (changedProperties.has('interpolationDecay')) {\n        controls.setDamperDecayTime(this.interpolationDecay);\n        this[$scene].setTargetDamperDecayTime(this.interpolationDecay);\n      }\n\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          controls.jumpToGoal();\n          this[$scene].jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n\n    updateFraming() {\n      var _this28 = this;\n\n      return _asyncToGenerator(function* () {\n        const scene = _this28[$scene];\n        const oldFramedFieldOfView = scene.framedFieldOfView;\n        yield _this28.requestUpdate('cameraTarget');\n        scene.updateFraming(_this28.bounds === 'tight' ? scene.getTarget() : undefined);\n        scene.frameModel();\n        const newFramedFieldOfView = scene.framedFieldOfView;\n        const zoom = _this28[$controls].getFieldOfView() / oldFramedFieldOfView;\n        _this28[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n        _this28[$maintainThetaPhi] = true;\n\n        _this28.requestUpdate('maxFieldOfView');\n\n        _this28.requestUpdate('fieldOfView');\n\n        _this28.requestUpdate('minCameraOrbit');\n\n        _this28.requestUpdate('maxCameraOrbit');\n\n        yield _this28.requestUpdate('cameraOrbit');\n      })();\n    }\n\n    [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $focusedTime, _d = $lastPromptOffset, _e = $promptElementVisibleTime, _f = $userHasInteracted, _g = $waitingToPromptUser, _h = $controls, _j = $zoomAdjustedFieldOfView, _k = $lastSpherical, _l = $jumpCamera, _m = $initialized, _o = $maintainThetaPhi, $syncFieldOfView)](style) {\n      this[$controls].setFieldOfView(style[0] * 180 / Math.PI);\n    }\n\n    [$syncCameraOrbit](style) {\n      if (this[$maintainThetaPhi]) {\n        const {\n          theta,\n          phi\n        } = this.getCameraOrbit();\n        style[0] = theta;\n        style[1] = phi;\n        this[$maintainThetaPhi] = false;\n      }\n\n      this[$controls].setOrbit(style[0], style[1], style[2]);\n    }\n\n    [$syncMinCameraOrbit](style) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxCameraOrbit](style) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this[$updateCameraForRadius](style[2]);\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMinFieldOfView](style) {\n      this[$controls].applyOptions({\n        minimumFieldOfView: style[0] * 180 / Math.PI\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxFieldOfView](style) {\n      this[$controls].applyOptions({\n        maximumFieldOfView: style[0] * 180 / Math.PI\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncCameraTarget](style) {\n      const [x, y, z] = style;\n      this[$scene].setTarget(x, y, z);\n      this[$renderer].arRenderer.updateTarget();\n    }\n\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n\n      if (this[$renderer].isPresenting || !this[$hasTransitioned]()) {\n        return;\n      }\n\n      const now = performance.now();\n\n      if (this[$waitingToPromptUser]) {\n        const thresholdTime = this.interactionPrompt === InteractionPromptStrategy.AUTO ? this[$loadedTime] : this[$focusedTime];\n\n        if (this.loaded && now > thresholdTime + this.interactionPromptThreshold) {\n          this[$userInputElement].setAttribute('aria-label', INTERACTION_PROMPT);\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n      if (isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const scene = this[$scene];\n        const animationTime = (now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME % 1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n\n        if (offset !== this[$lastPromptOffset]) {\n          const xOffset = offset * scene.width * 0.05;\n          const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n          this[$promptAnimatedContainer].style.transform = `translateX(${xOffset}px)`;\n          this[$controls].adjustOrbit(deltaTheta, 0, 0);\n          this[$lastPromptOffset] = offset;\n        }\n      }\n\n      this[$controls].update(time, delta);\n      this[$scene].updateTarget(delta);\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n\n\n    [$updateCameraForRadius](radius) {\n      const {\n        idealCameraDistance\n      } = this[$scene];\n      const maximumRadius = Math.max(idealCameraDistance, radius);\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n\n    [$updateAria]() {\n      // NOTE(cdata): It is possible that we might want to record the\n      // last spherical when the label actually changed. Right now, the\n      // side-effect the current implementation is that we will only\n      // announce the first view change that occurs after the element\n      // becomes focused.\n      const {\n        theta: lastTheta,\n        phi: lastPhi\n      } = this[$lastSpherical];\n      const {\n        theta,\n        phi\n      } = this[$controls].getCameraSpherical(this[$lastSpherical]);\n      const rootNode = this.getRootNode(); // Only change the aria-label if <model-viewer> is currently focused:\n\n      if (rootNode != null && rootNode.activeElement === this) {\n        const lastAzimuthalQuadrant = (4 + Math.floor((lastTheta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n        const azimuthalQuadrant = (4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n        const lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n        const polarTrient = Math.floor(phi / THIRD_PI);\n\n        if (azimuthalQuadrant !== lastAzimuthalQuadrant || polarTrient !== lastPolarTrient) {\n          const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n          const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n          const ariaLabel = `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`;\n          this[$userInputElement].setAttribute('aria-label', ariaLabel);\n        }\n      }\n    }\n\n    [$onResize](event) {\n      const controls = this[$controls];\n      const oldFramedFieldOfView = this[$scene].framedFieldOfView; // The super of $onResize will update the scene's framedFieldOfView, so we\n      // compare the before and after to calculate the proper zoom.\n\n      super[$onResize](event);\n      const newFramedFieldOfView = this[$scene].framedFieldOfView;\n      const zoom = controls.getFieldOfView() / oldFramedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n      controls.updateAspect(this[$scene].aspect);\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.jumpCameraToGoal();\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      const {\n        framedFieldOfView\n      } = this[$scene];\n      this[$zoomAdjustedFieldOfView] = framedFieldOfView;\n\n      if (this[$initialized]) {\n        this[$maintainThetaPhi] = true;\n      } else {\n        this[$initialized] = true;\n      }\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n\n  }\n\n  _p = $onFocus, _q = $onBlur, _r = $onChange, _s = $onPointerChange;\n\n  __decorate$3([property({\n    type: Boolean,\n    attribute: 'camera-controls'\n  })], ControlsModelViewerElement.prototype, \"cameraControls\", void 0);\n\n  __decorate$3([style({\n    intrinsics: cameraOrbitIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraOrbit\", void 0);\n\n  __decorate$3([style({\n    intrinsics: cameraTargetIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraTarget\n  }), property({\n    type: String,\n    attribute: 'camera-target',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraTarget\", void 0);\n\n  __decorate$3([style({\n    intrinsics: fieldOfViewIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncFieldOfView\n  }), property({\n    type: String,\n    attribute: 'field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"fieldOfView\", void 0);\n\n  __decorate$3([style({\n    intrinsics: minCameraOrbitIntrinsics,\n    updateHandler: $syncMinCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'min-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minCameraOrbit\", void 0);\n\n  __decorate$3([style({\n    intrinsics: maxCameraOrbitIntrinsics,\n    updateHandler: $syncMaxCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'max-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxCameraOrbit\", void 0);\n\n  __decorate$3([style({\n    intrinsics: minFieldOfViewIntrinsics,\n    updateHandler: $syncMinFieldOfView\n  }), property({\n    type: String,\n    attribute: 'min-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minFieldOfView\", void 0);\n\n  __decorate$3([style({\n    intrinsics: maxFieldOfViewIntrinsics,\n    updateHandler: $syncMaxFieldOfView\n  }), property({\n    type: String,\n    attribute: 'max-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxFieldOfView\", void 0);\n\n  __decorate$3([property({\n    type: Number,\n    attribute: 'interaction-prompt-threshold'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptThreshold\", void 0);\n\n  __decorate$3([property({\n    type: String,\n    attribute: 'interaction-prompt-style'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptStyle\", void 0);\n\n  __decorate$3([property({\n    type: String,\n    attribute: 'interaction-prompt'\n  })], ControlsModelViewerElement.prototype, \"interactionPrompt\", void 0);\n\n  __decorate$3([property({\n    type: String,\n    attribute: 'interaction-policy'\n  })], ControlsModelViewerElement.prototype, \"interactionPolicy\", void 0);\n\n  __decorate$3([property({\n    type: Number,\n    attribute: 'orbit-sensitivity'\n  })], ControlsModelViewerElement.prototype, \"orbitSensitivity\", void 0);\n\n  __decorate$3([property({\n    type: String,\n    attribute: 'touch-action'\n  })], ControlsModelViewerElement.prototype, \"touchAction\", void 0);\n\n  __decorate$3([property({\n    type: Boolean,\n    attribute: 'disable-zoom'\n  })], ControlsModelViewerElement.prototype, \"disableZoom\", void 0);\n\n  __decorate$3([property({\n    type: Number,\n    attribute: 'interpolation-decay'\n  })], ControlsModelViewerElement.prototype, \"interpolationDecay\", void 0);\n\n  __decorate$3([property({\n    type: String,\n    attribute: 'bounds'\n  })], ControlsModelViewerElement.prototype, \"bounds\", void 0);\n\n  return ControlsModelViewerElement;\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a$2, _b;\n\nconst INITIAL_STATUS_ANNOUNCEMENT = 'This page includes one or more 3D models that are loading';\nconst FINISHED_LOADING_ANNOUNCEMENT = 'All 3D models in the page have loaded';\nconst UPDATE_STATUS_DEBOUNCE_MS = 100;\nconst $modelViewerStatusInstance = Symbol('modelViewerStatusInstance');\nconst $updateStatus = Symbol('updateStatus');\n/**\n * The LoadingStatusAnnouncer manages announcements of loading status across\n * all <model-viewer> elements in the document at any given time. As new\n * <model-viewer> elements are connected to the document, they are registered\n * with a LoadingStatusAnnouncer singleton. As they are disconnected, the are\n * also unregistered. Announcements are made to indicate the following\n * conditions:\n *\n *  1. There are <model-viewer> elements that have yet to finish loading\n *  2. All <model-viewer> elements in the page have finished attempting to load\n */\n\nclass LoadingStatusAnnouncer extends EventDispatcher {\n  constructor() {\n    super();\n    /**\n     * The \"status\" instance is the <model-viewer> instance currently designated\n     * to announce the loading status of all <model-viewer> elements in the\n     * document at any given time. It might change as <model-viewer> elements are\n     * attached or detached over time.\n     */\n\n    this[_a$2] = null;\n    this.registeredInstanceStatuses = new Map();\n    this.loadingPromises = [];\n    /**\n     * This element is a node that floats around the document as the status\n     * instance changes (see above). It is a singleton that represents the loading\n     * status for all <model-viewer> elements currently in the page. It has its\n     * role attribute set to \"status\", which causes screen readers to announce\n     * any changes to its text content.\n     *\n     * @see https://www.w3.org/TR/wai-aria-1.1/#status\n     */\n\n    this.statusElement = document.createElement('p');\n    this.statusUpdateInProgress = false;\n    this[_b] = debounce(() => this.updateStatus(), UPDATE_STATUS_DEBOUNCE_MS);\n    const {\n      statusElement\n    } = this;\n    const {\n      style\n    } = statusElement;\n    statusElement.setAttribute('role', 'status');\n    statusElement.classList.add('screen-reader-only');\n    style.top = style.left = '0';\n    style.pointerEvents = 'none';\n  }\n  /**\n   * Register a <model-viewer> element with the announcer. If it is not yet\n   * loaded, its loading status will be tracked by the announcer.\n   */\n\n\n  registerInstance(modelViewer) {\n    if (this.registeredInstanceStatuses.has(modelViewer)) {\n      return;\n    }\n\n    let onUnregistered = () => {};\n\n    const loadShouldBeMeasured = modelViewer.loaded === false && !!modelViewer.src;\n    const loadAttemptCompletes = new Promise(resolve => {\n      if (!loadShouldBeMeasured) {\n        resolve();\n        return;\n      }\n\n      const resolveHandler = () => {\n        resolve();\n        modelViewer.removeEventListener('load', resolveHandler);\n        modelViewer.removeEventListener('error', resolveHandler);\n      };\n\n      modelViewer.addEventListener('load', resolveHandler);\n      modelViewer.addEventListener('error', resolveHandler);\n      onUnregistered = resolveHandler;\n    });\n    this.registeredInstanceStatuses.set(modelViewer, {\n      onUnregistered\n    });\n    this.loadingPromises.push(loadAttemptCompletes);\n\n    if (this.modelViewerStatusInstance == null) {\n      this.modelViewerStatusInstance = modelViewer;\n    }\n  }\n  /**\n   * Unregister a <model-viewer> element with the announcer. Its loading status\n   * will no longer be tracked by the announcer.\n   */\n\n\n  unregisterInstance(modelViewer) {\n    if (!this.registeredInstanceStatuses.has(modelViewer)) {\n      return;\n    }\n\n    const statuses = this.registeredInstanceStatuses;\n    const instanceStatus = statuses.get(modelViewer);\n    statuses.delete(modelViewer);\n    instanceStatus.onUnregistered();\n\n    if (this.modelViewerStatusInstance === modelViewer) {\n      this.modelViewerStatusInstance = statuses.size > 0 ? getFirstMapKey(statuses) : null;\n    }\n  }\n\n  get modelViewerStatusInstance() {\n    return this[$modelViewerStatusInstance];\n  }\n\n  set modelViewerStatusInstance(value) {\n    const currentInstance = this[$modelViewerStatusInstance];\n\n    if (currentInstance === value) {\n      return;\n    }\n\n    const {\n      statusElement\n    } = this;\n\n    if (value != null && value.shadowRoot != null) {\n      value.shadowRoot.appendChild(statusElement);\n    } else if (statusElement.parentNode != null) {\n      statusElement.parentNode.removeChild(statusElement);\n    }\n\n    this[$modelViewerStatusInstance] = value;\n    this[$updateStatus]();\n  }\n\n  updateStatus() {\n    var _this29 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this29.statusUpdateInProgress || _this29.loadingPromises.length === 0) {\n        return;\n      }\n\n      _this29.statusElement.textContent = INITIAL_STATUS_ANNOUNCEMENT;\n      _this29.statusUpdateInProgress = true;\n\n      _this29.dispatchEvent({\n        type: 'initial-status-announced'\n      });\n\n      while (_this29.loadingPromises.length) {\n        const {\n          loadingPromises\n        } = _this29;\n        _this29.loadingPromises = [];\n        yield Promise.all(loadingPromises);\n      }\n\n      _this29.statusElement.textContent = FINISHED_LOADING_ANNOUNCEMENT;\n      _this29.statusUpdateInProgress = false;\n\n      _this29.dispatchEvent({\n        type: 'finished-loading-announced'\n      });\n    })();\n  }\n\n}\n\n_a$2 = $modelViewerStatusInstance, _b = $updateStatus;\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nconst PROGRESS_BAR_UPDATE_THRESHOLD = 100;\nconst PROGRESS_MASK_BASE_OPACITY = 0.2;\nconst DEFAULT_DRACO_DECODER_LOCATION = 'https://www.gstatic.com/draco/versioned/decoders/1.3.6/';\nconst DEFAULT_KTX2_TRANSCODER_LOCATION = 'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/';\nconst SPACE_KEY = 32;\nconst ENTER_KEY = 13;\nconst RevealStrategy = {\n  AUTO: 'auto',\n  INTERACTION: 'interaction',\n  MANUAL: 'manual'\n};\nconst LoadingStrategy = {\n  AUTO: 'auto',\n  LAZY: 'lazy',\n  EAGER: 'eager'\n};\nconst PosterDismissalSource = {\n  INTERACTION: 'interaction'\n};\nconst loadingStatusAnnouncer = new LoadingStatusAnnouncer();\nconst $defaultProgressBarElement = Symbol('defaultProgressBarElement');\nconst $defaultProgressMaskElement = Symbol('defaultProgressMaskElement');\nconst $posterContainerElement = Symbol('posterContainerElement');\nconst $defaultPosterElement = Symbol('defaultPosterElement');\nconst $posterDismissalSource = Symbol('posterDismissalSource');\nconst $hidePoster = Symbol('hidePoster');\nconst $modelIsRevealed = Symbol('modelIsRevealed');\nconst $updateProgressBar = Symbol('updateProgressBar');\nconst $lastReportedProgress = Symbol('lastReportedProgress');\nconst $transitioned = Symbol('transitioned');\nconst $ariaLabelCallToAction = Symbol('ariaLabelCallToAction');\nconst $onClick = Symbol('onClick');\nconst $onKeydown = Symbol('onKeydown');\nconst $onProgress = Symbol('onProgress');\n/**\n * LoadingMixin implements features related to lazy loading, as well as\n * presentation details related to the pre-load / pre-render presentation of a\n * <model-viewer>\n *\n * This mixin implements support for models with DRACO-compressed meshes.\n * The DRACO decoder will be loaded on-demand if a glTF that uses the DRACO mesh\n * compression extension is encountered.\n *\n * By default, the DRACO decoder will be loaded from a Google CDN. It is\n * possible to customize where the decoder is loaded from by defining a global\n * configuration option for `<model-viewer>` like so:\n *\n * ```html\n * <script>\n * ModelViewerElement = self.ModelViewerElement || {};\n * ModelViewerElement.dracoDecoderLocation =\n *     'http://example.com/location/of/draco/decoder/files/';\n * </script>\n * ```\n *\n * Note that the above configuration strategy must be performed *before* the\n * first `<model-viewer>` element is created in the browser. The configuration\n * can be done anywhere, but the easiest way to ensure it is done at the right\n * time is to do it in the `<head>` of the HTML document. This is the\n * recommended way to set the location because it is most compatible with\n * scenarios where the `<model-viewer>` library is lazily loaded.\n *\n * If you absolutely have to set the DRACO decoder location *after* the first\n * `<model-viewer>` element is created, you can do it this way:\n *\n * ```html\n * <script>\n * const ModelViewerElement = customElements.get('model-viewer');\n * ModelViewerElement.dracoDecoderLocation =\n *     'http://example.com/location/of/draco/decoder/files/';\n * </script>\n * ```\n *\n * Note that the above configuration approach will not work until *after*\n * `<model-viewer>` is defined in the browser. Also note that this configuration\n * *must* be set *before* the first DRACO model is fully loaded.\n *\n * It is recommended that users who intend to take advantage of DRACO mesh\n * compression consider whether or not it is acceptable for their use case to\n * have code side-loaded from a Google CDN. If it is not acceptable, then the\n * location must be customized before loading any DRACO models in order to cause\n * the decoder to be loaded from an alternative, acceptable location.\n */\n\nconst LoadingMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n\n  class LoadingModelViewerElement extends ModelViewerElement {\n    constructor(...args) {\n      super(...args);\n      /**\n       * A URL pointing to the image to use as a poster in scenarios where the\n       * <model-viewer> is not ready to reveal a rendered model to the viewer.\n       */\n\n      this.poster = null;\n      /**\n       * An enumerable attribute describing under what conditions the\n       * <model-viewer> should reveal a model to the viewer.\n       *\n       * The default value is \"auto\". The only supported alternative values are\n       * \"interaction\" and \"manual\".\n       */\n\n      this.reveal = RevealStrategy.AUTO;\n      /**\n       * An enumerable attribute describing under what conditions the\n       * <model-viewer> should preload a model.\n       *\n       * The default value is \"auto\". The only supported alternative values are\n       * \"lazy\" and \"eager\". Auto is equivalent to lazy, which loads the model\n       * when it is near the viewport for reveal = \"auto\", and when interacted\n       * with for reveal = \"interaction\". Eager loads the model immediately.\n       */\n\n      this.loading = LoadingStrategy.AUTO;\n      this[_a] = false;\n      this[_b] = false;\n      this[_c] = 0;\n      this[_d] = null; // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n\n      this[_e] = this.shadowRoot.querySelector('.slot.poster');\n      this[_f] = this.shadowRoot.querySelector('#default-poster');\n      this[_g] = this.shadowRoot.querySelector('#default-progress-bar > .bar');\n      this[_h] = this.shadowRoot.querySelector('#default-progress-bar > .mask');\n      this[_j] = this[$defaultPosterElement].getAttribute('aria-label');\n      this[_k] = throttle(progress => {\n        const parentNode = this[$defaultProgressBarElement].parentNode;\n        requestAnimationFrame(() => {\n          this[$defaultProgressMaskElement].style.opacity = `${(1.0 - progress) * PROGRESS_MASK_BASE_OPACITY}`;\n          this[$defaultProgressBarElement].style.transform = `scaleX(${progress})`;\n\n          if (progress === 0) {\n            // NOTE(cdata): We remove and re-append the progress bar in this\n            // condition so that the progress bar does not appear to\n            // transition backwards from the right when we reset to 0 (or\n            // otherwise <1) progress after having already reached 1 progress\n            // previously.\n            parentNode.removeChild(this[$defaultProgressBarElement]);\n            parentNode.appendChild(this[$defaultProgressBarElement]);\n          } // NOTE(cdata): IE11 does not properly respect the second parameter\n          // of classList.toggle, which this implementation originally used.\n          // @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865865/\n\n\n          if (progress === 1.0) {\n            this[$defaultProgressBarElement].classList.add('hide');\n          } else {\n            this[$defaultProgressBarElement].classList.remove('hide');\n          }\n        });\n      }, PROGRESS_BAR_UPDATE_THRESHOLD);\n\n      this[_l] = () => {\n        if (this.reveal === RevealStrategy.MANUAL) {\n          return;\n        }\n\n        this.dismissPoster();\n      };\n\n      this[_m] = event => {\n        if (this.reveal === RevealStrategy.MANUAL) {\n          return;\n        }\n\n        switch (event.keyCode) {\n          // NOTE(cdata): Links and buttons can typically be activated with\n          // both spacebar and enter to produce a synthetic click action\n          case SPACE_KEY:\n          case ENTER_KEY:\n            this.dismissPoster();\n            break;\n        }\n      };\n\n      this[_o] = event => {\n        const progress = event.detail.totalProgress;\n        this[$lastReportedProgress] = Math.max(progress, this[$lastReportedProgress]);\n\n        if (progress === 1.0) {\n          this[$updateProgressBar].flush();\n\n          if (this[$sceneIsReady]() && (this[$posterDismissalSource] != null || this.reveal === RevealStrategy.AUTO)) {\n            this[$hidePoster]();\n          }\n        }\n\n        this[$updateProgressBar](progress);\n        this.dispatchEvent(new CustomEvent('progress', {\n          detail: {\n            totalProgress: progress\n          }\n        }));\n      };\n\n      const ModelViewerElement = self.ModelViewerElement || {};\n      const dracoDecoderLocation = ModelViewerElement.dracoDecoderLocation || DEFAULT_DRACO_DECODER_LOCATION;\n      CachingGLTFLoader.setDRACODecoderLocation(dracoDecoderLocation);\n      const ktx2TranscoderLocation = ModelViewerElement.ktx2TranscoderLocation || DEFAULT_KTX2_TRANSCODER_LOCATION;\n      CachingGLTFLoader.setKTX2TranscoderLocation(ktx2TranscoderLocation);\n    }\n\n    static set dracoDecoderLocation(value) {\n      CachingGLTFLoader.setDRACODecoderLocation(value);\n    }\n\n    static get dracoDecoderLocation() {\n      return CachingGLTFLoader.getDRACODecoderLocation();\n    }\n\n    static set ktx2TranscoderLocation(value) {\n      CachingGLTFLoader.setKTX2TranscoderLocation(value);\n    }\n\n    static get ktx2TranscoderLocation() {\n      return CachingGLTFLoader.getKTX2TranscoderLocation();\n    }\n    /**\n     * If provided, the callback will be passed each resource URL before a\n     * request is sent. The callback may return the original URL, or a new URL\n     * to override loading behavior. This behavior can be used to load assets\n     * from .ZIP files, drag-and-drop APIs, and Data URIs.\n     */\n\n\n    static mapURLs(callback) {\n      Renderer.singleton.loader[$loader].manager.setURLModifier(callback);\n    }\n    /**\n     * Dismisses the poster, causing the model to load and render if\n     * necessary. This is currently effectively the same as interacting with\n     * the poster via user input.\n     */\n\n\n    dismissPoster() {\n      if (this[$sceneIsReady]()) {\n        this[$hidePoster]();\n      } else {\n        this[$posterDismissalSource] = PosterDismissalSource.INTERACTION;\n        this[$updateSource]();\n      }\n    }\n    /**\n     * Displays the poster, hiding the 3D model. If this is called after the 3D\n     * model has been revealed, then it will behave as though\n     * reveal='interaction', being dismissed either by a user click or a call to\n     * dismissPoster().\n     */\n\n\n    showPoster() {\n      const posterContainerElement = this[$posterContainerElement];\n      const defaultPosterElement = this[$defaultPosterElement];\n      defaultPosterElement.removeAttribute('tabindex');\n      defaultPosterElement.removeAttribute('aria-hidden');\n      posterContainerElement.classList.add('show');\n      const oldVisibility = this.modelIsVisible;\n      this[$modelIsRevealed] = false;\n      this[$announceModelVisibility](oldVisibility);\n      this[$transitioned] = false;\n    }\n    /**\n     * Returns the model's bounding box dimensions in meters, independent of\n     * turntable rotation.\n     */\n\n\n    getDimensions() {\n      return toVector3D(this[$scene].size);\n    }\n\n    connectedCallback() {\n      super.connectedCallback(); // Fired when a user first clicks the model element. Used to\n      // change the visibility of a poster image, or start loading\n      // a model.\n\n      this[$posterContainerElement].addEventListener('click', this[$onClick]);\n      this[$posterContainerElement].addEventListener('keydown', this[$onKeydown]);\n      this[$progressTracker].addEventListener('progress', this[$onProgress]);\n      loadingStatusAnnouncer.registerInstance(this);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$posterContainerElement].removeEventListener('click', this[$onClick]);\n      this[$posterContainerElement].removeEventListener('keydown', this[$onKeydown]);\n      this[$progressTracker].removeEventListener('progress', this[$onProgress]);\n      loadingStatusAnnouncer.unregisterInstance(this);\n    }\n\n    updated(changedProperties) {\n      var _superprop_getUpdated = () => super.updated,\n          _this30 = this;\n\n      return _asyncToGenerator(function* () {\n        _superprop_getUpdated().call(_this30, changedProperties);\n\n        if (changedProperties.has('poster') && _this30.poster != null) {\n          _this30[$defaultPosterElement].style.backgroundImage = `url(${_this30.poster})`;\n        }\n\n        if (changedProperties.has('alt')) {\n          _this30[$defaultPosterElement].setAttribute('aria-label', `${_this30[$ariaLabel]}. ${_this30[$ariaLabelCallToAction]}`);\n        }\n\n        if (changedProperties.has('reveal') || changedProperties.has('loading')) {\n          _this30[$updateSource]();\n        }\n      })();\n    }\n\n    [(_a = $modelIsRevealed, _b = $transitioned, _c = $lastReportedProgress, _d = $posterDismissalSource, _e = $posterContainerElement, _f = $defaultPosterElement, _g = $defaultProgressBarElement, _h = $defaultProgressMaskElement, _j = $ariaLabelCallToAction, _k = $updateProgressBar, _l = $onClick, _m = $onKeydown, _o = $onProgress, $shouldAttemptPreload)]() {\n      return !!this.src && (this[$posterDismissalSource] != null || this.loading === LoadingStrategy.EAGER || this.reveal === RevealStrategy.AUTO && this[$isElementInViewport]);\n    }\n\n    [$sceneIsReady]() {\n      const {\n        src\n      } = this;\n      return !!src && super[$sceneIsReady]() && this[$lastReportedProgress] === 1.0;\n    }\n\n    [$hidePoster]() {\n      this[$posterDismissalSource] = null;\n      const posterContainerElement = this[$posterContainerElement];\n      const defaultPosterElement = this[$defaultPosterElement];\n\n      if (posterContainerElement.classList.contains('show')) {\n        posterContainerElement.classList.remove('show');\n        const oldVisibility = this.modelIsVisible;\n        this[$modelIsRevealed] = true;\n        this[$announceModelVisibility](oldVisibility); // We might need to forward focus to our internal canvas, but that\n        // cannot happen until the poster has completely transitioned away\n\n        posterContainerElement.addEventListener('transitionend', () => {\n          requestAnimationFrame(() => {\n            this[$transitioned] = true;\n            const root = this.getRootNode(); // If the <model-viewer> is still focused, forward the focus to\n            // the canvas that has just been revealed\n\n            if (root && root.activeElement === this) {\n              this[$userInputElement].focus();\n            } // Ensure that the poster is no longer focusable or visible to\n            // screen readers\n\n\n            defaultPosterElement.setAttribute('aria-hidden', 'true');\n            defaultPosterElement.tabIndex = -1;\n            this.dispatchEvent(new CustomEvent('poster-dismissed'));\n          });\n        }, {\n          once: true\n        });\n      }\n    }\n\n    [$getModelIsVisible]() {\n      return super[$getModelIsVisible]() && this[$modelIsRevealed];\n    }\n\n    [$hasTransitioned]() {\n      return super[$hasTransitioned]() && this[$transitioned];\n    }\n\n    [$updateSource]() {\n      var _superprop_get2 = _prop2 => super[_prop2],\n          _this31 = this;\n\n      return _asyncToGenerator(function* () {\n        _this31[$lastReportedProgress] = 0;\n\n        if (_this31[$scene].currentGLTF == null || _this31.src == null || !_this31[$shouldAttemptPreload]()) {\n          // Don't show the poster when switching models.\n          _this31.showPoster();\n        }\n\n        yield _superprop_get2($updateSource).call(_this31);\n      })();\n    }\n\n  }\n\n  __decorate$2([property({\n    type: String\n  })], LoadingModelViewerElement.prototype, \"poster\", void 0);\n\n  __decorate$2([property({\n    type: String\n  })], LoadingModelViewerElement.prototype, \"reveal\", void 0);\n\n  __decorate$2([property({\n    type: String\n  })], LoadingModelViewerElement.prototype, \"loading\", void 0);\n\n  return LoadingModelViewerElement;\n};\n\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n\n\n  parse(input, onDone, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options);\n  }\n\n} //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942; //------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\n\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\n\n\nfunction stringToArrayBuffer(text) {\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(text).buffer;\n  }\n\n  const array = new Uint8Array(new ArrayBuffer(text.length));\n\n  for (let i = 0, il = text.length; i < il; i++) {\n    const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n    array[i] = value > 0xFF ? 0x20 : value;\n  }\n\n  return array.buffer;\n}\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\n\n\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\n\n\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n      }\n\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n\n  return output;\n}\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\n\n\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\n\n\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n\n    return array.buffer;\n  }\n\n  return arrayBuffer;\n}\n\nlet cachedCanvas = null;\n/**\n * Writer\n */\n\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n\n\n  write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      truncateDrawRange: true,\n      embedImages: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n    const writer = this;\n    Promise.all(this.pending).then(function () {\n      const buffers = writer.buffers;\n      const json = writer.json;\n      const options = writer.options;\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n      const blob = new Blob(buffers, {\n        type: 'application/octet-stream'\n      }); // Declare extensions.\n\n      const extensionsUsedList = Object.keys(extensionsUsed);\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n      if (options.binary === true) {\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = function () {\n          // Binary chunk.\n          const binaryChunk = getPaddedArrayBuffer(reader.result);\n          const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n          binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n          binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n          const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n          const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n          jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n          jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n          const header = new ArrayBuffer(GLB_HEADER_BYTES);\n          const headerView = new DataView(header);\n          headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n          headerView.setUint32(4, GLB_VERSION, true);\n          const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n          headerView.setUint32(8, totalByteLength, true);\n          const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n            type: 'application/octet-stream'\n          });\n          const glbReader = new window.FileReader();\n          glbReader.readAsArrayBuffer(glbBlob);\n\n          glbReader.onloadend = function () {\n            onDone(glbReader.result);\n          };\n        };\n      } else {\n        if (json.buffers && json.buffers.length > 0) {\n          const reader = new window.FileReader();\n          reader.readAsDataURL(blob);\n\n          reader.onloadend = function () {\n            const base64data = reader.result;\n            json.buffers[0].uri = base64data;\n            onDone(json);\n          };\n        } else {\n          onDone(json);\n        }\n      }\n    });\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n\n\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn('THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' + 'won\\'t be serialized because of JSON.stringify error - ' + error.message);\n    }\n  }\n  /**\n   * Assign and return a temporal unique id for an object\n   * especially which doesn't have .uuid\n   * @param  {Object} object\n   * @return {Integer}\n   */\n\n\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n    return this.uids.get(object);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n\n\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n\n\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n\n\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\n\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }]; // All buffers are merged before export.\n\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\n\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\n\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(function (resolve) {\n      const reader = new window.FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = function () {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n\n\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n      const end = start + count;\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n      if (count < 0) count = 0;\n    } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n   * @param  {Boolean} flipY before writing out the image\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\n\n  processImage(image, format, flipY) {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n\n    if (options.embedImages) {\n      const canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      } else {\n        if (format !== RGBAFormat && format !== RGBFormat) {\n          console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        if (format === RGBAFormat) {\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n        } else {\n          for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n            data[i + 0] = image.data[j + 0];\n            data[i + 1] = image.data[j + 1];\n            data[i + 2] = image.data[j + 2];\n            data[i + 3] = 255;\n          }\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      }\n\n      if (options.binary === true) {\n        pending.push(new Promise(function (resolve) {\n          canvas.toBlob(function (blob) {\n            writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n              imageDef.bufferView = bufferViewIndex;\n              resolve();\n            });\n          }, mimeType);\n        }));\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    cachedImages[key] = index;\n    return index;\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\n\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n\n\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY)\n    };\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n\n\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    } // pbrMetallicRoughness.baseColorFactor\n\n\n    const color = material.color.toArray().concat([material.opacity]);\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n    if (material.metalnessMap || material.roughnessMap) {\n      if (material.metalnessMap === material.roughnessMap) {\n        const metalRoughMapDef = {\n          index: this.processTexture(material.metalnessMap)\n        };\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      } else {\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n      }\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if (material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      } // emissiveTexture\n\n\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    } // normalTexture\n\n\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    } // occlusionTexture\n\n\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    } // alphaMode\n\n\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    } // doubleSided\n\n\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n\n\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode; // Use the correct mode\n\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    } // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n\n\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.substr(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n\n      if (accessor !== null) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n            continue;\n          } // Clones attribute not to override\n\n\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n        }\n\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\n\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } // Question: Is saving \"type\" as name intentional?\n\n\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n\n\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n\n\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === undefined) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === undefined) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n\n    if (json.skins === undefined) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n\n\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n\n\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n\n\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n\n\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n\n}\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\n\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    const specularFactor = [1, 1, 1];\n    material.specular.toArray(specularFactor, 0);\n    extensionDef.specularFactor = specularFactor;\n    extensionDef.glossinessFactor = material.glossiness;\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if (material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.thickness === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationTint.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Static utility functions\n */\n\n\nGLTFExporter.Utils = {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      let mergedTrack; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n};\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\n\nconst compatibleObject = object => {\n  // @TODO: Need properer variantMaterials format validation?\n  return object.material !== undefined && // easier than (!object.isMesh && !object.isLine &&\n  // !object.isPoints)\n  object.userData && // just in case\n  object.userData.variantMaterials && // Is this line costly?\n  !!Array.from(object.userData.variantMaterials.values()).filter(m => compatibleMaterial(m.material));\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\n\n\nconst compatibleMaterial = material => {\n  // @TODO: support multi materials?\n  return material && material.isMaterial && !Array.isArray(material);\n};\n\nclass GLTFExporterMaterialsVariantsExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_variants';\n    this.variantNames = [];\n  }\n\n  beforeParse(objects) {\n    // Find all variant names and store them to the table\n    const variantNameSet = new Set();\n\n    for (const object of objects) {\n      object.traverse(o => {\n        if (!compatibleObject(o)) {\n          return;\n        }\n\n        const variantMaterials = o.userData.variantMaterials;\n\n        for (const variantName of variantMaterials.keys()) {\n          const variantMaterial = variantMaterials.get(variantName); // Ignore unloaded variant materials\n\n          if (compatibleMaterial(variantMaterial.material)) {\n            variantNameSet.add(variantName);\n          }\n        }\n      });\n    } // We may want to sort?\n\n\n    variantNameSet.forEach(name => this.variantNames.push(name));\n  }\n\n  writeMesh(mesh, meshDef) {\n    if (!compatibleObject(mesh)) {\n      return;\n    }\n\n    const userData = mesh.userData;\n    const variantMaterials = userData.variantMaterials;\n    const mappingTable = new Map();\n\n    for (const variantName of variantMaterials.keys()) {\n      const variantMaterialInstance = variantMaterials.get(variantName).material;\n\n      if (!compatibleMaterial(variantMaterialInstance)) {\n        continue;\n      }\n\n      const variantIndex = this.variantNames.indexOf(variantName); // Shouldn't be -1\n\n      const materialIndex = this.writer.processMaterial(variantMaterialInstance);\n\n      if (!mappingTable.has(materialIndex)) {\n        mappingTable.set(materialIndex, {\n          material: materialIndex,\n          variants: []\n        });\n      }\n\n      mappingTable.get(materialIndex).variants.push(variantIndex);\n    }\n\n    const mappingsDef = Array.from(mappingTable.values()).map(m => {\n      return m.variants.sort((a, b) => a - b) && m;\n    }).sort((a, b) => a.material - b.material);\n\n    if (mappingsDef.length === 0) {\n      return;\n    }\n\n    const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? this.writer.processMaterial(userData.originalMaterial) : -1;\n\n    for (const primitiveDef of meshDef.primitives) {\n      // Override primitiveDef.material with original material.\n      if (originalMaterialIndex >= 0) {\n        primitiveDef.material = originalMaterialIndex;\n      }\n\n      primitiveDef.extensions = primitiveDef.extensions || {};\n      primitiveDef.extensions[this.name] = {\n        mappings: mappingsDef\n      };\n    }\n  }\n\n  afterParse() {\n    if (this.variantNames.length === 0) {\n      return;\n    }\n\n    const root = this.writer.json;\n    root.extensions = root.extensions || {};\n    const variantsDef = this.variantNames.map(n => {\n      return {\n        name: n\n      };\n    });\n    root.extensions[this.name] = {\n      variants: variantsDef\n    };\n    this.writer.extensionsUsed[this.name] = true;\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst $correlatedObjects = Symbol('correlatedObjects');\nconst $sourceObject = Symbol('sourceObject');\nconst $onUpdate = Symbol('onUpdate');\n/**\n * A SerializableThreeDOMElement is the common primitive of all scene graph\n * elements that have been facaded in the host execution context. It adds\n * a common interface to these elements in support of convenient\n * serializability.\n */\n\nclass ThreeDOMElement {\n  constructor(onUpdate, element, correlatedObjects = null) {\n    this[$onUpdate] = onUpdate;\n    this[$sourceObject] = element;\n    this[$correlatedObjects] = correlatedObjects;\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst loader = new ImageLoader();\nconst quadMaterial = new MeshBasicMaterial();\nconst quad = new PlaneGeometry(2, 2);\nconst $threeTexture = Symbol('threeTexture');\n/**\n * Image facade implementation for Three.js textures\n */\n\nclass Image$1 extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n\n    console.assert(this[$correlatedObjects] != null && this[$correlatedObjects].size > 0, 'Image correlated object is undefined');\n    return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n  }\n\n  constructor(onUpdate, texture, gltfImage) {\n    gltfImage = gltfImage !== null && gltfImage !== void 0 ? gltfImage : {\n      name: 'adhoc_image',\n      uri: texture && texture.image ? texture.image.src : 'adhoc_image'\n    };\n    super(onUpdate, gltfImage, new Set(texture ? [texture] : []));\n  }\n\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n\n  get uri() {\n    return this[$sourceObject].uri;\n  }\n\n  get bufferView() {\n    return this[$sourceObject].bufferView;\n  }\n\n  get type() {\n    return this.uri != null ? 'external' : 'embedded';\n  }\n\n  setURI(uri) {\n    var _this32 = this;\n\n    return _asyncToGenerator(function* () {\n      _this32[$sourceObject].uri = uri;\n      const image = yield new Promise((resolve, reject) => {\n        loader.load(uri, resolve, undefined, reject);\n      });\n      const texture = _this32[$threeTexture];\n      texture.image = image;\n      texture.needsUpdate = true;\n\n      _this32[$onUpdate]();\n    })();\n  }\n\n  createThumbnail(width, height) {\n    var _this33 = this;\n\n    return _asyncToGenerator(function* () {\n      const scene = new Scene();\n      quadMaterial.map = _this33[$threeTexture];\n      const mesh = new Mesh(quad, quadMaterial);\n      scene.add(mesh);\n      const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n      const {\n        threeRenderer\n      } = Renderer.singleton;\n      const renderTarget = new WebGLRenderTarget(width, height);\n      threeRenderer.setRenderTarget(renderTarget);\n      threeRenderer.render(scene, camera);\n      threeRenderer.setRenderTarget(null);\n      const buffer = new Uint8Array(width * height * 4);\n      threeRenderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);\n      blobCanvas.width = width;\n      blobCanvas.height = height;\n      const blobContext = blobCanvas.getContext('2d');\n      const imageData = blobContext.createImageData(width, height);\n      imageData.data.set(buffer);\n      blobContext.putImageData(imageData, 0, 0);\n      return new Promise( /*#__PURE__*/function () {\n        var _ref9 = _asyncToGenerator(function* (resolve, reject) {\n          blobCanvas.toBlob(blob => {\n            if (!blob) {\n              return reject('Failed to capture thumbnail.');\n            }\n\n            resolve(URL.createObjectURL(blob));\n          }, 'image/png');\n        });\n\n        return function (_x16, _x17) {\n          return _ref9.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n\n}\n\nvar Filter;\n\n(function (Filter) {\n  Filter[Filter[\"Nearest\"] = 9728] = \"Nearest\";\n  Filter[Filter[\"Linear\"] = 9729] = \"Linear\";\n  Filter[Filter[\"NearestMipmapNearest\"] = 9984] = \"NearestMipmapNearest\";\n  Filter[Filter[\"LinearMipmapNearest\"] = 9985] = \"LinearMipmapNearest\";\n  Filter[Filter[\"NearestMipmapLinear\"] = 9986] = \"NearestMipmapLinear\";\n  Filter[Filter[\"LinearMipmapLinear\"] = 9987] = \"LinearMipmapLinear\";\n})(Filter || (Filter = {}));\n\nvar Wrap;\n\n(function (Wrap) {\n  Wrap[Wrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n  Wrap[Wrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n  Wrap[Wrap[\"Repeat\"] = 10497] = \"Repeat\";\n})(Wrap || (Wrap = {}));\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst isMinFilter = (() => {\n  const minFilterValues = [Filter.Nearest, Filter.Linear, Filter.NearestMipmapNearest, Filter.LinearMipmapLinear, Filter.NearestMipmapLinear, Filter.LinearMipmapLinear];\n  return value => minFilterValues.indexOf(value) > -1;\n})();\n\nconst isMagFilter = (() => {\n  const magFilterValues = [Filter.Nearest, Filter.Linear];\n  return value => magFilterValues.indexOf(value) > -1;\n})();\n\nconst isWrapMode = (() => {\n  const wrapModes = [Wrap.ClampToEdge, Wrap.MirroredRepeat, Wrap.Repeat];\n  return value => wrapModes.indexOf(value) > -1;\n})();\n\nconst isValidSamplerValue = (property, value) => {\n  switch (property) {\n    case 'minFilter':\n      return isMinFilter(value);\n\n    case 'magFilter':\n      return isMagFilter(value);\n\n    case 'wrapS':\n    case 'wrapT':\n      return isWrapMode(value);\n\n    default:\n      throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n  }\n};\n\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\nconst $sourceSampler = Symbol('sourceSampler');\n/**\n * Sampler facade implementation for Three.js textures\n */\n\nclass Sampler extends ThreeDOMElement {\n  get [$threeTextures]() {\n    console.assert(this[$correlatedObjects] != null && this[$correlatedObjects].size > 0, 'Sampler correlated object is undefined');\n    return this[$correlatedObjects];\n  }\n\n  get [$sourceSampler]() {\n    console.assert(this[$sourceObject] != null, 'Sampler source is undefined');\n    return this[$sourceObject];\n  }\n\n  constructor(onUpdate, texture, gltfSampler) {\n    gltfSampler = gltfSampler !== null && gltfSampler !== void 0 ? gltfSampler : {}; // These defaults represent a convergence of glTF defaults for wrap mode and\n    // Three.js defaults for filters. Per glTF 2.0 spec, a renderer may choose\n    // its own defaults for filters.\n    // @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler\n    // @see https://threejs.org/docs/#api/en/textures/Texture\n\n    if (gltfSampler.minFilter == null) {\n      gltfSampler.minFilter = texture ? texture.minFilter : Filter.LinearMipmapLinear;\n    }\n\n    if (gltfSampler.magFilter == null) {\n      gltfSampler.magFilter = texture ? texture.magFilter : Filter.Linear;\n    }\n\n    if (gltfSampler.wrapS == null) {\n      gltfSampler.wrapS = texture ? texture.wrapS : Wrap.Repeat;\n    }\n\n    if (gltfSampler.wrapT == null) {\n      gltfSampler.wrapT = texture ? texture.wrapT : Wrap.Repeat;\n    }\n\n    super(onUpdate, gltfSampler, new Set(texture ? [texture] : []));\n  }\n\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n\n  get minFilter() {\n    return this[$sourceSampler].minFilter;\n  }\n\n  get magFilter() {\n    return this[$sourceSampler].magFilter;\n  }\n\n  get wrapS() {\n    return this[$sourceSampler].wrapS;\n  }\n\n  get wrapT() {\n    return this[$sourceSampler].wrapT;\n  }\n\n  setMinFilter(filter) {\n    this[$setProperty]('minFilter', filter);\n  }\n\n  setMagFilter(filter) {\n    this[$setProperty]('magFilter', filter);\n  }\n\n  setWrapS(mode) {\n    this[$setProperty]('wrapS', mode);\n  }\n\n  setWrapT(mode) {\n    this[$setProperty]('wrapT', mode);\n  }\n\n  [$setProperty](property, value) {\n    const sampler = this[$sourceSampler];\n\n    if (sampler != null) {\n      if (isValidSamplerValue(property, value)) {\n        sampler[property] = value;\n\n        for (const texture of this[$threeTextures]) {\n          texture[property] = value;\n          texture.needsUpdate = true;\n        }\n      }\n\n      this[$onUpdate]();\n    }\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst $image = Symbol('image');\nconst $sampler = Symbol('sampler');\n/**\n * Material facade implementation for Three.js materials\n */\n\nclass Texture extends ThreeDOMElement {\n  constructor(onUpdate, threeTexture, gltfTexture = null, gltfSampler = null, gltfImage = null) {\n    super(onUpdate, gltfTexture ? gltfTexture : {}, new Set(threeTexture ? [threeTexture] : []));\n    this[$sampler] = new Sampler(onUpdate, threeTexture, gltfSampler);\n    this[$image] = new Image$1(onUpdate, threeTexture, gltfImage);\n  }\n\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n\n  get sampler() {\n    return this[$sampler];\n  }\n\n  get source() {\n    return this[$image];\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a$1;\n\nconst $texture = Symbol('texture');\nconst $materials$1 = Symbol('materials');\nconst $usage = Symbol('usage'); // Defines what a texture will be used for.\n\nvar TextureUsage;\n\n(function (TextureUsage) {\n  TextureUsage[TextureUsage[\"Base\"] = 0] = \"Base\";\n  TextureUsage[TextureUsage[\"MetallicRoughness\"] = 1] = \"MetallicRoughness\";\n  TextureUsage[TextureUsage[\"Normal\"] = 2] = \"Normal\";\n  TextureUsage[TextureUsage[\"Occlusion\"] = 3] = \"Occlusion\";\n  TextureUsage[TextureUsage[\"Emissive\"] = 4] = \"Emissive\";\n})(TextureUsage || (TextureUsage = {}));\n/**\n * TextureInfo facade implementation for Three.js materials\n */\n\n\nclass TextureInfo {\n  constructor(onUpdate, usage, threeTexture, material, gltf, gltfTextureInfo) {\n    this[_a$1] = null; // Creates image, sampler, and texture if valid texture info is provided.\n\n    if (gltfTextureInfo) {\n      const gltfTexture = gltf.textures ? gltf.textures[gltfTextureInfo.index] : null;\n      const sampler = gltfTexture ? gltf.samplers ? gltf.samplers[gltfTexture.sampler] : null : null;\n      const image = gltfTexture ? gltf.images ? gltf.images[gltfTexture.source] : null : null;\n      this[$texture] = new Texture(onUpdate, threeTexture, gltfTexture, sampler, image);\n    }\n\n    this.onUpdate = onUpdate;\n    this[$materials$1] = material;\n    this[$usage] = usage;\n  }\n\n  get texture() {\n    return this[$texture];\n  }\n\n  setTexture(texture) {\n    const threeTexture = texture != null ? texture.source[$threeTexture] : null;\n    let encoding = sRGBEncoding;\n    this[$texture] = texture;\n\n    if (this[$materials$1]) {\n      for (const material of this[$materials$1]) {\n        switch (this[$usage]) {\n          case TextureUsage.Base:\n            material.map = threeTexture;\n            break;\n\n          case TextureUsage.MetallicRoughness:\n            encoding = LinearEncoding;\n            material.metalnessMap = threeTexture;\n            material.roughnessMap = threeTexture;\n            break;\n\n          case TextureUsage.Normal:\n            encoding = LinearEncoding;\n            material.normalMap = threeTexture;\n            break;\n\n          case TextureUsage.Occlusion:\n            encoding = LinearEncoding;\n            material.aoMap = threeTexture;\n            break;\n\n          case TextureUsage.Emissive:\n            material.emissiveMap = threeTexture;\n            break;\n        }\n\n        material.needsUpdate = true;\n      }\n    }\n\n    if (threeTexture) {\n      // Updates the encoding for the texture, affects all references.\n      threeTexture.encoding = encoding;\n    }\n\n    this.onUpdate();\n  }\n\n}\n\n_a$1 = $texture;\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst $threeMaterials = Symbol('threeMaterials');\nconst $baseColorTexture = Symbol('baseColorTexture');\nconst $metallicRoughnessTexture = Symbol('metallicRoughnessTexture');\n/**\n * PBR material properties facade implementation for Three.js materials\n */\n\nclass PBRMetallicRoughness extends ThreeDOMElement {\n  constructor(onUpdate, gltf, pbrMetallicRoughness, correlatedMaterials) {\n    super(onUpdate, pbrMetallicRoughness, correlatedMaterials); // Assign glTF default values\n\n    if (pbrMetallicRoughness.baseColorFactor == null) {\n      pbrMetallicRoughness.baseColorFactor = [1, 1, 1, 1];\n    }\n\n    if (pbrMetallicRoughness.roughnessFactor == null) {\n      pbrMetallicRoughness.roughnessFactor = 1;\n    }\n\n    if (pbrMetallicRoughness.metallicFactor == null) {\n      pbrMetallicRoughness.metallicFactor = 1;\n    }\n\n    const {\n      baseColorTexture: gltfBaseColorTexture,\n      metallicRoughnessTexture: gltfMetallicRoughnessTexture\n    } = pbrMetallicRoughness;\n    const {\n      map,\n      metalnessMap\n    } = correlatedMaterials.values().next().value;\n    this[$baseColorTexture] = new TextureInfo(onUpdate, TextureUsage.Base, map, correlatedMaterials, gltf, gltfBaseColorTexture ? gltfBaseColorTexture : null);\n    this[$metallicRoughnessTexture] = new TextureInfo(onUpdate, TextureUsage.MetallicRoughness, metalnessMap, correlatedMaterials, gltf, gltfMetallicRoughnessTexture ? gltfMetallicRoughnessTexture : null);\n  }\n\n  get [$threeMaterials]() {\n    return this[$correlatedObjects];\n  }\n\n  get baseColorFactor() {\n    return this[$sourceObject].baseColorFactor;\n  }\n\n  get metallicFactor() {\n    return this[$sourceObject].metallicFactor;\n  }\n\n  get roughnessFactor() {\n    return this[$sourceObject].roughnessFactor;\n  }\n\n  get baseColorTexture() {\n    return this[$baseColorTexture];\n  }\n\n  get metallicRoughnessTexture() {\n    return this[$metallicRoughnessTexture];\n  }\n\n  setBaseColorFactor(rgba) {\n    for (const material of this[$threeMaterials]) {\n      material.color.fromArray(rgba);\n      material.opacity = rgba[3];\n    }\n\n    const pbrMetallicRoughness = this[$sourceObject];\n    pbrMetallicRoughness.baseColorFactor = rgba;\n    this[$onUpdate]();\n  }\n\n  setMetallicFactor(value) {\n    for (const material of this[$threeMaterials]) {\n      material.metalness = value;\n    }\n\n    const pbrMetallicRoughness = this[$sourceObject];\n    pbrMetallicRoughness.metallicFactor = value;\n    this[$onUpdate]();\n  }\n\n  setRoughnessFactor(value) {\n    for (const material of this[$threeMaterials]) {\n      material.roughness = value;\n    }\n\n    const pbrMetallicRoughness = this[$sourceObject];\n    pbrMetallicRoughness.roughnessFactor = value;\n    this[$onUpdate]();\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\n/**\n * Material facade implementation for Three.js materials\n */\n\nclass Material extends ThreeDOMElement {\n  constructor(onUpdate, gltf, gltfMaterial, correlatedMaterials) {\n    super(onUpdate, gltfMaterial, correlatedMaterials);\n\n    if (correlatedMaterials == null) {\n      return;\n    }\n\n    if (gltfMaterial.extensions && gltfMaterial.extensions['KHR_materials_pbrSpecularGlossiness']) {\n      console.warn(`Material ${gltfMaterial.name} uses a deprecated extension\n          \"KHR_materials_pbrSpecularGlossiness\", please use\n          \"pbrMetallicRoughness\" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.`);\n    }\n\n    if (gltfMaterial.pbrMetallicRoughness == null) {\n      gltfMaterial.pbrMetallicRoughness = {};\n    }\n\n    this[$pbrMetallicRoughness] = new PBRMetallicRoughness(onUpdate, gltf, gltfMaterial.pbrMetallicRoughness, correlatedMaterials);\n\n    if (gltfMaterial.emissiveFactor == null) {\n      gltfMaterial.emissiveFactor = [0, 0, 0];\n    }\n\n    if (gltfMaterial.doubleSided == null) {\n      gltfMaterial.doubleSided = false;\n    }\n\n    if (gltfMaterial.alphaMode == null) {\n      gltfMaterial.alphaMode = 'OPAQUE';\n    }\n\n    if (gltfMaterial.alphaCutoff == null) {\n      gltfMaterial.alphaCutoff = 0.5;\n    }\n\n    const {\n      normalTexture: gltfNormalTexture,\n      occlusionTexture: gltfOcculsionTexture,\n      emissiveTexture: gltfEmissiveTexture\n    } = gltfMaterial;\n    const {\n      normalMap,\n      aoMap,\n      emissiveMap\n    } = correlatedMaterials.values().next().value;\n    this[$normalTexture] = new TextureInfo(onUpdate, TextureUsage.Normal, normalMap, correlatedMaterials, gltf, gltfNormalTexture ? gltfNormalTexture : null);\n    this[$occlusionTexture] = new TextureInfo(onUpdate, TextureUsage.Occlusion, aoMap, correlatedMaterials, gltf, gltfOcculsionTexture ? gltfOcculsionTexture : null);\n    this[$emissiveTexture] = new TextureInfo(onUpdate, TextureUsage.Emissive, emissiveMap, correlatedMaterials, gltf, gltfEmissiveTexture ? gltfEmissiveTexture : null);\n  }\n\n  get [$backingThreeMaterial]() {\n    return this[$correlatedObjects].values().next().value;\n  }\n\n  get name() {\n    return this[$sourceObject].name || '';\n  }\n\n  get pbrMetallicRoughness() {\n    return this[$pbrMetallicRoughness];\n  }\n\n  get normalTexture() {\n    return this[$normalTexture];\n  }\n\n  get occlusionTexture() {\n    return this[$occlusionTexture];\n  }\n\n  get emissiveTexture() {\n    return this[$emissiveTexture];\n  }\n\n  get emissiveFactor() {\n    return this[$sourceObject].emissiveFactor;\n  }\n\n  setEmissiveFactor(rgb) {\n    for (const material of this[$correlatedObjects]) {\n      material.emissive.fromArray(rgb);\n    }\n\n    this[$sourceObject].emissiveFactor = rgb;\n    this[$onUpdate]();\n  }\n\n  [$applyAlphaCutoff]() {\n    const gltfMaterial = this[$sourceObject]; // 0.0001 is the minimum in order to keep from using zero, which disables\n    // masking in three.js. It's also small enough to be less than the smallest\n    // normalized 8-bit value.\n\n    const cutoff = gltfMaterial.alphaMode === 'OPAQUE' ? ALPHA_CUTOFF_OPAQUE : gltfMaterial.alphaMode === 'BLEND' ? ALPHA_CUTOFF_BLEND : Math.max(0.0001, Math.min(1.0, gltfMaterial.alphaCutoff));\n\n    for (const material of this[$correlatedObjects]) {\n      material.alphaTest = cutoff;\n      material.needsUpdate = true;\n    }\n  }\n\n  setAlphaCutoff(cutoff) {\n    this[$sourceObject].alphaCutoff = cutoff;\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n\n  getAlphaCutoff() {\n    return this[$sourceObject].alphaCutoff;\n  }\n\n  setDoubleSided(doubleSided) {\n    for (const material of this[$correlatedObjects]) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n\n    this[$sourceObject].doubleSided = doubleSided;\n    this[$onUpdate]();\n  }\n\n  getDoubleSided() {\n    return this[$sourceObject].doubleSided;\n  }\n\n  setAlphaMode(alphaMode) {\n    const enableTransparency = (material, enabled) => {\n      material.transparent = enabled;\n      material.depthWrite = !enabled;\n    };\n\n    this[$sourceObject].alphaMode = alphaMode;\n\n    for (const material of this[$correlatedObjects]) {\n      enableTransparency(material, alphaMode !== 'OPAQUE');\n      this[$applyAlphaCutoff]();\n      material.needsUpdate = true;\n    }\n\n    this[$onUpdate]();\n  }\n\n  getAlphaMode() {\n    return this[$sourceObject].alphaMode;\n  }\n\n}\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar _a;\n\nconst $materials = Symbol('materials');\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\n\nclass Model {\n  constructor(correlatedSceneGraph, onUpdate = () => {}) {\n    this[_a] = [];\n    const {\n      gltf,\n      gltfElementMap\n    } = correlatedSceneGraph;\n    gltf.materials.forEach(material => {\n      this[$materials].push(new Material(onUpdate, gltf, material, gltfElementMap.get(material)));\n    });\n  }\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n\n\n  get materials() {\n    return this[$materials];\n  }\n\n}\n\n_a = $materials;\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nconst $currentGLTF = Symbol('currentGLTF');\nconst $model = Symbol('model');\nconst $variants = Symbol('variants');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $textureLoader = Symbol('textureLoader');\nconst $originalGltfJson = Symbol('originalGltfJson');\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\n\nconst SceneGraphMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e;\n\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = undefined;\n      this[_b] = null;\n      this[_c] = [];\n      this[_d] = new TextureLoader();\n      this[_e] = null;\n      this.variantName = undefined;\n      this.orientation = '0 0 0';\n      this.scale = '1 1 1';\n    } // Scene-graph API:\n\n    /** @export */\n\n\n    get model() {\n      return this[$model];\n    }\n\n    get availableVariants() {\n      return this[$variants];\n    }\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n\n\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n\n    [(_a = $model, _b = $currentGLTF, _c = $variants, _d = $textureLoader, _e = $originalGltfJson, $getOnUpdateMethod)]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n\n    createTexture(uri, type = 'image/png') {\n      var _this34 = this;\n\n      return _asyncToGenerator(function* () {\n        const currentGLTF = _this34[$currentGLTF];\n        const texture = yield new Promise(resolve => _this34[$textureLoader].load(uri, resolve));\n\n        if (!currentGLTF || !texture) {\n          return null;\n        } // Applies default settings.\n\n\n        texture.encoding = sRGBEncoding;\n        texture.wrapS = RepeatWrapping;\n        texture.wrapT = RepeatWrapping;\n        texture.flipY = false; // This hack is because GLTFExporter checks if format is RGB vs RGBA to\n        // decide if it should save as JPEG vs PNG. However, TextureLoader sets\n        // format based on if the url ends in .jpg, which does not work for an\n        // ObjectURL like we're passing here. So, to keep from inflating all JPEGs\n        // to PNGs, we allow the user of the API to specify the type.\n\n        if (type === 'image/jpeg') {\n          texture.format = RGBFormat;\n        }\n\n        return new Texture(_this34[$getOnUpdateMethod](), texture);\n      })();\n    }\n\n    updated(changedProperties) {\n      var _superprop_getUpdated2 = () => super.updated,\n          _this35 = this;\n\n      return _asyncToGenerator(function* () {\n        _superprop_getUpdated2().call(_this35, changedProperties);\n\n        if (changedProperties.has('variantName')) {\n          const threeGLTF = _this35[$currentGLTF];\n          const {\n            variantName\n          } = _this35;\n\n          if (threeGLTF == null) {\n            return;\n          }\n\n          const updatedMaterials = yield threeGLTF.correlatedSceneGraph.loadVariant(variantName);\n          const {\n            gltf,\n            gltfElementMap\n          } = threeGLTF.correlatedSceneGraph;\n\n          for (const index of updatedMaterials) {\n            const material = gltf.materials[index];\n            _this35[$model].materials[index] = new Material(_this35[$getOnUpdateMethod](), gltf, material, gltfElementMap.get(material));\n          }\n\n          _this35[$needsRender]();\n        }\n\n        if (changedProperties.has('orientation') || changedProperties.has('scale')) {\n          const {\n            modelContainer\n          } = _this35[$scene];\n          const orientation = parseExpressions(_this35.orientation)[0].terms;\n          const roll = normalizeUnit(orientation[0]).number;\n          const pitch = normalizeUnit(orientation[1]).number;\n          const yaw = normalizeUnit(orientation[2]).number;\n          modelContainer.quaternion.setFromEuler(new Euler(pitch, yaw, roll, 'YXZ'));\n          const scale = parseExpressions(_this35.scale)[0].terms;\n          modelContainer.scale.set(scale[0].number, scale[1].number, scale[2].number);\n\n          _this35[$scene].updateBoundingBox();\n\n          _this35[$scene].updateShadow();\n\n          _this35[$renderer].arRenderer.onUpdateScene();\n\n          _this35[$needsRender]();\n        }\n      })();\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n      this[$variants] = [];\n      const {\n        currentGLTF\n      } = this[$scene];\n\n      if (currentGLTF != null) {\n        const {\n          correlatedSceneGraph\n        } = currentGLTF;\n\n        if (correlatedSceneGraph != null && currentGLTF !== this[$currentGLTF]) {\n          this[$model] = new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        } // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n\n\n        if ('variants' in currentGLTF.userData) {\n          this[$variants] = currentGLTF.userData.variants.slice();\n          this.requestUpdate('variantName');\n        }\n      }\n\n      this[$currentGLTF] = currentGLTF; // TODO: remove this event, as it is synonymous with the load event.\n\n      this.dispatchEvent(new CustomEvent('scene-graph-ready'));\n    }\n    /** @export */\n\n\n    exportScene(options) {\n      var _this36 = this;\n\n      return _asyncToGenerator(function* () {\n        const scene = _this36[$scene];\n        return new Promise( /*#__PURE__*/function () {\n          var _ref10 = _asyncToGenerator(function* (resolve) {\n            // Defaults\n            const opts = {\n              binary: true,\n              onlyVisible: true,\n              maxTextureSize: Infinity,\n              forcePowerOfTwoTextures: false,\n              includeCustomExtensions: false,\n              embedImages: true\n            };\n            Object.assign(opts, options); // Not configurable\n\n            opts.animations = scene.animations;\n            opts.truncateDrawRange = true;\n            const shadow = scene.shadow;\n            let visible = false; // Remove shadow from export\n\n            if (shadow != null) {\n              visible = shadow.visible;\n              shadow.visible = false;\n            }\n\n            const currentGLTF = _this36[$currentGLTF];\n\n            if (currentGLTF != null && 'functions' in currentGLTF.userData && 'ensureLoadVariants' in currentGLTF.userData.functions) {\n              // Ensure all variant materials are loaded because some of them may\n              // not be loaded yet.\n              yield currentGLTF.userData.functions.ensureLoadVariants(scene);\n            }\n\n            const exporter = new GLTFExporter().register(writer => new GLTFExporterMaterialsVariantsExtension(writer));\n            exporter.parse(scene.modelContainer.children[0], gltf => {\n              return resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {\n                type: opts.binary ? 'application/octet-stream' : 'application/json'\n              }));\n            }, opts);\n\n            if (shadow != null) {\n              shadow.visible = visible;\n            }\n          });\n\n          return function (_x18) {\n            return _ref10.apply(this, arguments);\n          };\n        }());\n      })();\n    }\n\n  }\n\n  __decorate$1([property({\n    type: String,\n    attribute: 'variant-name'\n  })], SceneGraphModelViewerElement.prototype, \"variantName\", void 0);\n\n  __decorate$1([property({\n    type: String,\n    attribute: 'orientation'\n  })], SceneGraphModelViewerElement.prototype, \"orientation\", void 0);\n\n  __decorate$1([property({\n    type: String,\n    attribute: 'scale'\n  })], SceneGraphModelViewerElement.prototype, \"scale\", void 0);\n\n  return SceneGraphModelViewerElement;\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof undefined === \"function\") r = undefined(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}; // How much the model will rotate per\n// second in radians:\n\n\nconst DEFAULT_ROTATION_SPEED = Math.PI / 32;\nconst AUTO_ROTATE_DELAY_DEFAULT = 3000;\nconst rotationRateIntrinsics = {\n  basis: [degreesToRadians(numberNode(DEFAULT_ROTATION_SPEED, 'rad'))],\n  keywords: {\n    auto: [null]\n  }\n};\nconst $autoRotateStartTime = Symbol('autoRotateStartTime');\nconst $radiansPerSecond = Symbol('radiansPerSecond');\nconst $syncRotationRate = Symbol('syncRotationRate');\nconst $onCameraChange = Symbol('onCameraChange');\n\nconst StagingMixin = ModelViewerElement => {\n  var _a, _b, _c;\n\n  class StagingModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.autoRotate = false;\n      this.autoRotateDelay = AUTO_ROTATE_DELAY_DEFAULT;\n      this.rotationPerSecond = 'auto';\n      this[_a] = performance.now();\n      this[_b] = 0;\n\n      this[_c] = event => {\n        if (!this.autoRotate) {\n          return;\n        }\n\n        if (event.detail.source === 'user-interaction') {\n          this[$autoRotateStartTime] = performance.now();\n        }\n      };\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this.addEventListener('camera-change', this[$onCameraChange]);\n      this[$autoRotateStartTime] = performance.now();\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.removeEventListener('camera-change', this[$onCameraChange]);\n      this[$autoRotateStartTime] = performance.now();\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoRotate')) {\n        this[$autoRotateStartTime] = performance.now();\n      }\n    }\n\n    [(_a = $autoRotateStartTime, _b = $radiansPerSecond, $syncRotationRate)](style) {\n      this[$radiansPerSecond] = style[0];\n    }\n\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n\n      if (!this.autoRotate || !this[$hasTransitioned]() || this[$renderer].isPresenting) {\n        return;\n      }\n\n      const rotationDelta = Math.min(delta, time - this[$autoRotateStartTime] - this.autoRotateDelay);\n\n      if (rotationDelta > 0) {\n        this[$scene].yaw = this.turntableRotation + this[$radiansPerSecond] * rotationDelta * 0.001;\n      }\n    }\n\n    get turntableRotation() {\n      return this[$scene].yaw;\n    }\n\n    resetTurntableRotation(theta = 0) {\n      this[$scene].yaw = theta;\n    }\n\n  }\n\n  _c = $onCameraChange;\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'auto-rotate'\n  })], StagingModelViewerElement.prototype, \"autoRotate\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'auto-rotate-delay'\n  })], StagingModelViewerElement.prototype, \"autoRotateDelay\", void 0);\n\n  __decorate([style({\n    intrinsics: rotationRateIntrinsics,\n    updateHandler: $syncRotationRate\n  }), property({\n    type: String,\n    attribute: 'rotation-per-second'\n  })], StagingModelViewerElement.prototype, \"rotationPerSecond\", void 0);\n\n  return StagingModelViewerElement;\n};\n/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\n\n\nconst FocusVisiblePolyfillMixin = SuperClass => {\n  var _a;\n\n  const coordinateWithPolyfill = instance => {\n    // If there is no shadow root, there is no need to coordinate with\n    // the polyfill. If we already coordinated with the polyfill, we can\n    // skip subsequent invokcations:\n    if (instance.shadowRoot == null || instance.hasAttribute('data-js-focus-visible')) {\n      return () => {};\n    } // The polyfill might already be loaded. If so, we can apply it to\n    // the shadow root immediately:\n\n\n    if (self.applyFocusVisiblePolyfill) {\n      self.applyFocusVisiblePolyfill(instance.shadowRoot);\n    } else {\n      const coordinationHandler = () => {\n        self.applyFocusVisiblePolyfill(instance.shadowRoot);\n      }; // Otherwise, wait for the polyfill to be loaded lazily. It might\n      // never be loaded, but if it is then we can apply it to the\n      // shadow root at the appropriate time by waiting for the ready\n      // event:\n\n\n      self.addEventListener('focus-visible-polyfill-ready', coordinationHandler, {\n        once: true\n      });\n      return () => {\n        self.removeEventListener('focus-visible-polyfill-ready', coordinationHandler);\n      };\n    }\n\n    return () => {};\n  };\n\n  const $endPolyfillCoordination = Symbol('endPolyfillCoordination'); // IE11 doesn't natively support custom elements or JavaScript class\n  // syntax The mixin implementation assumes that the user will take the\n  // appropriate steps to support both:\n\n  class FocusVisibleCoordinator extends SuperClass {\n    constructor() {\n      super(...arguments);\n      this[_a] = null;\n    } // Attempt to coordinate with the polyfill when connected to the\n    // document:\n\n\n    connectedCallback() {\n      super.connectedCallback && super.connectedCallback();\n\n      if (this[$endPolyfillCoordination] == null) {\n        this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback && super.disconnectedCallback(); // It's important to remove the polyfill event listener when we\n      // disconnect, otherwise we will leak the whole element via window:\n\n      if (this[$endPolyfillCoordination] != null) {\n        this[$endPolyfillCoordination]();\n        this[$endPolyfillCoordination] = null;\n      }\n    }\n\n  }\n\n  _a = $endPolyfillCoordination;\n  return FocusVisibleCoordinator;\n};\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Uncomment these lines to export PMREM textures in Glitch:\n// export {default as TextureUtils} from './three-components/TextureUtils';\n// export * from 'three';\n\n\nconst ModelViewerElement = AnnotationMixin(SceneGraphMixin(StagingMixin(EnvironmentMixin(ControlsMixin(ARMixin(LoadingMixin(AnimationMixin(FocusVisiblePolyfillMixin(ModelViewerElementBase)))))))));\ncustomElements.define('model-viewer', ModelViewerElement);\nexport { ModelViewerElement }; //# sourceMappingURL=model-viewer.js.map","map":null,"metadata":{},"sourceType":"module"}