{"ast":null,"code":"/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\nvar Url = require(\"url\");\n\nvar spawn = require(\"child_process\").spawn;\n\nvar fs = require(\"fs\");\n\nexports.XMLHttpRequest = function () {\n  \"use strict\";\n  /**\n   * Private variables\n   */\n\n  var self = this;\n\n  var http = require(\"http\");\n\n  var https = require(\"https\"); // Holds http.js objects\n\n\n  var request;\n  var response; // Request settings\n\n  var settings = {}; // Disable header blacklist.\n  // Not part of XHR specs.\n\n  var disableHeaderCheck = false; // Set some default headers\n\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n  var headers = {};\n  var headersCase = {}; // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n\n  var forbiddenRequestHeaders = [\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"content-transfer-encoding\", \"cookie\", \"cookie2\", \"date\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]; // These request methods are not allowed\n\n  var forbiddenRequestMethods = [\"TRACE\", \"TRACK\", \"CONNECT\"]; // Send flag\n\n  var sendFlag = false; // Error flag, used when errors occur or abort is called\n\n  var errorFlag = false; // Event listeners\n\n  var listeners = {};\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n  /**\n   * Public vars\n   */\n  // Current state\n\n  this.readyState = this.UNSENT; // default ready state change handler in case one is not set or is set late\n\n  this.onreadystatechange = null; // Result & response\n\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null; // Whether cross-site Access-Control requests should be made using\n  // credentials such as cookies or authorization headers\n\n  this.withCredentials = false;\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n  var isAllowedHttpHeader = function (header) {\n    return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n  };\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n\n  var isAllowedHttpMethod = function (method) {\n    return method && forbiddenRequestMethods.indexOf(method) === -1;\n  };\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n\n\n  this.open = function (method, url, async, user, password) {\n    this.abort();\n    errorFlag = false; // Check for valid request method\n\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": typeof async !== \"boolean\" ? true : async,\n      \"user\": user || null,\n      \"password\": password || null\n    };\n    setState(this.OPENED);\n  };\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n\n\n  this.setDisableHeaderCheck = function (state) {\n    disableHeaderCheck = state;\n  };\n  /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n\n\n  this.setRequestHeader = function (header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n\n    if (!isAllowedHttpHeader(header)) {\n      console.warn(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n      return;\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n\n    header = headersCase[header.toLowerCase()] || header;\n    headersCase[header.toLowerCase()] = header;\n    headers[header] = headers[header] ? headers[header] + ', ' + value : value;\n  };\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n\n\n  this.getResponseHeader = function (header) {\n    if (typeof header === \"string\" && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n\n\n  this.getAllResponseHeaders = function () {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n\n    return result.substr(0, result.length - 2);\n  };\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n\n\n  this.getRequestHeader = function (name) {\n    if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n      return headers[headersCase[name.toLowerCase()]];\n    }\n\n    return \"\";\n  };\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n\n\n  this.send = function (data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false,\n        local = false;\n    var url = Url.parse(settings.url);\n    var host; // Determine the server\n\n    switch (url.protocol) {\n      case \"https:\":\n        ssl = true;\n      // SSL & non-SSL both need host, no break here.\n\n      case \"http:\":\n        host = url.hostname;\n        break;\n\n      case \"file:\":\n        local = true;\n        break;\n\n      case undefined:\n      case null:\n      case \"\":\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    } // Load files off the local filesystem (file://)\n\n\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, \"utf8\", function (error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n          this.status = 200;\n          setState(self.DONE);\n        } catch (e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    } // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n\n\n    var port = url.port || (ssl ? 443 : 80); // Add query string if one is used\n\n    var uri = url.pathname + (url.search ? url.search : \"\"); // Set the defaults if they haven't been set\n\n    for (var name in defaultHeaders) {\n      if (!headersCase[name.toLowerCase()]) {\n        headers[name] = defaultHeaders[name];\n      }\n    } // Set the Host header or the server may reject the request\n\n\n    headers.Host = host;\n\n    if (!(ssl && port === 443 || port === 80)) {\n      headers.Host += \":\" + url.port;\n    } // Set Basic Auth if necessary\n\n\n    if (settings.user) {\n      if (typeof settings.password === \"undefined\") {\n        settings.password = \"\";\n      }\n\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n    } // Set content length header\n\n\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: false,\n      withCredentials: self.withCredentials\n    }; // Reset error flag\n\n    errorFlag = false; // Handle async requests\n\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request; // Request is being sent, set send flag\n\n      sendFlag = true; // As per spec, this is called here for historical reasons.\n\n      self.dispatchEvent(\"readystatechange\"); // Handler for the response\n\n      var responseHandler = function responseHandler(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp; // Check for redirect\n        // @TODO Prevent looped redirects\n\n        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url); // Set host var in case it's used later\n\n          host = url.hostname; // Options for the new request\n\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? \"GET\" : settings.method,\n            headers: headers,\n            withCredentials: self.withCredentials\n          }; // Issue the new request\n\n          request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n          request.end(); // @TODO Check if an XHR event needs to be fired here\n\n          return;\n        }\n\n        response.setEncoding(\"utf8\");\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n        response.on(\"data\", function (chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          } // Don't emit state changes if the connection has been aborted.\n\n\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n        response.on(\"end\", function () {\n          if (sendFlag) {\n            // Discard the end event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n        response.on(\"error\", function (error) {\n          self.handleError(error);\n        });\n      }; // Error handler for the request\n\n\n      var errorHandler = function errorHandler(error) {\n        self.handleError(error);\n      }; // Create the request\n\n\n      request = doRequest(options, responseHandler).on(\"error\", errorHandler); // Node 0.4 and later won't accept empty data. Make sure it's needed.\n\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n      self.dispatchEvent(\"loadstart\");\n    } else {\n      // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\"); // The async request the other Node process executes\n\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\"; // Start the other Node Process, executing this string\n\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n\n      while (fs.existsSync(syncFile)) {// Wait while the sync file is empty\n      }\n\n      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8')); // Kill the child process once the file has data\n\n      syncProc.stdin.end(); // Remove the temporary file\n\n      fs.unlinkSync(contentFile);\n\n      if (resp.err) {\n        self.handleError(resp.err);\n      } else {\n        response = resp.data;\n        self.status = resp.data.statusCode;\n        self.responseText = resp.data.text;\n        setState(self.DONE);\n      }\n    }\n  };\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n\n\n  this.handleError = function (error) {\n    this.status = 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n    this.dispatchEvent('error');\n  };\n  /**\n   * Aborts a request.\n   */\n\n\n  this.abort = function () {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = defaultHeaders;\n    this.status = 0;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n\n    this.readyState = this.UNSENT;\n    this.dispatchEvent('abort');\n  };\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n\n\n  this.addEventListener = function (event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    } // Currently allows duplicate callbacks. Should it?\n\n\n    listeners[event].push(callback);\n  };\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n\n\n  this.removeEventListener = function (event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function (ev) {\n        return ev !== callback;\n      });\n    }\n  };\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n\n\n  this.dispatchEvent = function (event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n\n\n  var setState = function (state) {\n    if (state == self.LOADING || self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\"); // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/Users/artakoroushnia/Desktop/thred-web/node_modules/xmlhttprequest/lib/XMLHttpRequest.js"],"names":["Url","require","spawn","fs","exports","XMLHttpRequest","self","http","https","request","response","settings","disableHeaderCheck","defaultHeaders","headers","headersCase","forbiddenRequestHeaders","forbiddenRequestMethods","sendFlag","errorFlag","listeners","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","readyState","onreadystatechange","responseText","responseXML","status","statusText","withCredentials","isAllowedHttpHeader","header","indexOf","toLowerCase","isAllowedHttpMethod","method","open","url","async","user","password","abort","Error","toString","setState","setDisableHeaderCheck","state","setRequestHeader","value","console","warn","getResponseHeader","getAllResponseHeaders","result","i","substr","length","getRequestHeader","name","send","data","ssl","local","parse","host","protocol","hostname","undefined","readFile","pathname","error","handleError","readFileSync","e","port","uri","search","Host","authBuf","Buffer","Authorization","isBuffer","byteLength","options","path","agent","doRequest","dispatchEvent","responseHandler","resp","statusCode","location","newOptions","on","errorHandler","end","setEncoding","chunk","write","contentFile","process","pid","syncFile","writeFileSync","execString","JSON","stringify","slice","replace","syncProc","argv","existsSync","stdin","unlinkSync","err","text","stack","addEventListener","event","callback","push","removeEventListener","filter","ev","len","call"],"mappings":"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","sourcesContent":["/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar Url = require(\"url\");\nvar spawn = require(\"child_process\").spawn;\nvar fs = require(\"fs\");\n\nexports.XMLHttpRequest = function() {\n  \"use strict\";\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = require(\"http\");\n  var https = require(\"https\");\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\",\n  };\n\n  var headers = {};\n  var headersCase = {};\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n  \n  // Whether cross-site Access-Control requests should be made using\n  // credentials such as cookies or authorization headers\n  this.withCredentials = false;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function(state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request or appends the value if one is already set.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n      return;\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n    header = headersCase[header.toLowerCase()] || header;\n    headersCase[header.toLowerCase()] = header;\n    headers[header] = headers[header] ? headers[header] + ', ' + value : value;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response\n      && response.headers\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    if (typeof name === \"string\" && headersCase[name.toLowerCase()]) {\n      return headers[headersCase[name.toLowerCase()]];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false, local = false;\n    var url = Url.parse(settings.url);\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case \"https:\":\n        ssl = true;\n        // SSL & non-SSL both need host, no break here.\n      case \"http:\":\n        host = url.hostname;\n        break;\n\n      case \"file:\":\n        local = true;\n        break;\n\n      case undefined:\n      case null:\n      case \"\":\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, \"utf8\", function(error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, \"utf8\");\n          this.status = 200;\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : \"\");\n\n    // Set the defaults if they haven't been set\n    for (var name in defaultHeaders) {\n      if (!headersCase[name.toLowerCase()]) {\n        headers[name] = defaultHeaders[name];\n      }\n    }\n\n    // Set the Host header or the server may reject the request\n    headers.Host = host;\n    if (!((ssl && port === 443) || port === 80)) {\n      headers.Host += \":\" + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password === \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers.Authorization = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: false,\n      withCredentials: self.withCredentials\n    };\n\n    // Reset error flag\n    errorFlag = false;\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function responseHandler(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url);\n          // Set host var in case it's used later\n          host = url.hostname;\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? \"GET\" : settings.method,\n            headers: headers,\n            withCredentials: self.withCredentials\n          };\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on(\"error\", errorHandler);\n          request.end();\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n\n        response.setEncoding(\"utf8\");\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n\n        response.on(\"data\", function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n\n        response.on(\"end\", function() {\n          if (sendFlag) {\n            // Discard the end event if the connection has been aborted\n            setState(self.DONE);\n            sendFlag = false;\n          }\n        });\n\n        response.on(\"error\", function(error) {\n          self.handleError(error);\n        });\n      };\n\n      // Error handler for the request\n      var errorHandler = function errorHandler(error) {\n        self.handleError(error);\n      };\n\n      // Create the request\n      request = doRequest(options, responseHandler).on(\"error\", errorHandler);\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var responseText = '';\"\n        + \"var req = doRequest(options, function(response) {\"\n        + \"response.setEncoding('utf8');\"\n        + \"response.on('data', function(chunk) {\"\n        + \"  responseText += chunk;\"\n        + \"});\"\n        + \"response.on('end', function() {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"response.on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"}).on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: error}), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + (data ? \"req.write('\" + JSON.stringify(data).slice(1,-1).replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"req.end();\";\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      while(fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n\n      if (resp.err) {\n        self.handleError(resp.err);\n      } else {\n        response = resp.data;\n        self.status = resp.data.statusCode;\n        self.responseText = resp.data.text;\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function(error) {\n    this.status = 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n    this.dispatchEvent('error');\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = defaultHeaders;\n    this.status = 0;\n    this.responseText = \"\";\n    this.responseXML = \"\";\n\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n    this.dispatchEvent('abort');\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function(event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if (state == self.LOADING || self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\");\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}