{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _asyncToGenerator = require(\"/Users/artakoroushnia/Desktop/thred-web/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\n\nconst filter_1 = require(\"./filter\");\n\nconst constants_1 = require(\"./constants\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n  constructor(channel, stream) {\n    var _a, _b;\n\n    super();\n    this.channel = channel;\n    this.stream = stream;\n    this.channel = channel;\n    this.stream = stream;\n    const splitPath = stream.getMethod().split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n\n    const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  sendMetadata(metadata) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const credentials = _this.stream.getCredentials();\n\n      const credsMetadata = credentials.generateMetadata({\n        service_url: _this.serviceUrl\n      });\n      const resultMetadata = yield metadata;\n\n      try {\n        resultMetadata.merge(yield credsMetadata);\n      } catch (error) {\n        _this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n\n        return Promise.reject('Failed to retrieve auth metadata');\n      }\n\n      if (resultMetadata.get('authorization').length > 1) {\n        _this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n\n        return Promise.reject('\"authorization\" metadata cannot have multiple values');\n      }\n\n      return resultMetadata;\n    })();\n  }\n\n}\n\nexports.CallCredentialsFilter = CallCredentialsFilter;\n\nclass CallCredentialsFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n    this.channel = channel;\n  }\n\n  createFilter(callStream) {\n    return new CallCredentialsFilter(this.channel, callStream);\n  }\n\n}\n\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory; //# sourceMappingURL=call-credentials-filter.js.map","map":null,"metadata":{},"sourceType":"script"}